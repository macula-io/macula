# v0.12.0 NAT Traversal - Complete Implementation Plan

**Version**: v0.12.0
**Status**: In Progress
**Goal**: Complete ALL NAT traversal functionality in a single release
**Published Hex Version**: 0.11.3

---

## Executive Summary

v0.12.0 will deliver **complete NAT traversal** including:
1. Connection pooling (reduce bootstrap load)
2. Direct peer-to-peer hole punching
3. Hierarchical relay architecture for scale

This consolidates what was originally planned as v0.12.x, v0.13.x, and v0.14.x into a single comprehensive release.

---

## Current State Analysis

### What's Implemented (from v0.12.0-dev)

| Component | Status | Completeness | Notes |
|-----------|--------|--------------|-------|
| `macula_nat_system.erl` | ✅ Ready | 100% | Supervisor for NAT subsystem |
| `macula_nat_detector.erl` | ⚠️ Partial | 85% | Missing local port/IP detection |
| `macula_nat_coordinator.erl` | ✅ Ready | 90% | Hole punch coordination works |
| `macula_nat_connector.erl` | ⚠️ Partial | 80% | Relay tunnel needs validation |
| `macula_nat_cache.erl` | ✅ Ready | 95% | TTL cache with DHT integration |
| `macula_hole_punch.erl` | ⚠️ Partial | 75% | Missing cancellation, adaptive timing |
| `macula_peer_discovery.erl` | ✅ Fixed | 100% | Binary key handling fixed |
| `macula_peer_system.erl` | ✅ Fixed | 100% | peer_id for gproc uniqueness |
| Docker NAT simulation | ✅ Ready | 100% | Full Cone, Restricted, Symmetric |
| Chatter demo | ✅ Working | 100% | Cross-NAT messaging verified |

### What's Missing for Complete NAT Traversal

#### 1. Connection Pooling (HIGH PRIORITY)
**Problem**: Every message creates new QUIC connection → bootstrap overload at scale
**Impact**: 1000 nodes sending 1 msg/10sec = 100,000 msg/sec through bootstrap

**Required Components**:
- [ ] `macula_connection_pool.erl` - Persistent connection pool per peer
- [ ] Stream multiplexing over existing connections
- [ ] Connection health monitoring and reconnection
- [ ] LRU eviction for idle connections

#### 2. Direct P2P Hole Punching (HIGH PRIORITY)
**Problem**: All traffic routes through bootstrap even when direct connection possible
**Impact**: Unnecessary latency, bandwidth bottleneck

**Required Fixes**:
- [ ] `macula_nat_detector.erl` - Fix local port/IP detection (lines 306-311, 571-575)
- [ ] `macula_nat_detector.erl` - Fix public IP detection (lines 579-582)
- [ ] `macula_hole_punch.erl` - Implement cancellation
- [ ] `macula_hole_punch.erl` - Add adaptive timing
- [ ] `macula_nat_connector.erl` - Relay tunnel validation (wait for RELAY_READY)
- [ ] Connection upgrade path (relay → direct when hole punch succeeds)

#### 3. Hierarchical Relay Architecture (MEDIUM PRIORITY)
**Problem**: Single bootstrap = single point of failure and bottleneck
**Impact**: Can't scale beyond ~1000 nodes reliably

**Required Components**:
- [ ] `macula_relay_registry.erl` - Track available relay nodes
- [ ] `macula_relay_selector.erl` - Geographic/latency-based relay selection
- [ ] Relay capability advertisement in DHT
- [ ] Automatic relay promotion (nodes with public IPs become relays)

---

## Implementation Plan

### Phase 1: Connection Pooling (Week 1-2)

#### 1.1 Create `macula_connection_pool.erl`

```erlang
-module(macula_connection_pool).
-behaviour(gen_server).

%% API
-export([
    start_link/1,
    get_connection/2,      % Get or create connection to peer
    return_connection/2,   % Return connection to pool
    close_connection/2,    % Force close
    get_stats/0           % Pool statistics
]).

%% Pool configuration
-record(pool_config, {
    max_connections_per_peer = 3 :: pos_integer(),
    max_total_connections = 1000 :: pos_integer(),
    idle_timeout = 300000 :: pos_integer(),  % 5 minutes
    health_check_interval = 30000 :: pos_integer()
}).
```

**Key Features**:
- Connection reuse across multiple messages
- Automatic health checks and reconnection
- LRU eviction when pool full
- Per-peer connection limits

#### 1.2 Integrate with Message Sending

Update `macula_peer_connector.erl` to use pool:

```erlang
%% Before (creates new connection every time)
send_message(Endpoint, Msg) ->
    {ok, Conn} = quicer:connect(Host, Port, Opts),
    quicer:send(Conn, Msg),
    quicer:close(Conn).

%% After (reuses pooled connections)
send_message(Endpoint, Msg) ->
    {ok, Conn} = macula_connection_pool:get_connection(Endpoint, #{}),
    Result = quicer:send(Conn, Msg),
    macula_connection_pool:return_connection(Endpoint, Conn),
    Result.
```

#### 1.3 Tests
- [ ] Pool creation and configuration
- [ ] Connection acquisition and release
- [ ] Idle timeout eviction
- [ ] Health check and reconnection
- [ ] Load testing with 100+ concurrent requests

---

### Phase 2: Complete Hole Punching (Week 2-3)

#### 2.1 Fix NAT Detector

**File**: `src/macula_nat_system/macula_nat_detector.erl`

```erlang
%% FIX: Get actual local QUIC port (line 306-311)
get_local_quic_port() ->
    case whereis(macula_gateway_quic_server) of
        undefined -> 0;
        Pid ->
            case gen_server:call(Pid, get_listener_port) of
                {ok, Port} -> Port;
                _ -> 0
            end
    end.

%% FIX: Get actual local address (line 571-575)
get_local_address() ->
    case inet:getifaddrs() of
        {ok, Interfaces} ->
            find_non_loopback_ipv4(Interfaces);
        _ ->
            {{0, 0, 0, 0}, get_local_quic_port()}
    end.

%% FIX: Detect if we have public IP (line 579-582)
is_relay_capable() ->
    case get_local_address() of
        {{A, _, _, _}, _} when A =/= 10, A =/= 172, A =/= 192 ->
            true;  % Public IP
        _ ->
            %% Check if reflexive address equals local address
            case get_reflexive_address() of
                {ok, ReflexiveAddr} ->
                    {LocalAddr, _} = get_local_address(),
                    ReflexiveAddr == LocalAddr;
                _ ->
                    false
            end
    end.
```

#### 2.2 Fix Hole Punch Cancellation

**File**: `src/macula_nat_system/macula_hole_punch.erl`

```erlang
%% Track active punch attempts
-record(state, {
    active_punches = #{} :: #{reference() => [pid()]}
}).

%% FIX: Implement actual cancellation (line 96-100)
cancel(Ref) ->
    gen_server:call(?MODULE, {cancel, Ref}).

handle_call({cancel, Ref}, _From, State) ->
    case maps:get(Ref, State#state.active_punches, []) of
        [] ->
            {reply, {error, not_found}, State};
        Pids ->
            [exit(Pid, cancelled) || Pid <- Pids],
            NewState = State#state{
                active_punches = maps:remove(Ref, State#state.active_punches)
            },
            {reply, ok, NewState}
    end.
```

#### 2.3 Add Connection Upgrade

**New File**: `src/macula_nat_system/macula_connection_upgrade.erl`

```erlang
-module(macula_connection_upgrade).

%% Upgrade relay connection to direct when hole punch succeeds
-spec upgrade_to_direct(pid(), pid()) -> ok | {error, term()}.
upgrade_to_direct(RelayConn, DirectConn) ->
    %% 1. Pause new messages on relay
    %% 2. Drain in-flight messages
    %% 3. Switch routing table entry
    %% 4. Close relay connection gracefully
    ok.
```

#### 2.4 Tests
- [ ] NAT type detection accuracy
- [ ] Hole punch success rate by NAT type
- [ ] Cancellation cleans up resources
- [ ] Connection upgrade preserves messages

---

### Phase 3: Hierarchical Relay (Week 3-4)

#### 3.1 Relay Registry

**New File**: `src/macula_relay_system/macula_relay_registry.erl`

```erlang
-module(macula_relay_registry).
-behaviour(gen_server).

%% Track nodes that can act as relays
-record(relay_info, {
    node_id :: binary(),
    endpoint :: {inet:ip_address(), inet:port_number()},
    region :: binary(),           % Geographic region
    load :: float(),              % Current load 0.0-1.0
    latency_samples :: [integer()], % RTT samples
    last_seen :: integer()
}).

%% API
-export([
    register_relay/2,     % Node advertises as relay
    get_best_relay/1,     % Get optimal relay for target
    get_relays_in_region/1,
    report_latency/3
]).
```

#### 3.2 Relay Selection Strategy

**New File**: `src/macula_relay_system/macula_relay_selector.erl`

```erlang
-module(macula_relay_selector).

%% Selection strategies
-type strategy() ::
    nearest |           % Lowest latency
    least_loaded |      % Lowest current load
    regional |          % Same geographic region
    random.             % Random selection

-spec select_relay(binary(), strategy()) ->
    {ok, relay_info()} | {error, no_relays}.

%% Fallback chain: regional → nearest → least_loaded → any
select_relay(TargetNodeId, Strategy) ->
    case do_select(TargetNodeId, Strategy) of
        {ok, Relay} -> {ok, Relay};
        {error, _} -> select_relay(TargetNodeId, next_strategy(Strategy))
    end.
```

#### 3.3 Automatic Relay Promotion

Nodes with public IPs automatically advertise as relays:

```erlang
%% In macula_nat_detector.erl, after detection completes
maybe_advertise_as_relay(Profile) ->
    case Profile#nat_profile.can_receive_unsolicited of
        true ->
            %% We have public IP or port-forwarded
            macula_relay_registry:register_relay(self(), #{
                endpoint => Profile#nat_profile.reflexive_address,
                capacity => estimate_relay_capacity()
            });
        false ->
            ok
    end.
```

#### 3.4 Tests
- [ ] Relay registration and discovery
- [ ] Geographic routing
- [ ] Load balancing
- [ ] Relay failover

---

## Architecture After v0.12.0

### Before (Current - Hub and Spoke)

```
          ┌─────────────┐
          │  Bootstrap  │  ← ALL traffic flows here
          │   Gateway   │
          └──────┬──────┘
       ┌─────────┼─────────┐
       │         │         │
   ┌───▼───┐ ┌───▼───┐ ┌───▼───┐
   │Peer A │ │Peer B │ │Peer C │
   │ (NAT) │ │ (NAT) │ │ (NAT) │
   └───────┘ └───────┘ └───────┘
```

### After (v0.12.0 - Mesh with Fallback)

```
                    ┌─────────────┐
                    │  Bootstrap  │  ← Only DHT queries
                    │   (Seed)    │     and fallback relay
                    └──────┬──────┘
                           │
    ┌──────────────────────┼──────────────────────┐
    │                      │                      │
┌───▼───┐  ←── direct ──►  ┌───▼───┐  ←── direct ──►  ┌───▼───┐
│Peer A │                  │Peer B │                  │Peer C │
│(Relay)│  ←───────────────│ (NAT) │───────────────►  │ (NAT) │
└───────┘      relay       └───────┘      relay       └───────┘
    ▲          fallback                   fallback        ▲
    │                                                     │
    └─────────────────── direct (hole punch) ─────────────┘
```

### Connection Strategy Decision Tree

```
1. Check NAT profiles of both peers
   │
   ├─► Both have public IPs? → DIRECT connection
   │
   ├─► Compatible NAT types? → HOLE PUNCH attempt
   │   │
   │   ├─► Success? → Use direct connection
   │   │
   │   └─► Failure? → Fall through to relay
   │
   └─► Find best relay
       │
       ├─► Regional relay available? → Use regional relay
       │
       ├─► Any relay available? → Use nearest relay
       │
       └─► No relays? → Use bootstrap as last resort
```

---

## Success Metrics

| Metric | Current | Target | Measurement |
|--------|---------|--------|-------------|
| Direct P2P connections | 0% | 80%+ | % of connections not using relay |
| Bootstrap bandwidth | 100% | <20% | Traffic through bootstrap |
| Message latency | 2 hops | 1 hop avg | RTT measurement |
| Max supported nodes | ~100 | 1000+ | Load test |
| Connection reuse rate | 0% | 95%+ | Pool hit rate |

---

## Testing Strategy

### Unit Tests (per module)
- `test/macula_connection_pool_tests.erl` - Pool operations
- `test/macula_relay_registry_tests.erl` - Relay tracking
- `test/macula_relay_selector_tests.erl` - Selection strategies
- `test/macula_connection_upgrade_tests.erl` - Upgrade flow

### Integration Tests
- `test/macula_nat_e2e_tests.erl` - End-to-end NAT scenarios
- Docker NAT simulation with all NAT types
- 10-node mesh formation test
- Connection upgrade under load

### Performance Tests
- 100-node simulated mesh
- Message throughput before/after connection pooling
- Hole punch success rate by NAT combination
- Relay selection latency

---

## Files to Create/Modify

### New Files
| File | Purpose |
|------|---------|
| `src/macula_connection_pool.erl` | Connection pooling |
| `src/macula_relay_system/macula_relay_registry.erl` | Relay tracking |
| `src/macula_relay_system/macula_relay_selector.erl` | Relay selection |
| `src/macula_relay_system/macula_relay_system.erl` | Relay supervisor |
| `src/macula_nat_system/macula_connection_upgrade.erl` | Upgrade flow |

### Files to Modify
| File | Changes |
|------|---------|
| `src/macula_nat_system/macula_nat_detector.erl` | Fix local port/IP detection |
| `src/macula_nat_system/macula_hole_punch.erl` | Cancellation, adaptive timing |
| `src/macula_nat_system/macula_nat_connector.erl` | Relay validation, pool integration |
| `src/macula_peer_system/macula_peer_connector.erl` | Use connection pool |
| `src/macula_root.erl` | Start relay system supervisor |

---

## Timeline

| Week | Phase | Deliverables |
|------|-------|--------------|
| 1 | Connection Pool | `macula_connection_pool.erl`, integration |
| 2 | Hole Punch Fixes | NAT detector fixes, cancellation |
| 3 | Relay System | Registry, selector, promotion |
| 4 | Testing & Polish | E2E tests, performance validation |

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Hole punch success rate lower than expected | Relay overload | Conservative strategy selection, more relays |
| Connection pool memory usage | OOM | LRU eviction, max limits |
| Relay selection latency | Slow connection setup | Cache relay info, pre-warm connections |
| Complexity increase | Bugs, maintenance | Comprehensive tests, clear module boundaries |

---

## Document History

| Date | Author | Changes |
|------|--------|---------|
| 2025-11-29 | Claude | Initial comprehensive plan |

---

**Next Steps**:
1. Review and approve this plan
2. Start Phase 1: Connection Pooling
3. Update CLAUDE.md and ROADMAP.md as work progresses
