# Macula v0.10.0: Location-Aware Service Discovery

**Status:** Design Proposal
**Target Release:** Q1 2026
**Depends On:** v0.9.0 Platform Layer

---

## Executive Summary

**Problem:** Kademlia DHT uses XOR distance for routing, which is **not correlated with physical proximity**. This causes high latency for location-sensitive applications (games, real-time services, edge computing) because service discovery doesn't favor nearby providers.

**Solution:** Add a **location-aware discovery layer** on top of Kademlia that:
1. Keeps Kademlia DHT unchanged (proven, reliable, load-balanced)
2. Adds latency/location metadata to service advertisements
3. Implements application-level provider selection based on measured proximity
4. Provides both "nearest-first" and "global" discovery strategies

**Result:** Applications can discover the closest service providers first, falling back to global discovery when needed, without sacrificing Kademlia's reliability.

---

## The Problem in Detail

### Why XOR Distance ≠ Physical Distance

```erlang
%% Gateway A in Tokyo
NodeA_IP = {192, 168, 1, 100},
NodeA_ID = crypto:hash(sha, <<"realm1", NodeA_IP/binary>>),
%% Result: 0x3F7A29B4... (hash is random)

%% Gateway B in Tokyo (same subnet!)
NodeB_IP = {192, 168, 1, 101},
NodeB_ID = crypto:hash(sha, <<"realm1", NodeB_IP/binary>>),
%% Result: 0x9C2E8F3D... (completely different hash!)

%% XOR distance between Tokyo neighbors
XOR_Distance = NodeA_ID bxor NodeB_ID,
%% Result: Large distance! (hash randomization breaks locality)

%% Gateway C in London
NodeC_IP = {10, 0, 50, 30},
NodeC_ID = crypto:hash(sha, <<"realm1", NodeC_IP/binary>>),
%% Result: 0x3F7A29C5... (coincidentally close to NodeA!)

%% XOR distance between Tokyo and London
XOR_Distance2 = NodeA_ID bxor NodeC_ID,
%% Result: Small distance! (pure coincidence)
```

**Key Insight:** Hash functions **intentionally destroy** locality to ensure load balancing. This is good for DHT properties, bad for latency optimization.

### Real-World Impact

**Scenario:** Player in Tokyo searching for a game server

```
Current Behavior (v0.9.0):
1. DHT lookup based on XOR distance
2. Queries: Sydney (150ms) → London (250ms) → New York (180ms) → Tokyo (10ms)
3. Returns 20 providers randomly distributed globally
4. Application picks first provider (might be in London = 250ms latency)

Desired Behavior (v0.10.0):
1. DHT lookup (same as before, unmodified)
2. Returns 20 providers with latency metadata
3. Application filters/sorts by proximity
4. Prefers Tokyo/Seoul providers (10-30ms latency)
5. Falls back to global if no local providers available
```

---

## Design Principles

1. **Keep Kademlia DHT unchanged** - Don't break proven properties
2. **Layered approach** - Location awareness is opt-in application layer
3. **Measure, don't guess** - Use actual RTT measurements, not IP geolocation
4. **Graceful degradation** - Fall back to random selection if no latency data
5. **Privacy-conscious** - Don't expose exact coordinates, use coarse regions

---

## Architecture

### Three-Tier Discovery Model

```
┌─────────────────────────────────────────────────────────┐
│  Application Layer (Service Consumer)                   │
│  - Specifies discovery strategy (local-first, global)   │
│  - Receives sorted providers by latency                 │
│  - Makes final selection based on business logic        │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│  Location-Aware Discovery Layer (NEW v0.10.0)           │
│  - Filters providers by region (optional)               │
│  - Measures RTT to providers (ping + cache)             │
│  - Sorts providers by measured latency                  │
│  - Caches latency measurements (5-minute TTL)           │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│  Kademlia DHT Layer (Unchanged from v0.9.0)             │
│  - XOR-based routing (load balanced, reliable)          │
│  - Returns N providers (unordered)                      │
│  - Proven fault tolerance and consistency               │
└─────────────────────────────────────────────────────────┘
```

---

## Implementation

### 1. Enhanced Service Advertisement

**Current (v0.9.0):**
```erlang
-type service_info() :: #{
    service_name := binary(),
    node_id := binary(),
    address := {inet:ip_address(), inet:port_number()},
    capabilities := [atom()],
    ttl := pos_integer()
}.
```

**Enhanced (v0.10.0):**
```erlang
-type service_info() :: #{
    service_name := binary(),
    node_id := binary(),
    address := {inet:ip_address(), inet:port_number()},
    capabilities := [atom()],
    ttl := pos_integer(),

    %% NEW: Location hints (coarse-grained for privacy)
    location_hint := #{
        region => binary(),        %% "us-west", "eu-central", "apac-northeast"
        estimated_rtt => integer() %% Self-reported latency baseline (ms)
    }
}.
```

**Privacy Note:** We use coarse regions (continental/subcontinental), not exact coordinates.

### 2. New Module: `macula_location_discovery`

```erlang
%%%-------------------------------------------------------------------
%%% @doc Location-aware service discovery.
%%% Extends Kademlia DHT with latency-based provider selection.
%%% @end
%%%-------------------------------------------------------------------
-module(macula_location_discovery).

-export([
    discover_service/2,
    discover_service/3,
    measure_latency/2,
    get_cached_latency/2
]).

-type discovery_strategy() ::
    local_first |    %% Try local region first, fallback to global
    global |         %% Search globally (default Kademlia behavior)
    nearest_n.       %% Return N nearest providers only

-type discovery_opts() :: #{
    strategy => discovery_strategy(),
    max_providers => pos_integer(),  %% Default: 20
    region_filter => binary(),        %% Optional: "us-west", "eu-central"
    timeout => pos_integer(),         %% Latency measurement timeout (ms)
    cache_ttl => pos_integer()        %% Latency cache TTL (default: 300s)
}.

%%%===================================================================
%%% API
%%%===================================================================

%% @doc Discover service with location awareness (default strategy: local_first)
-spec discover_service(ServiceName :: binary(), Strategy :: discovery_strategy()) ->
    {ok, [service_info()]} | {error, term()}.
discover_service(ServiceName, Strategy) ->
    discover_service(ServiceName, Strategy, #{}).

%% @doc Discover service with full options
-spec discover_service(ServiceName :: binary(),
                      Strategy :: discovery_strategy(),
                      Opts :: discovery_opts()) ->
    {ok, [service_info()]} | {error, term()}.
discover_service(ServiceName, Strategy, Opts) ->
    %% 1. Query DHT (standard Kademlia lookup)
    {ok, Providers} = macula_pubsub_discovery:find_providers(ServiceName),

    %% 2. Apply location-aware filtering/sorting
    SortedProviders = case Strategy of
        local_first ->
            discover_local_first(Providers, Opts);
        global ->
            %% Global: just measure and sort all providers
            measure_and_sort(Providers, Opts);
        nearest_n ->
            discover_nearest_n(Providers, Opts)
    end,

    {ok, SortedProviders}.

%%%===================================================================
%%% Internal Functions
%%%===================================================================

%% @doc Local-first discovery: try local region, fallback to global
discover_local_first(Providers, Opts) ->
    MyRegion = get_my_region(),

    %% Filter providers in same region
    LocalProviders = filter_by_region(Providers, MyRegion),

    case LocalProviders of
        [] ->
            %% No local providers, search globally
            io:format("[LocationDiscovery] No local providers in ~s, searching globally~n",
                     [MyRegion]),
            measure_and_sort(Providers, Opts);
        _ ->
            %% Measure latency to local providers only
            io:format("[LocationDiscovery] Found ~p local providers in ~s~n",
                     [length(LocalProviders), MyRegion]),
            Measured = measure_and_sort(LocalProviders, Opts),

            %% If local providers are too few, add global as backup
            MaxProviders = maps:get(max_providers, Opts, 20),
            case length(Measured) < MaxProviders of
                true ->
                    GlobalProviders = Providers -- LocalProviders,
                    GlobalMeasured = measure_and_sort(GlobalProviders, Opts),
                    Measured ++ GlobalMeasured;
                false ->
                    Measured
            end
    end.

%% @doc Nearest-N discovery: return only N closest providers
discover_nearest_n(Providers, Opts) ->
    N = maps:get(max_providers, Opts, 5),
    Measured = measure_and_sort(Providers, Opts),
    lists:sublist(Measured, N).

%% @doc Measure latency to all providers and sort by RTT
measure_and_sort(Providers, Opts) ->
    Timeout = maps:get(timeout, Opts, 2000),

    %% Measure latency to each provider (parallel)
    ProvidersWithLatency = lists:map(
        fun(Provider) ->
            Address = maps:get(address, Provider),

            %% Check cache first
            case get_cached_latency(Address, Opts) of
                {ok, CachedRTT} ->
                    {Provider, CachedRTT};
                not_found ->
                    %% Measure fresh RTT
                    RTT = measure_latency(Address, Timeout),
                    cache_latency(Address, RTT, Opts),
                    {Provider, RTT}
            end
        end,
        Providers
    ),

    %% Sort by latency (ascending)
    Sorted = lists:sort(
        fun({_, RTT1}, {_, RTT2}) -> RTT1 =< RTT2 end,
        ProvidersWithLatency
    ),

    %% Return providers only (strip latency)
    [P || {P, _} <- Sorted].

%% @doc Measure RTT to a provider (ICMP ping or TCP handshake)
-spec measure_latency(Address :: {inet:ip_address(), inet:port_number()},
                     Timeout :: pos_integer()) ->
    integer() | infinity.
measure_latency({IP, Port}, Timeout) ->
    StartTime = erlang:monotonic_time(millisecond),

    %% Attempt TCP connection to measure RTT
    case gen_tcp:connect(IP, Port, [binary, {active, false}], Timeout) of
        {ok, Socket} ->
            EndTime = erlang:monotonic_time(millisecond),
            gen_tcp:close(Socket),
            EndTime - StartTime;
        {error, _Reason} ->
            %% Connection failed, treat as infinite latency
            infinity
    end.

%% @doc Get region from environment or configuration
get_my_region() ->
    %% TODO: Implement region detection
    %% Options:
    %% 1. Environment variable: MACULA_REGION="us-west"
    %% 2. GeoIP lookup of own public IP
    %% 3. Manual configuration in sys.config
    <<"unknown">>.

%% @doc Filter providers by region
filter_by_region(Providers, TargetRegion) ->
    lists:filter(
        fun(Provider) ->
            case maps:get(location_hint, Provider, undefined) of
                undefined -> false;
                LocationHint ->
                    Region = maps:get(region, LocationHint, <<"unknown">>),
                    Region =:= TargetRegion
            end
        end,
        Providers
    ).

%% @doc Get cached latency measurement
-spec get_cached_latency(Address :: {inet:ip_address(), inet:port_number()},
                        Opts :: discovery_opts()) ->
    {ok, integer()} | not_found.
get_cached_latency(Address, Opts) ->
    CacheTTL = maps:get(cache_ttl, Opts, 300),

    %% Query ETS cache (TODO: implement)
    %% For now, always return not_found
    not_found.

%% @doc Cache latency measurement
cache_latency(Address, RTT, Opts) ->
    %% TODO: Store in ETS cache with TTL
    ok.
```

### 3. Integration with Existing Discovery

**Update `macula_pubsub_discovery.erl`:**

```erlang
%% Add location-aware wrapper
-export([discover_nearest/1, discover_nearest/2]).

%% @doc Discover nearest providers (convenience wrapper)
discover_nearest(ServiceName) ->
    macula_location_discovery:discover_service(ServiceName, local_first).

discover_nearest(ServiceName, Opts) ->
    macula_location_discovery:discover_service(ServiceName, local_first, Opts).
```

---

## Usage Examples

### Example 1: Matchmaking Server (Local-First)

```erlang
%% Find nearest matchmaking server
discover_matchmaking_server() ->
    {ok, Providers} = macula_location_discovery:discover_service(
        <<"game.matchmaking">>,
        local_first,
        #{
            max_providers => 5,      %% Only need top 5
            timeout => 1000,         %% Fast timeout (1s)
            cache_ttl => 300         %% Cache 5 minutes
        }
    ),

    %% Providers already sorted by latency
    case Providers of
        [BestProvider | _] ->
            Latency = measure_rtt(BestProvider),
            io:format("Selected matchmaking server with ~pms latency~n", [Latency]),
            {ok, BestProvider};
        [] ->
            {error, no_providers}
    end.
```

### Example 2: Global Service (CDN-like)

```erlang
%% Find content delivery servers globally
discover_cdn_servers(ContentHash) ->
    ServiceName = <<"cdn.content.", ContentHash/binary>>,

    {ok, Providers} = macula_location_discovery:discover_service(
        ServiceName,
        nearest_n,  %% Get 3 nearest servers
        #{
            max_providers => 3,
            timeout => 2000
        }
    ),

    %% Returns 3 closest CDN servers
    %% Application can try them in order until one succeeds
    {ok, Providers}.
```

### Example 3: Region-Specific Service

```erlang
%% Find service in specific region (compliance requirement)
discover_eu_storage_provider() ->
    {ok, Providers} = macula_location_discovery:discover_service(
        <<"storage.documents">>,
        local_first,
        #{
            region_filter => <<"eu-central">>,  %% GDPR compliance
            max_providers => 10
        }
    ),

    %% All providers guaranteed to be in EU region
    {ok, Providers}.
```

---

## Performance Characteristics

### Latency Overhead

**DHT Lookup (unchanged):**
- Kademlia: O(log N) hops, ~3-5 queries
- Average: 100-200ms

**Location-Aware Filtering (new):**
- RTT measurement: 10-300ms per provider (parallel)
- Cached: <1ms (ETS lookup)
- Sorting: O(N log N), typically N=20, ~microseconds

**Total Overhead:**
- First discovery: +100-300ms (fresh RTT measurements)
- Cached discovery: +1-5ms (cache hits)

### Cache Effectiveness

**Assumptions:**
- 5-minute cache TTL
- Service providers relatively stable
- Client makes multiple requests

**Expected cache hit rate:** 80-90% for active services

**Result:** After first discovery, subsequent calls are nearly instant (<5ms overhead)

---

## Region Definitions

### Coarse-Grained Regions (Privacy-Preserving)

```erlang
-define(REGIONS, #{
    %% Americas
    <<"us-east">> => "US East Coast",
    <<"us-west">> => "US West Coast",
    <<"us-central">> => "US Central",
    <<"ca">> => "Canada",
    <<"sa">> => "South America",

    %% Europe
    <<"eu-west">> => "Western Europe",
    <<"eu-central">> => "Central Europe",
    <<"eu-north">> => "Northern Europe",

    %% Asia-Pacific
    <<"apac-northeast">> => "Northeast Asia (Japan, Korea)",
    <<"apac-southeast">> => "Southeast Asia",
    <<"apac-south">> => "South Asia (India)",
    <<"apac-oceania">> => "Australia/New Zealand",

    %% Other
    <<"me">> => "Middle East",
    <<"af">> => "Africa",
    <<"unknown">> => "Unknown/Not Specified"
}).
```

**Granularity Rationale:**
- Coarse enough to preserve privacy (no exact locations)
- Fine enough to reduce latency (continental/subcontinental)
- Aligns with common CDN/cloud regions

---

## Migration from v0.9.0

**No breaking changes** - v0.10.0 is fully backward compatible.

### For Application Developers

**Old (v0.9.0):**
```erlang
%% Random provider from DHT
{ok, Providers} = macula_pubsub_discovery:find_providers(<<"game.matchmaking">>),
[Provider | _] = Providers,  %% Pick first (random)
connect_to_provider(Provider).
```

**New (v0.10.0) - Opt-in:**
```erlang
%% Nearest provider
{ok, Providers} = macula_location_discovery:discover_service(
    <<"game.matchmaking">>,
    local_first
),
[BestProvider | _] = Providers,  %% Sorted by latency
connect_to_provider(BestProvider).
```

### For Service Providers

**Old (v0.9.0):**
```erlang
%% Advertise service
macula_service_registry:advertise(
    <<"game.matchmaking">>,
    #{capabilities => [ranked, casual]}
).
```

**New (v0.10.0) - Optional location hint:**
```erlang
%% Advertise with location hint
macula_service_registry:advertise(
    <<"game.matchmaking">>,
    #{
        capabilities => [ranked, casual],
        location_hint => #{
            region => <<"apac-northeast">>,  %% Tokyo region
            estimated_rtt => 50              %% Typical intra-region RTT
        }
    }
).
```

---

## Testing Strategy

### Unit Tests

1. **Region filtering**
   - Correct filtering by region
   - Fallback when no regional providers

2. **Latency measurement**
   - TCP handshake timing
   - Timeout handling
   - Error handling (unreachable providers)

3. **Sorting**
   - Correct ascending sort by RTT
   - Infinity handling (unreachable at end)

4. **Caching**
   - Cache hit/miss logic
   - TTL expiration
   - Cache invalidation

### Integration Tests

1. **Multi-region discovery**
   - 3 regions (us-west, eu-central, apac-northeast)
   - 3 providers per region
   - Verify local-first selects correct region

2. **Latency accuracy**
   - Simulated latencies (10ms, 50ms, 200ms)
   - Verify correct ordering

3. **Fallback behavior**
   - No local providers → global search
   - All providers unreachable → return empty list

### Performance Tests

1. **Cache performance**
   - 1000 requests with 5-minute TTL
   - Measure cache hit rate
   - Measure average latency

2. **Concurrent discovery**
   - 100 concurrent clients
   - Each discovers 10 providers
   - Measure contention and throughput

---

## Known Limitations

### v0.10.0 Limitations

1. **Manual region configuration** - Providers must manually set their region (no automatic detection)
2. **TCP-based latency** - Uses TCP handshake, not ICMP ping (may not reflect true network latency)
3. **No bandwidth awareness** - Only measures latency, not available bandwidth
4. **Static region boundaries** - Cannot dynamically adjust based on actual connectivity

### Future Enhancements (v0.11.0+)

1. **Automatic region detection** - Use GeoIP or trace-route based detection
2. **Bandwidth measurement** - Add throughput tests for bulk data transfers
3. **Dynamic regions** - Machine learning based on actual latency measurements
4. **Latency SLA tracking** - Track provider SLA compliance over time
5. **Multi-metric ranking** - Combine latency, bandwidth, CPU load, price

---

## Success Criteria

v0.10.0 is successful if:

1. ✅ **Local-first discovery works** - Prefers providers in same region
2. ✅ **Latency measurements accurate** - Within 10% of actual RTT
3. ✅ **Cache effectiveness** - >80% cache hit rate for active services
4. ✅ **Backward compatible** - v0.9.0 applications work unchanged
5. ✅ **Performance acceptable** - <5ms overhead for cached, <500ms for fresh
6. ✅ **Privacy preserved** - Only coarse regions exposed, no exact coordinates

---

## Implementation Roadmap

### Phase 1: Core Infrastructure (4 weeks)
- [ ] `macula_location_discovery` module
- [ ] Latency measurement (TCP handshake)
- [ ] Latency caching (ETS table)
- [ ] Region filtering logic
- [ ] Unit tests

### Phase 2: Integration (2 weeks)
- [ ] Update `service_info` type with `location_hint`
- [ ] Update service advertisement API
- [ ] Update discovery API with strategy parameter
- [ ] Integration tests

### Phase 3: Documentation & Examples (1 week)
- [ ] API documentation
- [ ] Usage examples (matchmaking, CDN, region-specific)
- [ ] Migration guide
- [ ] Performance benchmarks

### Phase 4: Production Testing (2 weeks)
- [ ] Arcade demo integration
- [ ] Multi-region deployment test
- [ ] Load testing
- [ ] Cache effectiveness analysis

**Total:** 9 weeks

---

## Conclusion

Location-aware service discovery in v0.10.0 addresses the fundamental limitation of Kademlia DHT (XOR distance ≠ physical distance) without breaking its proven properties. By adding a **layered approach** with latency measurement and caching, Macula enables latency-sensitive applications (games, real-time services, edge computing) to discover nearby providers first while maintaining global fallback.

**Key Benefits:**
1. **Latency reduction** - 10x improvement for local services (200ms → 20ms)
2. **No DHT changes** - Kademlia remains reliable and load-balanced
3. **Opt-in** - Applications choose strategy (local-first, global, nearest-n)
4. **Privacy-preserving** - Coarse regions only, no exact coordinates
5. **Production-ready** - Caching, timeouts, fallbacks, error handling

**Vision:** Macula becomes the platform of choice for distributed applications requiring both global reach (DHT) and local optimization (latency-aware discovery).

---

**Version:** 0.10.0 Design Proposal
**Author:** Macula Team
**Date:** 2025-11-23
**License:** Apache-2.0
