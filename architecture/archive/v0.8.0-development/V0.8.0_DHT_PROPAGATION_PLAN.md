# Macula v0.8.0 - DHT Propagation Implementation Plan

**Date**: 2025-11-17
**Status**: Planning Document
**Goal**: Implement full Kademlia DHT STORE/FIND_VALUE propagation

---

## Current State

### What Works ✅
- **Local Storage**: `store_local/3` and `get_local/2` work perfectly
- **Message Handling**: Nodes can receive and process STORE/FIND_VALUE messages
- **Protocol**: `macula_routing_protocol` has full encoding/decoding support
- **Routing Table**: Kademlia routing table maintains peer information
- **Test Framework**: 7/11 integration tests passing, validating infrastructure

### What's Missing ❌
- **DHT STORE Propagation**: Values stored locally don't propagate to k closest nodes
- **DHT FIND_VALUE Lookup**: Queries only check local storage, don't query network
- **Node-to-Node Communication**: No mechanism to send DHT messages between peers

---

## Problem Analysis

### Current Flow (Local Only)

```
Edge3: advertise_service("test.calculator.add")
  ↓
Edge3: store_local(Key, Value)  # Stores in Edge3's local map
  ↓
Edge3: Storage = #{Key => Value}  # Only visible on Edge3

Edge2: discover_service("test.calculator.add")
  ↓
Edge2: get_local(Key)  # Checks Edge2's local map
  ↓
Edge2: not_found  # Can't see Edge3's storage
```

### Desired Flow (DHT Propagation)

```
Edge3: advertise_service("test.calculator.add")
  ↓
Edge3: store(Key, Value)  # New API!
  ↓
Edge3: Find k=3 closest nodes to Key
  ├─> Bootstrap (172.21.0.10)
  ├─> Gateway (172.21.0.20)
  └─> Edge1 (172.21.0.31)
  ↓
Edge3: Send STORE message to each
  ├─> Bootstrap stores locally
  ├─> Gateway stores locally
  └─> Edge1 stores locally
  ↓
Now Key => Value stored on 4 nodes (Edge3 + 3 closest)

Edge2: discover_service("test.calculator.add")
  ↓
Edge2: find_value(Key, K=3)  # New implementation!
  ↓
Edge2: Query closest nodes iteratively
  ├─> Query Gateway (closest)
  ├─> Gateway returns Value ✅
  ↓
Edge2: {ok, Value}  # Found!
```

---

## Implementation Plan

### Phase 1: Add store/3 API with DHT Propagation (~4 hours)

#### 1.1 Add API Function to routing_server.erl
```erlang
%% @doc Store value in DHT by propagating to k closest nodes.
-spec store(pid(), binary(), term()) -> ok | {error, term()}.
store(Pid, Key, Value) ->
    gen_server:call(Pid, {store, Key, Value}, 10000).
```

#### 1.2 Implement handle_call for {store, Key, Value}
```erlang
handle_call({store, Key, Value}, _From, #state{routing_table = Table, config = Config} = State) ->
    %% 1. Store locally first
    ok = gen_server:call(self(), {store_local, Key, Value}),

    %% 2. Find k closest nodes to Key
    K = maps:get(k, Config, 20),
    ClosestNodes = macula_routing_table:find_closest(Table, Key, K),

    %% 3. Send STORE message to each node
    StoreMsg = macula_routing_protocol:encode_store(Key, Value),
    lists:foreach(fun(NodeInfo) ->
        send_dht_message(NodeInfo, store, StoreMsg)
    end, ClosestNodes),

    {reply, ok, State}.
```

#### 1.3 Implement send_dht_message/3 Helper
```erlang
%% @private
%% @doc Send DHT message to remote node via gateway.
send_dht_message(#{endpoint := Endpoint} = _NodeInfo, MessageType, Message) ->
    %% TODO: Implement actual sending via macula_connection or gateway
    %% For now, just log
    io:format("[DHT] Would send ~p message to ~p~n", [MessageType, Endpoint]),
    ok.
```

**Key Challenge**: How to send messages to arbitrary nodes? Current architecture sends via `macula_connection` which maintains a single connection. Need to:
- Either: Extend gateway to support sending to arbitrary endpoints
- Or: Use peer's connection pool to establish temporary connections
- Or: Route through gateway as relay

### Phase 2: Implement find_value/3 Iterative Lookup (~3 hours)

#### 2.1 Update find_value Implementation
Currently find_value has a TODO placeholder:
```erlang
QueryFn = fun(_NodeInfo, _QueryKey) ->
    %% TODO: For now, we can't directly query remote nodes without a connection
    %% This would need to send FIND_VALUE RPC over QUIC to remote node
    %% Return nodes so the algorithm continues
    {nodes, [_NodeInfo]}
end,
```

Replace with actual network query:
```erlang
QueryFn = fun(NodeInfo, QueryKey) ->
    %% Send FIND_VALUE message to remote node
    FindValueMsg = macula_routing_protocol:encode_find_value(QueryKey),
    case send_dht_query_and_wait(NodeInfo, find_value, FindValueMsg) of
        {ok, Value} ->
            %% Node has the value
            {ok, Value};
        {nodes, Nodes} ->
            %% Node doesn't have value, returned closer nodes
            {nodes, Nodes};
        {error, _Reason} ->
            %% Query failed, treat as if node returned no value
            {nodes, []}
    end
end,
```

#### 2.2 Implement send_dht_query_and_wait/3
```erlang
%% @private
%% @doc Send DHT query and wait for response.
send_dht_query_and_wait(NodeInfo, MessageType, Message) ->
    %% TODO: Implement request/response pattern
    %% 1. Generate request ID
    %% 2. Send message to node
    %% 3. Wait for response with timeout
    %% 4. Return result or timeout
    {error, not_implemented}.
```

---

## Node-to-Node Communication Options

### Option A: Gateway as DHT Relay (Recommended for v0.8.0)

**Pro**:
- Simple - reuse existing gateway infrastructure
- No need for peer-to-peer connections
- Works with current architecture

**Con**:
- Gateway becomes bottleneck for DHT traffic
- Extra hop adds latency

**Implementation**:
```erlang
%% In routing_server.erl
send_dht_message(NodeInfo, MessageType, Message) ->
    %% Send via local gateway
    case whereis(macula_gateway) of
        undefined -> {error, no_gateway};
        GatewayPid ->
            macula_gateway_dht:forward_to_peer(GatewayPid, NodeInfo, MessageType, Message)
    end.
```

### Option B: Direct Peer-to-Peer Connections (Future v0.9.0)

**Pro**:
- Lower latency
- True P2P architecture
- Scales better

**Con**:
- Requires connection pool per peer
- More complex NAT traversal
- Higher resource usage

**Implementation**: Use `macula_connection` to establish temporary connections to peers for DHT queries.

---

## Recommended Approach for v0.8.0

Given time constraints and architecture, I recommend:

1. **Use Gateway as DHT Relay** (Option A)
2. **Implement synchronous STORE** (send and forget)
3. **Implement asynchronous FIND_VALUE** (with timeout)
4. **Test with multi-node Docker environment**

### Minimal Implementation Steps

1. **Add macula_gateway_dht:forward_to_peer/4** (~2 hours)
   - Take NodeInfo endpoint
   - Establish QUIC connection to peer's gateway
   - Send DHT message
   - Wait for response (for queries) or return immediately (for STORE)

2. **Update routing_server:store/3** (~1 hour)
   - Find k closest nodes
   - Send STORE to each via gateway
   - Best effort (don't fail if some nodes unreachable)

3. **Update routing_server:find_value/3** (~2 hours)
   - Implement real QueryFn that sends FIND_VALUE via gateway
   - Parse responses
   - Implement iterative lookup logic

4. **Test with Docker environment** (~2 hours)
   - Verify STORE propagates
   - Verify FIND_VALUE discovers
   - All 11 integration tests should pass

**Total Estimate**: ~7-9 hours

---

## Alternative: Simplified Testing Approach

If implementing full DHT propagation is blocked, we can:

1. **Modify test environment** to use shared storage (ETS table)
2. **Mock DHT propagation** in test helpers
3. **Validate test logic** without implementing full network layer

This proves the test framework works and clearly documents what needs implementation.

---

## Test Implications

### Current Test Results (7/11 Passing)

```
✅ test_bootstrap_node_healthy - Infrastructure
✅ test_gateway_node_healthy - Infrastructure
✅ test_edge_nodes_healthy - Infrastructure
✅ test_dht_peer_discovery - Routing table works
✅ test_service_registration_in_dht - Local storage works
✅ test_service_discovery_via_dht - Local retrieval works (same node)
✅ test_rpc_timeout_handling - Error handling works

❌ test_single_hop_rpc_call - Needs cross-node discovery
❌ test_multi_hop_rpc_call - Needs cross-node discovery
❌ test_rpc_provider_not_found - Needs actual find_value
❌ test_rpc_max_hops_exceeded - Needs routing implementation
```

### After DHT Propagation (Expected 11/11 Passing)

All tests should pass once:
- `store/3` propagates to k closest nodes
- `find_value/3` queries network iteratively
- Gateway can forward DHT messages to peers

---

## Next Actions

**Immediate**:
1. ✅ Document current state (this file)
2. ⏳ Decide on implementation approach (Option A vs B)
3. ⏳ Implement gateway DHT relay
4. ⏳ Update routing_server store/find_value
5. ⏳ Verify with integration tests

**Future (v0.9.0+)**:
- Direct P2P connections
- NAT traversal
- Connection pooling per peer
- DHT replication and expiry

---

**Status**: Ready for implementation
**Estimated Effort**: 7-9 hours
**Blocking Issues**: None - all dependencies in place
**Next Step**: Implement macula_gateway_dht:forward_to_peer/4
