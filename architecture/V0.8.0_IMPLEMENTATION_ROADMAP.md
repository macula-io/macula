# Macula v0.8.0 Implementation Roadmap

**Target Release**: Q2 2025 (10 weeks)
**Major Features**:
1. Subsystem refactoring (bootstrap, relay, NAT, bridge)
2. DHT-routed RPC (complete implementation)
3. NAT traversal with hole punching
4. P2P matchmaking for macula-arcade

**Status**: Approved - Ready to implement

---

## Week-by-Week Breakdown

### Week 1-2: Extract `macula_bootstrap_system`

**Goal**: Separate bootstrap functionality from monolithic gateway

#### Tasks

##### 1. Create New OTP Application Structure
```bash
cd /home/rl/work/github.com/macula-io/macula
mkdir -p src/macula_bootstrap_system
touch src/macula_bootstrap_system/macula_bootstrap_system.erl
touch src/macula_bootstrap_system/macula_bootstrap_server.erl
touch src/macula_bootstrap_system/macula_bootstrap_registry.erl
touch src/macula_bootstrap_system/macula_bootstrap_health.erl
```

##### 2. Define Bootstrap System Supervisor

**File**: `src/macula_bootstrap_system/macula_bootstrap_system.erl`

```erlang
-module(macula_bootstrap_system).
-behaviour(supervisor).

-export([start_link/1, init/1]).
-export([get_server_pid/0]).

%% @doc Start bootstrap system supervisor
start_link(Config) ->
    supervisor:start_link({local, ?MODULE}, ?MODULE, Config).

%% @doc Get bootstrap server PID
get_server_pid() ->
    case whereis(macula_bootstrap_server) of
        undefined -> {error, not_started};
        Pid -> {ok, Pid}
    end.

init(Config) ->
    io:format("[BootstrapSystem] Starting with config: ~p~n", [Config]),

    Children = [
        %% Bootstrap server (DHT storage, service registry)
        #{
            id => bootstrap_server,
            start => {macula_bootstrap_server, start_link, [Config]},
            restart => permanent,
            shutdown => 5000,
            type => worker,
            modules => [macula_bootstrap_server]
        },

        %% Service registry (stores advertised services)
        #{
            id => service_registry,
            start => {macula_bootstrap_registry, start_link, [Config]},
            restart => permanent,
            shutdown => 5000,
            type => worker,
            modules => [macula_bootstrap_registry]
        },

        %% Health monitoring
        #{
            id => health_monitor,
            start => {macula_bootstrap_health, start_link, [Config]},
            restart => permanent,
            shutdown => 5000,
            type => worker,
            modules => [macula_bootstrap_health]
        }
    ],

    SupFlags = #{
        strategy => one_for_one,
        intensity => 10,
        period => 60
    },

    {ok, {SupFlags, Children}}.
```

##### 3. Implement Bootstrap Server

**File**: `src/macula_bootstrap_system/macula_bootstrap_server.erl`

```erlang
-module(macula_bootstrap_server).
-behaviour(gen_server).

-export([start_link/1]).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2]).
-export([handle_dht_query/2, get_stats/0]).

-record(state, {
    realm :: binary(),
    node_id :: binary(),
    config :: map(),
    stats :: map()
}).

%% API
start_link(Config) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, Config, []).

%% @doc Handle DHT query (FIND_NODE, FIND_VALUE, STORE)
handle_dht_query(QueryType, QueryData) ->
    gen_server:call(?MODULE, {dht_query, QueryType, QueryData}).

%% @doc Get bootstrap stats
get_stats() ->
    gen_server:call(?MODULE, get_stats).

%% Callbacks
init(Config) ->
    Realm = maps:get(realm, Config, <<"macula.bootstrap">>),
    NodeId = macula_id:generate(),

    io:format("[BootstrapServer] Starting for realm ~s~n", [Realm]),

    State = #state{
        realm = Realm,
        node_id = NodeId,
        config = Config,
        stats = #{
            queries_handled => 0,
            services_registered => 0,
            uptime_start => erlang:system_time(second)
        }
    },

    {ok, State}.

handle_call({dht_query, find_node, TargetId}, _From, State) ->
    %% Delegate to routing_server
    Result = macula_routing_server:find_closest(TargetId, 20),
    NewStats = maps:update_with(queries_handled, fun(N) -> N + 1 end, State#state.stats),
    {reply, {ok, Result}, State#state{stats = NewStats}};

handle_call({dht_query, find_value, Key}, _From, State) ->
    %% Delegate to service registry
    Result = macula_bootstrap_registry:lookup(Key),
    NewStats = maps:update_with(queries_handled, fun(N) -> N + 1 end, State#state.stats),
    {reply, Result, State#state{stats = NewStats}};

handle_call({dht_query, store, {Key, Value}}, _From, State) ->
    %% Store in service registry
    ok = macula_bootstrap_registry:store(Key, Value),
    NewStats = maps:update_with(services_registered, fun(N) -> N + 1 end, State#state.stats),
    {reply, ok, State#state{stats = NewStats}};

handle_call(get_stats, _From, State) ->
    Uptime = erlang:system_time(second) - maps:get(uptime_start, State#state.stats),
    Stats = maps:put(uptime_seconds, Uptime, State#state.stats),
    {reply, {ok, Stats}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    io:format("[BootstrapServer] Shutting down~n"),
    ok.
```

##### 4. Implement Service Registry

**File**: `src/macula_bootstrap_system/macula_bootstrap_registry.erl`

```erlang
-module(macula_bootstrap_registry).
-behaviour(gen_server).

-export([start_link/1]).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).
-export([store/2, lookup/1, list_all/0, cleanup_expired/0]).

-record(state, {
    services :: ets:tid(),
    ttl_seconds :: pos_integer()
}).

-record(service_entry, {
    key :: binary(),
    value :: term(),
    stored_at :: integer(),
    ttl :: pos_integer()
}).

%% API
start_link(Config) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, Config, []).

store(Key, Value) ->
    gen_server:call(?MODULE, {store, Key, Value}).

lookup(Key) ->
    gen_server:call(?MODULE, {lookup, Key}).

list_all() ->
    gen_server:call(?MODULE, list_all).

cleanup_expired() ->
    gen_server:cast(?MODULE, cleanup_expired).

%% Callbacks
init(Config) ->
    TtlSeconds = maps:get(service_ttl, Config, 300),  % 5 minutes default

    %% Create ETS table for service storage
    Services = ets:new(services, [
        set,
        named_table,
        {keypos, #service_entry.key},
        {read_concurrency, true}
    ]),

    io:format("[BootstrapRegistry] Starting with TTL ~p seconds~n", [TtlSeconds]),

    %% Schedule periodic cleanup
    erlang:send_after(60000, self(), cleanup_expired),  % Every minute

    State = #state{
        services = Services,
        ttl_seconds = TtlSeconds
    },

    {ok, State}.

handle_call({store, Key, Value}, _From, State) ->
    Now = erlang:system_time(second),
    Entry = #service_entry{
        key = Key,
        value = Value,
        stored_at = Now,
        ttl = State#state.ttl_seconds
    },
    ets:insert(State#state.services, Entry),
    io:format("[BootstrapRegistry] Stored service: ~p~n", [Key]),
    {reply, ok, State};

handle_call({lookup, Key}, _From, State) ->
    case ets:lookup(State#state.services, Key) of
        [#service_entry{value = Value, stored_at = StoredAt, ttl = Ttl}] ->
            Now = erlang:system_time(second),
            case Now - StoredAt < Ttl of
                true -> {reply, {ok, Value}, State};
                false ->
                    %% Expired
                    ets:delete(State#state.services, Key),
                    {reply, {error, not_found}, State}
            end;
        [] ->
            {reply, {error, not_found}, State}
    end;

handle_call(list_all, _From, State) ->
    All = ets:tab2list(State#state.services),
    {reply, {ok, All}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

handle_cast(cleanup_expired, State) ->
    Now = erlang:system_time(second),
    Expired = ets:select(State#state.services, [
        {#service_entry{key = '$1', stored_at = '$2', ttl = '$3', _ = '_'},
         [{'<', {'+', '$2', '$3'}, Now}],
         ['$1']}
    ]),
    lists:foreach(fun(Key) -> ets:delete(State#state.services, Key) end, Expired),
    case length(Expired) of
        0 -> ok;
        N -> io:format("[BootstrapRegistry] Cleaned up ~p expired services~n", [N])
    end,
    {noreply, State};

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(cleanup_expired, State) ->
    handle_cast(cleanup_expired, State),
    erlang:send_after(60000, self(), cleanup_expired),
    {noreply, State};

handle_info(_Info, State) ->
    {noreply, State}.
```

##### 5. Add Configuration Support

Update `macula_app.erl` to support bootstrap mode:

```erlang
%% In macula_app.erl init/1
case application:get_env(macula, mode, edge) of
    bootstrap ->
        %% Start bootstrap system instead of gateway
        Config = #{
            realm => application:get_env(macula, realm, <<"macula.bootstrap">>),
            service_ttl => application:get_env(macula, service_ttl, 300)
        },
        {ok, _Pid} = macula_bootstrap_system:start_link(Config);

    relay ->
        %% Start relay system (Week 3-4)
        start_relay_system();

    edge ->
        %% Start edge peer system (existing macula_peer_system)
        start_edge_peer()
end
```

##### 6. Write Tests

**File**: `test/macula_bootstrap_system_tests.erl`

```erlang
-module(macula_bootstrap_system_tests).
-include_lib("eunit/include/eunit.hrl").

bootstrap_system_test_() ->
    {foreach,
     fun setup/0,
     fun cleanup/1,
     [
      fun test_start_stop/1,
      fun test_service_store_lookup/1,
      fun test_service_expiry/1,
      fun test_dht_queries/1
     ]}.

setup() ->
    Config = #{
        realm => <<"test.realm">>,
        service_ttl => 5  % 5 seconds for testing
    },
    {ok, Pid} = macula_bootstrap_system:start_link(Config),
    Pid.

cleanup(Pid) ->
    exit(Pid, normal),
    ok.

test_start_stop(_Pid) ->
    {ok, ServerPid} = macula_bootstrap_system:get_server_pid(),
    ?assert(is_pid(ServerPid)).

test_service_store_lookup(_Pid) ->
    %% Store a service
    ok = macula_bootstrap_registry:store(<<"test.service">>, #{node => <<"node1">>}),

    %% Lookup should succeed
    {ok, #{node := <<"node1">>}} = macula_bootstrap_registry:lookup(<<"test.service">>),

    ok.

test_service_expiry(_Pid) ->
    %% Store a service
    ok = macula_bootstrap_registry:store(<<"temp.service">>, #{node => <<"node2">>}),

    %% Should exist immediately
    {ok, _} = macula_bootstrap_registry:lookup(<<"temp.service">>),

    %% Wait for expiry (TTL = 5 seconds)
    timer:sleep(6000),

    %% Should be expired
    {error, not_found} = macula_bootstrap_registry:lookup(<<"temp.service">>),

    ok.

test_dht_queries(_Pid) ->
    %% Test DHT FIND_VALUE
    ok = macula_bootstrap_registry:store(<<"dht.key">>, #{data => <<"value">>}),
    {ok, #{data := <<"value">>}} = macula_bootstrap_server:handle_dht_query(find_value, <<"dht.key">>),

    %% Test stats
    {ok, Stats} = macula_bootstrap_server:get_stats(),
    ?assert(maps:get(queries_handled, Stats) > 0),

    ok.
```

##### 7. Update Documentation

Create `docs/bootstrap_mode.md`:

```markdown
# Bootstrap Mode

Macula can run as a bootstrap node providing DHT bootstrap and service registry.

## Configuration

```erlang
%% config/sys.config
[{macula, [
    {mode, bootstrap},
    {realm, <<"macula.bootstrap">>},
    {listen_port, 4433},
    {service_ttl, 300}  % Services expire after 5 minutes
]}].
```

## Running

```bash
./bin/macula start
```

## Docker

```bash
docker run -p 4433:4433/udp macula/bootstrap:0.8.0
```

## API

### Store Service
```erlang
macula_bootstrap_registry:store(Key, Value).
```

### Lookup Service
```erlang
{ok, Value} = macula_bootstrap_registry:lookup(Key).
```
```

---

### Week 3-4: Extract `macula_relay_system`

**Goal**: Separate relay functionality (former "gateway" relay role)

#### Tasks

1. Create relay system structure (similar to bootstrap)
2. Move relay code from `macula_gateway`:
   - `macula_gateway_pubsub.erl` → `macula_relay_pubsub.erl`
   - `macula_gateway_rpc.erl` → `macula_relay_rpc.erl`
   - `macula_gateway_mesh.erl` → `macula_relay_connections.erl`
3. Implement relay-specific supervision tree
4. Add `{mode, relay}` configuration
5. Write relay system tests
6. Update documentation

---

### Week 5-6: Implement DHT-Routed RPC Foundation

**Goal**: Complete DHT-routed RPC implementation (fix P2P matchmaking)

#### Tasks

1. Implement `macula_rpc_routing.erl` (from `architecture/dht_routed_rpc.md`)
2. Update gateway to route `rpc_route` messages
3. Update connection to use DHT routing instead of direct endpoints
4. Test multi-hop RPC (client → node_a → node_b → provider)
5. Update macula-arcade coordinator to use RPC for P2P matching

**Result**: P2P matchmaking works across peers!

---

### Week 7-8: Implement `macula_nat_system` Foundation

**Goal**: NAT discovery and hole punching (basic version)

#### Tasks

1. Create `macula_nat_discovery.erl` (discover public address)
2. Create `macula_nat_detector.erl` (detect NAT type)
3. Create `macula_nat_hole_punch.erl` (coordinate simultaneous connection)
4. Test hole punching in Docker environment
5. Integrate with relay system

**See**: `architecture/NAT_TRAVERSAL_ROADMAP.md` for detailed implementation

---

### Week 9-10: Integration, Testing, Documentation

**Goal**: Polish and release v0.8.0

#### Tasks

1. End-to-end testing (all modes: bootstrap, relay, edge)
2. Performance testing (DHT-routed RPC latency)
3. Update all documentation
4. Deprecate old `macula_gateway` (mark as deprecated)
5. Create migration guide (v0.7.30 → v0.8.0)
6. Publish to hex.pm
7. Update macula-arcade to v0.8.0

---

## Priority Order (Next Steps)

### 1. IMMEDIATE: Extract Bootstrap System (Start Now)

This is the foundation for everything else. Once we have a clean bootstrap system, we can:
- Deploy bootstrap-only nodes
- Test relay system separately
- Implement NAT system against clean architecture

**Command to start**:
```bash
cd /home/rl/work/github.com/macula-io/macula
mkdir -p src/macula_bootstrap_system
```

### 2. NEXT: Complete DHT-Routed RPC

This unblocks P2P matchmaking for macula-arcade. Once complete:
- Coordinators can send match requests via RPC
- No need for direct connections yet (routes through DHT)
- Bootstrap-only gateway works perfectly

### 3. THEN: Extract Relay System

Once RPC works, we can separate relay from bootstrap cleanly.

### 4. FINALLY: Add NAT Traversal

This is the "nice to have" that improves performance but isn't blocking.

---

## Success Criteria (v0.8.0)

✅ Can deploy bootstrap-only nodes (no relay code)
✅ Can deploy relay-only nodes (no bootstrap authority)
✅ DHT-routed RPC works (multi-hop messaging)
✅ P2P matchmaking works in macula-arcade (cross-peer)
✅ NAT hole punching works (basic implementation)
✅ All tests passing (1,500+ tests)
✅ Documentation updated
✅ Published to hex.pm

---

## Risk Mitigation

### Risk: Breaking Existing Applications

**Mitigation**:
- Keep v0.7.30 behavior as default (`mode = edge`)
- Provide migration guide
- Support both old and new APIs during transition

### Risk: DHT-Routed RPC Performance

**Mitigation**:
- Implement caching (discovered providers cached for 60s)
- Profile multi-hop latency
- Fallback to direct connections in v0.9.0 (NAT traversal)

### Risk: Timeline Slippage

**Mitigation**:
- Week 1-4: Must complete (bootstrap + relay extraction)
- Week 5-6: High priority (DHT RPC for matchmaking)
- Week 7-8: Can defer to v0.8.1 (NAT system)
- Week 9-10: Buffer for testing/docs

---

## Next Command to Run

```bash
cd /home/rl/work/github.com/macula-io/macula
mkdir -p src/macula_bootstrap_system
touch src/macula_bootstrap_system/macula_bootstrap_system.erl
touch src/macula_bootstrap_system/macula_bootstrap_server.erl
touch src/macula_bootstrap_system/macula_bootstrap_registry.erl
touch src/macula_bootstrap_system/macula_bootstrap_health.erl
```

**Ready to start implementation?**

---

**Last Updated**: 2025-01-17
**Status**: Ready to Implement
**Target**: v0.8.0 (Q2 2025)
