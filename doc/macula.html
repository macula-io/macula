<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module macula</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module macula</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>   
Macula - Main API for distributed workloads on Macula platform.

<p><b>Behaviours:</b> <a href="macula_client_behaviour.html"><code>macula_client_behaviour</code></a>.</p>

<h2><a name="description">Description</a></h2><p>   
Macula - Main API for distributed workloads on Macula platform.</p>
  
   <p>This is the ONLY module workload applications should import. It provides   
a stable, versioned API for all platform operations:</p>
  
   <p>- Mesh networking (connect, publish, subscribe, RPC)   
- Platform Layer (leader election, CRDTs, workload registration)   
- Service discovery (DHT queries, node identity)</p>
  
   <h3><a name="Quick_Start">Quick Start</a></h3>
  
   Connect to local platform and publish events:
   <pre>   {ok, Client} = macula:connect_local(#{realm =&gt; &amp;lt;&amp;lt;"my.app"&amp;gt;&amp;gt;}),
   ok = macula:publish(Client, &amp;lt;&amp;lt;"my.events"&amp;gt;&amp;gt;, #{type =&gt; &amp;lt;&amp;lt;"test"&amp;gt;&amp;gt;}).</pre>
  
   <h3><a name="Architecture">Architecture</a></h3>
  
   <p>Workload applications run in the same BEAM VM as the Macula platform.
   Use <code>connect_local/1` to connect via process-to-process communication:
  
   ```
   Workload App → macula:connect_local/1 → macula_gateway → Mesh (QUIC/HTTP3)</code>''</p>
  
   <h3><a name="Platform_Layer_(v0.10.0+)">Platform Layer (v0.10.0+)</a></h3>
  
   Register with platform for coordination features:
   <pre>   {ok, #{leader_node := Leader}} = macula:register_workload(Client, #{
       workload_name =&gt; &amp;lt;&amp;lt;"my_app"&amp;gt;&amp;gt;
   }).</pre>
  
   <h3><a name="DHT_Network_Bootstrap">DHT Network Bootstrap</a></h3>
  
   The platform handles DHT bootstrapping via <code>MACULA_BOOTSTRAP_PEERS`.
   Workloads don</code>t need to manage peer discovery.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-args">args()</a></h3>
<p><code>args() = map() | list() | binary()</code></p>
<p>  Arguments for RPC calls.</p>

<h3 class="typedecl"><a name="type-client">client()</a></h3>
<p><code>client() = pid()</code></p>
<p>  Reference to a connected Macula mesh client.</p>

<h3 class="typedecl"><a name="type-event_data">event_data()</a></h3>
<p><code>event_data() = map() | binary()</code></p>
<p>  Event payload data. Typically a map that will be JSON-encoded.</p>

<h3 class="typedecl"><a name="type-options">options()</a></h3>
<p><code>options() = map()</code></p>
<p>  Connection or operation options.</p>

<h3 class="typedecl"><a name="type-procedure">procedure()</a></h3>
<p><code>procedure() = binary()</code></p>
<p>  RPC procedure name. Example: <code>"my.app.get_user"</code>.</p>

<h3 class="typedecl"><a name="type-subscription_ref">subscription_ref()</a></h3>
<p><code>subscription_ref() = reference()</code></p>
<p>  Reference to an active subscription for unsubscribe operations.</p>

<h3 class="typedecl"><a name="type-topic">topic()</a></h3>
<p><code>topic() = binary()</code></p>
<p>  Topic name for pub/sub operations. Topics should describe event types,
  not entity IDs. Example: <code>"my.app.user.registered"</code> (good),
  not <code>"my.app.user.123.registered"</code> (bad - ID belongs in payload).</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#advertise-3">advertise/3</a></td><td>Advertise a service that this client provides.</td></tr>
<tr><td valign="top"><a href="#advertise-4">advertise/4</a></td><td>Advertise a service with options.</td></tr>
<tr><td valign="top"><a href="#call-3">call/3</a></td><td>Make a synchronous RPC call.</td></tr>
<tr><td valign="top"><a href="#call-4">call/4</a></td><td>Make an RPC call with options.</td></tr>
<tr><td valign="top"><a href="#connect-2">connect/2</a></td><td>Connect to a Macula mesh network.</td></tr>
<tr><td valign="top"><a href="#connect_local-1">connect_local/1</a></td><td>Connect to the local Macula gateway (for in-VM workloads).</td></tr>
<tr><td valign="top"><a href="#disconnect-1">disconnect/1</a></td><td>Disconnect from the Macula mesh.</td></tr>
<tr><td valign="top"><a href="#discover_subscribers-2">discover_subscribers/2</a></td><td>Discover subscribers to a topic via DHT query.</td></tr>
<tr><td valign="top"><a href="#get_leader-1">get_leader/1</a></td><td>Get the current Platform Layer leader node.</td></tr>
<tr><td valign="top"><a href="#get_node_id-1">get_node_id/1</a></td><td>Get the node ID of this client.</td></tr>
<tr><td valign="top"><a href="#propose_crdt_update-3">propose_crdt_update/3</a></td><td>Propose a CRDT update to Platform Layer shared state.</td></tr>
<tr><td valign="top"><a href="#propose_crdt_update-4">propose_crdt_update/4</a></td><td>Propose a CRDT update with specific CRDT type.</td></tr>
<tr><td valign="top"><a href="#publish-3">publish/3</a></td><td>Publish an event to a topic.</td></tr>
<tr><td valign="top"><a href="#publish-4">publish/4</a></td><td>Publish an event with options.</td></tr>
<tr><td valign="top"><a href="#read_crdt-2">read_crdt/2</a></td><td>Read the current value of a CRDT-managed shared state entry.</td></tr>
<tr><td valign="top"><a href="#register_workload-2">register_workload/2</a></td><td>Register this workload with the Platform Layer.</td></tr>
<tr><td valign="top"><a href="#subscribe-3">subscribe/3</a></td><td>Subscribe to a topic.</td></tr>
<tr><td valign="top"><a href="#subscribe_leader_changes-2">subscribe_leader_changes/2</a></td><td>Subscribe to Platform Layer leader change notifications.</td></tr>
<tr><td valign="top"><a href="#unadvertise-2">unadvertise/2</a></td><td>Stop advertising a service.</td></tr>
<tr><td valign="top"><a href="#unsubscribe-2">unsubscribe/2</a></td><td>Unsubscribe from a topic.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="advertise-3">advertise/3</a></h3>
<div class="spec">
<p><code>advertise(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Procedure::<a href="#type-procedure" docgen-rel="seetype" docgen-href="#procedure/0">procedure()</a>, Handler::<a href="/home/rl/work/github.com/macula-io/macula/doc/macula_service_registry.html#type-handler_fn" docgen-rel="seetype" docgen-href="macula:macula_service_registry#handler_fn/0">macula_service_registry:handler_fn()</a>) -&gt; {ok, reference()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Advertise a service that this client provides.</p>
 
  <p>Registers a handler function for the specified procedure and advertises  
it to the DHT so other clients can discover and call it.</p>
 
  <p>The handler function receives a map of arguments and must return
  <code>{ok, Result}</code> or <code>{error, Reason}</code>.</p>
 
  <h3><a name="Options">Options</a></h3>
 
  <ul>
  <li><code>ttl</code> - Advertisement TTL in seconds (default: 300)</li>
  <li><code>metadata</code> - Custom metadata map (default: #{})</li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Define a handler function
  Handler = fun(#{user_id := UserId}) -&gt;
      {ok, #{user_id =&gt; UserId, name =&gt; &amp;lt;&amp;lt;"Alice"&amp;gt;&amp;gt;}}
  end.
 
  %% Advertise the service
  {ok, Ref} = macula:advertise(
      Client,
      &amp;lt;&amp;lt;"my.app.get_user"&amp;gt;&amp;gt;,
      Handler
  ).
 
  %% Other clients can now call:
  %% {ok, User} = macula:call(OtherClient, &amp;lt;&amp;lt;"my.app.get_user"&amp;gt;&amp;gt;,
  %%     #{user_id =&gt; &amp;lt;&amp;lt;"user-123"&amp;gt;&amp;gt;}).</pre></p>

<h3 class="function"><a name="advertise-4">advertise/4</a></h3>
<div class="spec">
<p><code>advertise(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Procedure::<a href="#type-procedure" docgen-rel="seetype" docgen-href="#procedure/0">procedure()</a>, Handler::<a href="/home/rl/work/github.com/macula-io/macula/doc/macula_service_registry.html#type-handler_fn" docgen-rel="seetype" docgen-href="macula:macula_service_registry#handler_fn/0">macula_service_registry:handler_fn()</a>, Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; {ok, reference()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p>Advertise a service with options.</p>

<h3 class="function"><a name="call-3">call/3</a></h3>
<div class="spec">
<p><code>call(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Procedure::<a href="#type-procedure" docgen-rel="seetype" docgen-href="#procedure/0">procedure()</a>, Args::<a href="#type-args" docgen-rel="seetype" docgen-href="#args/0">args()</a>) -&gt; {ok, Result::term()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Make a synchronous RPC call.</p>
 
  <p>Calls a remote procedure and waits for the result.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Simple RPC call
  {ok, User} = macula:call(Client, &amp;lt;&amp;lt;"my.app.get_user"&amp;gt;&amp;gt;, #{
      user_id =&gt; &amp;lt;&amp;lt;"user-123"&amp;gt;&amp;gt;
  }).
 
  %% With timeout
  {ok, Result} = macula:call(Client, &amp;lt;&amp;lt;"my.app.process"&amp;gt;&amp;gt;,
      #{data =&gt; &amp;lt;&amp;lt;"large"&amp;gt;&amp;gt;},
      #{timeout =&gt; 30000}).</pre></p>

<h3 class="function"><a name="call-4">call/4</a></h3>
<div class="spec">
<p><code>call(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Procedure::<a href="#type-procedure" docgen-rel="seetype" docgen-href="#procedure/0">procedure()</a>, Args::<a href="#type-args" docgen-rel="seetype" docgen-href="#args/0">args()</a>, Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; {ok, Result::term()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p>Make an RPC call with options.</p>

<h3 class="function"><a name="connect-2">connect/2</a></h3>
<div class="spec">
<p><code>connect(Url::binary(), Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; {ok, <a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Connect to a Macula mesh network.</p>
 
  <p>Creates a new HTTP/3 (QUIC) connection to the specified mesh endpoint.</p>
 
  <h3><a name="Options">Options</a></h3>
 
  <ul>
  <li><code>realm</code> - Required. Binary realm identifier (e.g., <code>&amp;lt;&amp;lt;"my.app.realm"&amp;gt;&amp;gt;</code>)</li>
  <li><code>auth</code> - Optional. Authentication map with <code>api_key</code> or other auth methods</li>
  <li><code>timeout</code> - Optional. Connection timeout in milliseconds (default: 5000)</li>
  <li><code>node_id</code> - Optional. 32-byte node ID (generated if not provided)</li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Basic connection
  {ok, Client} = macula:connect(&amp;lt;&amp;lt;"https://mesh.local:443"&amp;gt;&amp;gt;, #{
      realm =&gt; &amp;lt;&amp;lt;"my.realm"&amp;gt;&amp;gt;
  }).
 
  %% With API key authentication
  {ok, Client} = macula:connect(&amp;lt;&amp;lt;"https://mesh.local:443"&amp;gt;&amp;gt;, #{
      realm =&gt; &amp;lt;&amp;lt;"my.realm"&amp;gt;&amp;gt;,
      auth =&gt; #{api_key =&gt; &amp;lt;&amp;lt;"secret-key"&amp;gt;&amp;gt;}
  }).</pre></p>

<h3 class="function"><a name="connect_local-1">connect_local/1</a></h3>
<div class="spec">
<p><code>connect_local(Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; {ok, <a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Connect to the local Macula gateway (for in-VM workloads).</p>
 
  <p>This function is used by applications running in the same BEAM VM as
  the Macula platform. Instead of creating a QUIC connection to localhost,
  it connects directly to the local <code>macula_gateway</code> process via  
process-to-process communication.</p>
 
  <h3><a name="Architecture">Architecture</a></h3>
 
  <pre>  Phoenix/Elixir App → macula_local_client → macula_gateway
                                              ↓ (QUIC)
                                         Other Peers</pre>
 
  <h3><a name="When_to_Use">When to Use</a></h3>
 
  <ul>
  <li>✅ Use <code>connect_local/1</code> when your application runs in the same VM as Macula</li>
  <li>✅ Phoenix applications deployed with Macula in the same container</li>
  <li>❌ Do NOT use <code>connect/2</code> with localhost URL - it creates unnecessary QUIC overhead</li>
  </ul>
 
  <h3><a name="Options">Options</a></h3>
 
  <ul>
  <li><code>realm</code> - Required. Binary realm identifier (e.g., <code>&amp;lt;&amp;lt;"my.app.realm"&amp;gt;&amp;gt;</code>)</li>
  <li><code>event_handler</code> - Optional. PID to receive events (default: caller PID)</li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Elixir Phoenix application
  {:ok, client} = :macula.connect_local(%{
      realm: "macula.arcade.dev"
  })
 
  %% Erlang application
  {ok, Client} = macula:connect_local(#{
      realm =&gt; &amp;lt;&amp;lt;"my.app.realm"&amp;gt;&amp;gt;
  }).</pre>
 </p>
<p><b>Introduced in:</b> v0.8.9</p>

<h3 class="function"><a name="disconnect-1">disconnect/1</a></h3>
<div class="spec">
<p><code>disconnect(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Disconnect from the Macula mesh.</p>
 
  Cleanly closes the HTTP/3 connection and cleans up all subscriptions.</p>

<h3 class="function"><a name="discover_subscribers-2">discover_subscribers/2</a></h3>
<div class="spec">
<p><code>discover_subscribers(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Topic::<a href="#type-topic" docgen-rel="seetype" docgen-href="#topic/0">topic()</a>) -&gt; {ok, [#{node_id := binary(), endpoint := binary()}]} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Discover subscribers to a topic via DHT query.</p>
 
  <p>Queries the DHT for all nodes subscribed to the given topic.  
Returns a list of subscriber nodes with their node IDs and endpoints.</p>
 
  This is used for P2P discovery before sending direct messages.</p>

<h3 class="function"><a name="get_leader-1">get_leader/1</a></h3>
<div class="spec">
<p><code>get_leader(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>) -&gt; {ok, binary()} | {error, no_leader | term()}</code><br></p>
<p> </p>
</div><p><p>Get the current Platform Layer leader node.</p>
 
  <p>Queries the Platform Layer for the current leader node ID. The leader  
is elected via Raft consensus and handles coordination tasks.</p>
 
  <p>Returns <code>{error, no_leader}</code> if leader election is in progress.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  case macula:get_leader(Client) of
      {ok, LeaderNodeId} -&gt;
          %% Check if we're the leader
          {ok, OurNodeId} = macula:get_node_id(Client),
          case LeaderNodeId == OurNodeId of
              true -&gt; coordinate_globally();
              false -&gt; defer_to_leader()
          end;
      {error, no_leader} -&gt;
          wait_for_leader_election()
  end.</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="get_node_id-1">get_node_id/1</a></h3>
<div class="spec">
<p><code>get_node_id(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>) -&gt; {ok, binary()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Get the node ID of this client.</p>
 
  Returns the 32-byte node ID assigned to this client.</p>

<h3 class="function"><a name="propose_crdt_update-3">propose_crdt_update/3</a></h3>
<div class="spec">
<p><code>propose_crdt_update(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Key::binary(), Value::term()) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Propose a CRDT update to Platform Layer shared state.</p>
 
  <p>Updates platform-managed shared state using Conflict-Free Replicated  
Data Types (CRDTs) for automatic conflict resolution across nodes.</p>
 
  <p>Default CRDT type is <code>lww_register</code> (Last-Write-Wins Register).
  See <code>propose_crdt_update/4</code> for other CRDT types.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Store simple value (LWW-Register)
  ok = macula:propose_crdt_update(
      Client,
      &amp;lt;&amp;lt;"my.app.config.max_users"&amp;gt;&amp;gt;,
      1000
  ).
 
  %% Later read it back
  {ok, 1000} = macula:read_crdt(Client, &amp;lt;&amp;lt;"my.app.config.max_users"&amp;gt;&amp;gt;).</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="propose_crdt_update-4">propose_crdt_update/4</a></h3>
<div class="spec">
<p><code>propose_crdt_update(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Key::binary(), Value::term(), Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Propose a CRDT update with specific CRDT type.</p>
 
  <p>Updates platform-managed shared state using the specified CRDT type  
for automatic conflict resolution.</p>
 
  <h3><a name="CRDT_Types">CRDT Types</a></h3>
 
  <ul>
  <li><code>lww_register</code> - Last-Write-Wins Register (default)
      <ul><li>Use for: Configuration values, latest status</li>
      <li>Conflict resolution: Latest timestamp wins</li></ul></li>
  <li><code>g_counter</code> - Grow-Only Counter
      <ul><li>Use for: Metrics, totals (never decrease)</li>
      <li>Operations: increment only</li></ul></li>
  <li><code>pn_counter</code> - Positive-Negative Counter
      <ul><li>Use for: Bidirectional counters (can increase/decrease)</li>
      <li>Operations: increment, decrement</li></ul></li>
  <li><code>g_set</code> - Grow-Only Set
      <ul><li>Use for: Accumulating collections (never remove)</li>
      <li>Operations: add elements only</li></ul></li>
  <li><code>or_set</code> - Observed-Remove Set
      <ul><li>Use for: Sets with add/remove operations</li>
      <li>Operations: add, remove elements</li></ul></li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Increment a counter
  ok = macula:propose_crdt_update(
      Client,
      &amp;lt;&amp;lt;"my.app.active_games"&amp;gt;&amp;gt;,
      {increment, 1},
      #{crdt_type =&gt; pn_counter}
  ).
 
  %% Add to a set
  ok = macula:propose_crdt_update(
      Client,
      &amp;lt;&amp;lt;"my.app.player_ids"&amp;gt;&amp;gt;,
      {add, &amp;lt;&amp;lt;"player123"&amp;gt;&amp;gt;},
      #{crdt_type =&gt; or_set}
  ).</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="publish-3">publish/3</a></h3>
<div class="spec">
<p><code>publish(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Topic::<a href="#type-topic" docgen-rel="seetype" docgen-href="#topic/0">topic()</a>, Data::<a href="#type-event_data" docgen-rel="seetype" docgen-href="#event_data/0">event_data()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Publish an event to a topic.</p>
 
  <p>Publishes data to the specified topic. All subscribers to this topic  
will receive the event.</p>
 
  <h3><a name="Topic_Design">Topic Design</a></h3>
 
  Topics should describe EVENT TYPES, not entity instances:
  <ul>
  <li>Good: <code>&amp;lt;&amp;lt;"my.app.user.registered"&amp;gt;&amp;gt;</code> (event type)</li>
  <li>Bad: <code>&amp;lt;&amp;lt;"my.app.user.123.registered"&amp;gt;&amp;gt;</code> (entity ID in topic)</li>
  </ul>
 
  <p>Entity IDs belong in the event payload, not the topic name.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Publish with default options
  ok = macula:publish(Client, &amp;lt;&amp;lt;"my.app.events"&amp;gt;&amp;gt;, #{
      type =&gt; &amp;lt;&amp;lt;"user.registered"&amp;gt;&amp;gt;,
      user_id =&gt; &amp;lt;&amp;lt;"user-123"&amp;gt;&amp;gt;,
      email =&gt; &amp;lt;&amp;lt;"user@example.com"&amp;gt;&amp;gt;
  }).
 
  %% Publish with options
  ok = macula:publish(Client, &amp;lt;&amp;lt;"my.app.events"&amp;gt;&amp;gt;, #{
      data =&gt; &amp;lt;&amp;lt;"important"&amp;gt;&amp;gt;
  }, #{acknowledge =&gt; true}).</pre></p>

<h3 class="function"><a name="publish-4">publish/4</a></h3>
<div class="spec">
<p><code>publish(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Topic::<a href="#type-topic" docgen-rel="seetype" docgen-href="#topic/0">topic()</a>, Data::<a href="#type-event_data" docgen-rel="seetype" docgen-href="#event_data/0">event_data()</a>, Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Publish an event with options.</p>
 
  This is fire-and-forget - returns ok immediately without blocking.
  Uses gen_server:cast to avoid blocking the caller (prevents LiveView freezes).
  Both macula_local_client and macula_peer handle {publish_async, ...} casts.</p>

<h3 class="function"><a name="read_crdt-2">read_crdt/2</a></h3>
<div class="spec">
<p><code>read_crdt(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Key::binary()) -&gt; {ok, term()} | {error, not_found | term()}</code><br></p>
<p> </p>
</div><p><p>Read the current value of a CRDT-managed shared state entry.</p>
 
  <p>Reads from the local CRDT replica. The value reflects all converged  
updates from across the platform cluster.</p>
 
  <p>Returns <code>{error, not_found}</code> if the key has never been written.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Read LWW-Register value
  {ok, MaxUsers} = macula:read_crdt(Client, &amp;lt;&amp;lt;"my.app.config.max_users"&amp;gt;&amp;gt;).
 
  %% Read counter value
  {ok, GameCount} = macula:read_crdt(Client, &amp;lt;&amp;lt;"my.app.active_games"&amp;gt;&amp;gt;).
 
  %% Read set value
  {ok, PlayerSet} = macula:read_crdt(Client, &amp;lt;&amp;lt;"my.app.player_ids"&amp;gt;&amp;gt;).</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="register_workload-2">register_workload/2</a></h3>
<div class="spec">
<p><code>register_workload(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Opts::<a href="#type-options" docgen-rel="seetype" docgen-href="#options/0">options()</a>) -&gt; {ok, map()} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Register this workload with the Platform Layer.</p>
 
  <p>Registers the workload application with Macula's Platform Layer and  
returns information about the current platform cluster state, including  
the current leader node.</p>
 
  <h3><a name="Options">Options</a></h3>
 
  <ul>
  <li><code>workload_name</code> - Required. Binary name identifying this workload type
      (e.g., <code>&amp;lt;&amp;lt;"macula_arcade"&amp;gt;&amp;gt;</code>, <code>&amp;lt;&amp;lt;"my_app"&amp;gt;&amp;gt;</code>)</li>
  <li><code>capabilities</code> - Optional. List of atoms describing workload capabilities
      (e.g., <code>[coordinator, game_server]</code>)</li>
  </ul>
 
  <h3><a name="Returns">Returns</a></h3>
 
  <ul>
  <li><code>leader_node</code> - Binary node ID of the current Platform Layer leader</li>
  <li><code>cluster_size</code> - Integer count of nodes in the platform cluster</li>
  <li><code>platform_version</code> - Binary version string (e.g., <code>&amp;lt;&amp;lt;"0.10.0"&amp;gt;&amp;gt;</code>)</li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  {ok, Client} = macula:connect_local(#{realm =&gt; &amp;lt;&amp;lt;"my.app"&amp;gt;&amp;gt;}),
  {ok, Info} = macula:register_workload(Client, #{
      workload_name =&gt; &amp;lt;&amp;lt;"my_app_coordinator"&amp;gt;&amp;gt;,
      capabilities =&gt; [coordinator, matchmaking]
  }),
  #{leader_node := Leader, cluster_size := Size} = Info.</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="subscribe-3">subscribe/3</a></h3>
<div class="spec">
<p><code>subscribe(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Topic::<a href="#type-topic" docgen-rel="seetype" docgen-href="#topic/0">topic()</a>, Callback::fun((<a href="#type-event_data" docgen-rel="seetype" docgen-href="#event_data/0">event_data()</a>) -&gt; ok)) -&gt; {ok, <a href="#type-subscription_ref" docgen-rel="seetype" docgen-href="#subscription_ref/0">subscription_ref()</a>} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Subscribe to a topic.</p>
 
  <p>Subscribes to events on the specified topic. The callback function  
will be invoked for each event received.</p>
 
  <h3><a name="Callback_Function">Callback Function</a></h3>
 
  <p>The callback receives the event data and should return <code>ok</code>.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  %% Simple subscription
  {ok, SubRef} = macula:subscribe(Client, &amp;lt;&amp;lt;"my.app.events"&amp;gt;&amp;gt;,
      fun(EventData) -&gt;
          io:format("Event: ~p~n", [EventData]),
          ok
      end).
 
  %% Unsubscribe later
  ok = macula:unsubscribe(Client, SubRef).</pre></p>

<h3 class="function"><a name="subscribe_leader_changes-2">subscribe_leader_changes/2</a></h3>
<div class="spec">
<p><code>subscribe_leader_changes(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Callback::fun((map()) -&gt; ok)) -&gt; {ok, <a href="#type-subscription_ref" docgen-rel="seetype" docgen-href="#subscription_ref/0">subscription_ref()</a>} | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Subscribe to Platform Layer leader change notifications.</p>
 
  <p>Registers a callback function to be invoked whenever the Platform Layer  
leader changes due to election or node failure.</p>
 
  The callback receives a map with:
  <ul>
  <li><code>old_leader</code> - Previous leader node ID (may be <code>undefined</code>)</li>
  <li><code>new_leader</code> - New leader node ID</li>
  <li><code>term</code> - Raft term number (monotonically increasing)</li>
  </ul>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  {ok, SubRef} = macula:subscribe_leader_changes(Client,
      fun(#{old_leader := Old, new_leader := New}) -&gt;
          io:format("Leader changed: ~p -&gt; ~p~n", [Old, New]),
          handle_leadership_transition(New),
          ok
      end).</pre>
 </p>
<p><b>Introduced in:</b> v0.10.0</p>

<h3 class="function"><a name="unadvertise-2">unadvertise/2</a></h3>
<div class="spec">
<p><code>unadvertise(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, Procedure::<a href="#type-procedure" docgen-rel="seetype" docgen-href="#procedure/0">procedure()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Stop advertising a service.</p>
 
  <p>Removes the local handler and stops advertising to the DHT.</p>
 
  <h3><a name="Examples">Examples</a></h3>
 
  <pre>  ok = macula:unadvertise(Client, &amp;lt;&amp;lt;"my.app.get_user"&amp;gt;&amp;gt;).</pre></p>

<h3 class="function"><a name="unsubscribe-2">unsubscribe/2</a></h3>
<div class="spec">
<p><code>unsubscribe(Client::<a href="#type-client" docgen-rel="seetype" docgen-href="#client/0">client()</a>, SubRef::<a href="#type-subscription_ref" docgen-rel="seetype" docgen-href="#subscription_ref/0">subscription_ref()</a>) -&gt; ok | {error, Reason::term()}</code><br></p>
<p> </p>
</div><p><p>Unsubscribe from a topic.</p>
 
  Removes the subscription identified by the subscription reference.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
