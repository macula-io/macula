searchData={"items":[{"type":"module","title":"macula_advertisement_manager","doc":"Advertisement manager GenServer - manages DHT service advertisements. Responsibilities: - Advertise services in DHT with periodic re-advertisement - Unadvertise services and cancel timers - Register handlers with local gateway - Manage service advertisement lifecycle - Periodic cleanup of expired local services (every 60s, TTL 300s default) Extracted from macula_connection.erl (Phase 6)","ref":"macula_advertisement_manager.html"},{"type":"function","title":"macula_advertisement_manager.advertise_service/4","doc":"Advertise a service in DHT and local registry","ref":"macula_advertisement_manager.html#advertise_service/4"},{"type":"function","title":"macula_advertisement_manager.get_active_advertisements/1","doc":"Get list of actively advertised services","ref":"macula_advertisement_manager.html#get_active_advertisements/1"},{"type":"function","title":"macula_advertisement_manager.handle_call/3","doc":"","ref":"macula_advertisement_manager.html#handle_call/3"},{"type":"function","title":"macula_advertisement_manager.handle_cast/2","doc":"","ref":"macula_advertisement_manager.html#handle_cast/2"},{"type":"function","title":"macula_advertisement_manager.handle_info/2","doc":"Handle re-advertisement timer","ref":"macula_advertisement_manager.html#handle_info/2"},{"type":"function","title":"macula_advertisement_manager.init/1","doc":"","ref":"macula_advertisement_manager.html#init/1"},{"type":"function","title":"macula_advertisement_manager.start_link/1","doc":"","ref":"macula_advertisement_manager.html#start_link/1"},{"type":"function","title":"macula_advertisement_manager.terminate/2","doc":"","ref":"macula_advertisement_manager.html#terminate/2"},{"type":"function","title":"macula_advertisement_manager.unadvertise_service/2","doc":"Stop advertising a service","ref":"macula_advertisement_manager.html#unadvertise_service/2"},{"type":"module","title":"macula_app","doc":"macula public API","ref":"macula_app.html"},{"type":"function","title":"macula_app.start/2","doc":"","ref":"macula_app.html#start/2"},{"type":"function","title":"macula_app.stop/1","doc":"","ref":"macula_app.html#stop/1"},{"type":"module","title":"macula_cache","doc":"Generic LRU cache implementation. Provides least-recently-used eviction with configurable max size.","ref":"macula_cache.html"},{"type":"type","title":"macula_cache.cache/0","doc":"","ref":"macula_cache.html#t:cache/0"},{"type":"function","title":"macula_cache.clear/1","doc":"Clear all entries.","ref":"macula_cache.html#clear/1"},{"type":"type","title":"macula_cache.entry/0","doc":"","ref":"macula_cache.html#t:entry/0"},{"type":"function","title":"macula_cache.get/2","doc":"Get entry from cache. Returns {ok, Value, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU).","ref":"macula_cache.html#get/2"},{"type":"type","title":"macula_cache.key/0","doc":"","ref":"macula_cache.html#t:key/0"},{"type":"function","title":"macula_cache.keys/1","doc":"Get all keys in cache (most recent first).","ref":"macula_cache.html#keys/1"},{"type":"function","title":"macula_cache.max_size/1","doc":"Get max size.","ref":"macula_cache.html#max_size/1"},{"type":"function","title":"macula_cache.new/1","doc":"Create new cache with max size.","ref":"macula_cache.html#new/1"},{"type":"function","title":"macula_cache.put/3","doc":"Put entry in cache with current timestamp.","ref":"macula_cache.html#put/3"},{"type":"function","title":"macula_cache.put/4","doc":"Put entry in cache with custom timestamp (for testing).","ref":"macula_cache.html#put/4"},{"type":"function","title":"macula_cache.remove/2","doc":"Remove entry from cache.","ref":"macula_cache.html#remove/2"},{"type":"function","title":"macula_cache.size/1","doc":"Get number of entries.","ref":"macula_cache.html#size/1"},{"type":"type","title":"macula_cache.timestamp/0","doc":"","ref":"macula_cache.html#t:timestamp/0"},{"type":"type","title":"macula_cache.value/0","doc":"","ref":"macula_cache.html#t:value/0"},{"type":"module","title":"macula_client","doc":"Macula SDK - Main API module for HTTP/3 mesh client operations. This module provides the primary interface for applications to connect to Macula mesh networks and perform pub/sub and RPC operations over HTTP/3 (QUIC) transport. Quick Start Connect to a mesh, publish events, subscribe to topics, and make RPC calls. See individual function documentation for detailed examples with code.","ref":"macula_client.html"},{"type":"function","title":"macula_client.advertise/3","doc":"Advertise a service that this client provides. Registers a handler function for the specified procedure and advertises it to the DHT so other clients can discover and call it. The handler function receives a map of arguments and must return  {ok, Result}  or  {error, Reason} . Options ttl  - Advertisement TTL in seconds (default: 300) metadata  - Custom metadata map (default: #{}) Examples <span class=\"w\">  </span><span class=\"c1\">%% Define a handler function</span><span class=\"w\">\n  </span><span class=\"n\">Handler</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">fun</span><span class=\"p\" data-group-id=\"8570092776-1\">(</span><span class=\"p\" data-group-id=\"8570092776-2\">#{</span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">:=</span><span class=\"w\"> </span><span class=\"n\">UserId</span><span class=\"p\" data-group-id=\"8570092776-2\">}</span><span class=\"p\" data-group-id=\"8570092776-1\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\">\n      </span><span class=\"p\" data-group-id=\"8570092776-3\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"8570092776-4\">#{</span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">UserId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">name</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;Alice&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\" data-group-id=\"8570092776-4\">}</span><span class=\"p\" data-group-id=\"8570092776-3\">}</span><span class=\"w\">\n  </span><span class=\"k\">end</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Advertise the service</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"8570092776-5\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"p\" data-group-id=\"8570092776-5\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">advertise</span><span class=\"p\" data-group-id=\"8570092776-6\">(</span><span class=\"w\">\n      </span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.get_user&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"n\">Handler</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"8570092776-6\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Other clients can now call:</span><span class=\"w\">\n  </span><span class=\"c1\">%% {ok, User} = macula_client:call(OtherClient, &amp;lt;&amp;lt;&quot;my.app.get_user&quot;&amp;gt;&amp;gt;,</span><span class=\"w\">\n  </span><span class=\"c1\">%%     #{user_id =&gt; &amp;lt;&amp;lt;&quot;user-123&quot;&amp;gt;&amp;gt;}).</span>","ref":"macula_client.html#advertise/3"},{"type":"function","title":"macula_client.advertise/4","doc":"Advertise a service with options.","ref":"macula_client.html#advertise/4"},{"type":"type","title":"macula_client.args/0","doc":"Arguments for RPC calls.","ref":"macula_client.html#t:args/0"},{"type":"function","title":"macula_client.call/3","doc":"Make a synchronous RPC call. Calls a remote procedure and waits for the result. Examples <span class=\"w\">  </span><span class=\"c1\">%% Simple RPC call</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7639836260-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">User</span><span class=\"p\" data-group-id=\"7639836260-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">call</span><span class=\"p\" data-group-id=\"7639836260-2\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.get_user&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"7639836260-3\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;user-123&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7639836260-3\">}</span><span class=\"p\" data-group-id=\"7639836260-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% With timeout</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7639836260-4\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"p\" data-group-id=\"7639836260-4\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">call</span><span class=\"p\" data-group-id=\"7639836260-5\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.process&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"p\" data-group-id=\"7639836260-6\">#{</span><span class=\"ss\">data</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;large&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\" data-group-id=\"7639836260-6\">}</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"p\" data-group-id=\"7639836260-7\">#{</span><span class=\"ss\">timeout</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">30000</span><span class=\"p\" data-group-id=\"7639836260-7\">}</span><span class=\"p\" data-group-id=\"7639836260-5\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#call/3"},{"type":"function","title":"macula_client.call/4","doc":"Make an RPC call with options.","ref":"macula_client.html#call/4"},{"type":"type","title":"macula_client.client/0","doc":"Reference to a connected Macula mesh client.","ref":"macula_client.html#t:client/0"},{"type":"function","title":"macula_client.connect/2","doc":"Connect to a Macula mesh network. Creates a new HTTP/3 (QUIC) connection to the specified mesh endpoint. Options realm  - Required. Binary realm identifier (e.g.,  &lt;&lt;\"my.app.realm\"&gt;&gt; ) auth  - Optional. Authentication map with  api_key  or other auth methods timeout  - Optional. Connection timeout in milliseconds (default: 5000) node_id  - Optional. 32-byte node ID (generated if not provided) Examples <span class=\"w\">  </span><span class=\"c1\">%% Basic connection</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7096525550-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Client</span><span class=\"p\" data-group-id=\"7096525550-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">connect</span><span class=\"p\" data-group-id=\"7096525550-2\">(</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;https://mesh.local:443&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"7096525550-3\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">realm</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.realm&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7096525550-3\">}</span><span class=\"p\" data-group-id=\"7096525550-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% With API key authentication</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7096525550-4\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Client</span><span class=\"p\" data-group-id=\"7096525550-4\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">connect</span><span class=\"p\" data-group-id=\"7096525550-5\">(</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;https://mesh.local:443&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"7096525550-6\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">realm</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.realm&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">auth</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"7096525550-7\">#{</span><span class=\"ss\">api_key</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;secret-key&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\" data-group-id=\"7096525550-7\">}</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"7096525550-6\">}</span><span class=\"p\" data-group-id=\"7096525550-5\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#connect/2"},{"type":"function","title":"macula_client.disconnect/1","doc":"Disconnect from the Macula mesh. Cleanly closes the HTTP/3 connection and cleans up all subscriptions.","ref":"macula_client.html#disconnect/1"},{"type":"type","title":"macula_client.event_data/0","doc":"Event payload data. Typically a map that will be JSON-encoded.","ref":"macula_client.html#t:event_data/0"},{"type":"type","title":"macula_client.options/0","doc":"Connection or operation options.","ref":"macula_client.html#t:options/0"},{"type":"type","title":"macula_client.procedure/0","doc":"RPC procedure name. Example:  \"my.app.get_user\" .","ref":"macula_client.html#t:procedure/0"},{"type":"function","title":"macula_client.publish/3","doc":"Publish an event to a topic. Publishes data to the specified topic. All subscribers to this topic will receive the event. Topic Design Topics should describe EVENT TYPES, not entity instances: Good:  &lt;&lt;\"my.app.user.registered\"&gt;&gt;  (event type) Bad:  &lt;&lt;\"my.app.user.123.registered\"&gt;&gt;  (entity ID in topic) Entity IDs belong in the event payload, not the topic name. Examples <span class=\"w\">  </span><span class=\"c1\">%% Publish with default options</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">publish</span><span class=\"p\" data-group-id=\"9410684228-1\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"9410684228-2\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">type</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;user.registered&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;user-123&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">email</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;user@example.com&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"9410684228-2\">}</span><span class=\"p\" data-group-id=\"9410684228-1\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Publish with options</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">publish</span><span class=\"p\" data-group-id=\"9410684228-3\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"9410684228-4\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">data</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;important&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"9410684228-4\">}</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"9410684228-5\">#{</span><span class=\"ss\">acknowledge</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"ss\">true</span><span class=\"p\" data-group-id=\"9410684228-5\">}</span><span class=\"p\" data-group-id=\"9410684228-3\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#publish/3"},{"type":"function","title":"macula_client.publish/4","doc":"Publish an event with options.","ref":"macula_client.html#publish/4"},{"type":"function","title":"macula_client.subscribe/3","doc":"Subscribe to a topic. Subscribes to events on the specified topic. The callback function will be invoked for each event received. Callback Function The callback receives the event data and should return  ok . Examples <span class=\"w\">  </span><span class=\"c1\">%% Simple subscription</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"8224085953-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SubRef</span><span class=\"p\" data-group-id=\"8224085953-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">subscribe</span><span class=\"p\" data-group-id=\"8224085953-2\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"nf\">fun</span><span class=\"p\" data-group-id=\"8224085953-3\">(</span><span class=\"n\">EventData</span><span class=\"p\" data-group-id=\"8224085953-3\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\">\n          </span><span class=\"nc\">io</span><span class=\"p\">:</span><span class=\"nf\">format</span><span class=\"p\" data-group-id=\"8224085953-4\">(</span><span class=\"s\">&quot;Event: </span><span class=\"si\">~p</span><span class=\"si\">~n</span><span class=\"s\">&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"8224085953-5\">[</span><span class=\"n\">EventData</span><span class=\"p\" data-group-id=\"8224085953-5\">]</span><span class=\"p\" data-group-id=\"8224085953-4\">)</span><span class=\"p\">,</span><span class=\"w\">\n          </span><span class=\"ss\">ok</span><span class=\"w\">\n      </span><span class=\"k\">end</span><span class=\"p\" data-group-id=\"8224085953-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Unsubscribe later</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">unsubscribe</span><span class=\"p\" data-group-id=\"8224085953-6\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SubRef</span><span class=\"p\" data-group-id=\"8224085953-6\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#subscribe/3"},{"type":"type","title":"macula_client.subscription_ref/0","doc":"Reference to an active subscription for unsubscribe operations.","ref":"macula_client.html#t:subscription_ref/0"},{"type":"type","title":"macula_client.topic/0","doc":"Topic name for pub/sub operations. Topics should describe event types, not entity IDs. Example:  \"my.app.user.registered\"  (good), not  \"my.app.user.123.registered\"  (bad - ID belongs in payload).","ref":"macula_client.html#t:topic/0"},{"type":"function","title":"macula_client.unadvertise/2","doc":"Stop advertising a service. Removes the local handler and stops advertising to the DHT. Examples <span class=\"w\">  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">unadvertise</span><span class=\"p\" data-group-id=\"4749673077-1\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;my.app.get_user&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\" data-group-id=\"4749673077-1\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#unadvertise/2"},{"type":"function","title":"macula_client.unsubscribe/2","doc":"Unsubscribe from a topic. Removes the subscription identified by the subscription reference.","ref":"macula_client.html#unsubscribe/2"},{"type":"module","title":"macula_connection","doc":"Macula Connection - QUIC Transport Layer (v0.7.0+). This module manages the low-level QUIC connection lifecycle and message transport for mesh participants. Responsibilities: - Establish and maintain QUIC connection - Send messages via QUIC stream - Receive and route incoming messages to handlers - Handle connection errors and reconnection - Message encoding/decoding and buffering Renamed from macula_connection in v0.7.0 for clarity: - macula_connection = QUIC transport (this module - low-level) - macula_peer = mesh participant (high-level API)","ref":"macula_connection.html"},{"type":"function","title":"macula_connection.decode_messages/2","doc":"Decode all complete messages from buffer.","ref":"macula_connection.html#decode_messages/2"},{"type":"function","title":"macula_connection.default_config/0","doc":"","ref":"macula_connection.html#default_config/0"},{"type":"function","title":"macula_connection.get_status/1","doc":"","ref":"macula_connection.html#get_status/1"},{"type":"function","title":"macula_connection.handle_call/3","doc":"","ref":"macula_connection.html#handle_call/3"},{"type":"function","title":"macula_connection.handle_cast/2","doc":"","ref":"macula_connection.html#handle_cast/2"},{"type":"function","title":"macula_connection.handle_info/2","doc":"","ref":"macula_connection.html#handle_info/2"},{"type":"function","title":"macula_connection.init/1","doc":"","ref":"macula_connection.html#init/1"},{"type":"function","title":"macula_connection.send_message/3","doc":"","ref":"macula_connection.html#send_message/3"},{"type":"function","title":"macula_connection.start_keepalive_timer/1","doc":"Start keep-alive timer if enabled in options.","ref":"macula_connection.html#start_keepalive_timer/1"},{"type":"function","title":"macula_connection.start_link/2","doc":"","ref":"macula_connection.html#start_link/2"},{"type":"function","title":"macula_connection.terminate/2","doc":"","ref":"macula_connection.html#terminate/2"},{"type":"module","title":"macula_connection_pool","doc":"Connection pool manager for endpoint connections. Manages a pool of QUIC connections to remote endpoints, providing connection caching and reuse to avoid connection overhead for multi-endpoint RPC operations. Connection pool structure: #{Endpoint => #{connection => Conn, stream => Stream, last_used => Timestamp}}","ref":"macula_connection_pool.html"},{"type":"function","title":"macula_connection_pool.close_all_connections/1","doc":"Close all connections in the pool.","ref":"macula_connection_pool.html#close_all_connections/1"},{"type":"function","title":"macula_connection_pool.create_connection/4","doc":"Create a new connection to an endpoint.","ref":"macula_connection_pool.html#create_connection/4"},{"type":"function","title":"macula_connection_pool.get_or_create_connection/4","doc":"Get or create a connection to an endpoint. Returns {ok, Conn, Stream, UpdatedPool} or {error, Reason, Pool}.","ref":"macula_connection_pool.html#get_or_create_connection/4"},{"type":"module","title":"macula_connection_sup","doc":"Supervisor for the connection subsystem. Supervision Strategy: - rest_for_one: If child N crashes, restart N and all children after N - Rationale: connection_manager is foundational; handlers depend on it but are independent of each other. This provides fault isolation while maintaining consistency when connection_manager restarts. Children (in dependency order): - macula_connection: QUIC connection lifecycle (foundational) - macula_pubsub_handler: Pub/sub operations (depends on connection_manager) - macula_rpc_handler: RPC operations (depends on connection_manager) - macula_advertisement_manager: DHT advertisements (depends on connection_manager) Fault Isolation: - advertisement_manager crash → only advertisement restarts - rpc_handler crash → rpc + advertisement restart - pubsub_handler crash → pubsub + rpc + advertisement restart - connection_manager crash → all restart (unavoidable - foundational)","ref":"macula_connection_sup.html"},{"type":"function","title":"macula_connection_sup.init/1","doc":"Initialize the supervisor with child specifications.","ref":"macula_connection_sup.html#init/1"},{"type":"function","title":"macula_connection_sup.start_link/2","doc":"Start the connection supervisor with given URL and options.","ref":"macula_connection_sup.html#start_link/2"},{"type":"function","title":"macula_connection_sup.stop/1","doc":"Stop the connection supervisor and all children.","ref":"macula_connection_sup.html#stop/1"},{"type":"module","title":"macula_core_types","doc":"Core type definitions and encoding/decoding for Macula. Provides fundamental types like node IDs, realm IDs, and addresses.","ref":"macula_core_types.html"},{"type":"type","title":"macula_core_types.address/0","doc":"","ref":"macula_core_types.html#t:address/0"},{"type":"function","title":"macula_core_types.decode_address/1","doc":"Decode binary address format to {IP, Port} tuple.","ref":"macula_core_types.html#decode_address/1"},{"type":"function","title":"macula_core_types.encode_address/1","doc":"Encode an IP address and port to binary format. Format: - 1 byte: IP version (4 or 6) - 4 or 16 bytes: IP address - 2 bytes: port (big-endian)","ref":"macula_core_types.html#encode_address/1"},{"type":"type","title":"macula_core_types.ip_address/0","doc":"","ref":"macula_core_types.html#t:ip_address/0"},{"type":"type","title":"macula_core_types.node_id/0","doc":"32-byte unique node identifier","ref":"macula_core_types.html#t:node_id/0"},{"type":"function","title":"macula_core_types.node_id/0","doc":"Generate a unique node ID. Uses cryptographically strong random bytes for uniqueness.","ref":"macula_core_types.html#node_id/0"},{"type":"type","title":"macula_core_types.port_number/0","doc":"","ref":"macula_core_types.html#t:port_number/0"},{"type":"type","title":"macula_core_types.realm_id/0","doc":"32-byte realm identifier","ref":"macula_core_types.html#t:realm_id/0"},{"type":"function","title":"macula_core_types.realm_id/1","doc":"Generate a deterministic realm ID from a realm name. Same name always produces the same ID (uses SHA-256 hash).","ref":"macula_core_types.html#realm_id/1"},{"type":"module","title":"macula_dht_rpc","doc":"DHT RPC client for querying remote nodes. Provides callback functions for macula_routing_dht algorithms.","ref":"macula_dht_rpc.html"},{"type":"function","title":"macula_dht_rpc.make_query_fn/0","doc":"Create a query_fn callback for DHT algorithms.","ref":"macula_dht_rpc.html#make_query_fn/0"},{"type":"function","title":"macula_dht_rpc.make_store_fn/0","doc":"Create a store_fn callback for DHT algorithms.","ref":"macula_dht_rpc.html#make_store_fn/0"},{"type":"function","title":"macula_dht_rpc.query_find_node/2","doc":"Query remote node for closest nodes to target. Returns {ok, [NodeInfo]} or {error, Reason}.","ref":"macula_dht_rpc.html#query_find_node/2"},{"type":"function","title":"macula_dht_rpc.query_find_value/2","doc":"Query remote node for value by key. Returns {value, Value} if found, {nodes, [NodeInfo]} if not found, or {error, Reason}.","ref":"macula_dht_rpc.html#query_find_value/2"},{"type":"function","title":"macula_dht_rpc.query_store/3","doc":"Store key-value pair on remote node. Returns ok or {error, Reason}.","ref":"macula_dht_rpc.html#query_store/3"},{"type":"module","title":"macula_discovery","doc":"Generic DHT-based service discovery. Provides cache-integrated lookup and announcement operations. Used by both pub/sub and RPC discovery layers.","ref":"macula_discovery.html"},{"type":"function","title":"macula_discovery.announce/2","doc":"Announce value to DHT.","ref":"macula_discovery.html#announce/2"},{"type":"function","title":"macula_discovery.filter_by_age/3","doc":"Filter items by age based on last_seen timestamp and TTL. Items must have #{last_seen := integer()} in their structure.","ref":"macula_discovery.html#filter_by_age/3"},{"type":"function","title":"macula_discovery.find/2","doc":"Find values for a key via DHT lookup.","ref":"macula_discovery.html#find/2"},{"type":"function","title":"macula_discovery.find_with_cache/3","doc":"Find values with cache (default TTL: 300 seconds).","ref":"macula_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_discovery.find_with_cache/4","doc":"Find values with cache and custom TTL.","ref":"macula_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_discovery.key/0","doc":"","ref":"macula_discovery.html#t:key/0"},{"type":"type","title":"macula_discovery.lookup_fun/0","doc":"","ref":"macula_discovery.html#t:lookup_fun/0"},{"type":"type","title":"macula_discovery.publish_fun/0","doc":"","ref":"macula_discovery.html#t:publish_fun/0"},{"type":"function","title":"macula_discovery.unannounce/2","doc":"Remove value from DHT.","ref":"macula_discovery.html#unannounce/2"},{"type":"type","title":"macula_discovery.unpublish_fun/0","doc":"","ref":"macula_discovery.html#t:unpublish_fun/0"},{"type":"type","title":"macula_discovery.value/0","doc":"","ref":"macula_discovery.html#t:value/0"},{"type":"module","title":"macula_gateway","doc":"Macula Gateway - HTTP/3 Message Router & Orchestrator Main API module and coordinator for the Macula Gateway. The gateway can be embedded in applications or run standalone. Architecture (Modular Design - Refactored Jan 2025): ======================================================== Gateway (this module): - QUIC Listener Management - Message Decoding & Routing - Supervisor Coordination - API Facade Child Modules (managed via macula_gateway_sup): - macula_gateway_client_manager: Client lifecycle management - macula_gateway_pubsub: Pub/Sub message routing with wildcards - macula_gateway_rpc: RPC handler registration & invocation - macula_gateway_mesh: Mesh connection pooling Stateless Delegation Modules: - macula_gateway_dht: DHT query forwarding to routing server - macula_gateway_rpc_router: Multi-hop RPC routing via DHT Single Responsibility Principle: Each module has one clear purpose and delegates to specialized child modules. Gateway acts as orchestrator, not implementer. Usage (Embedded): <span class=\"w\">   </span><span class=\"p\" data-group-id=\"5962054729-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Pid</span><span class=\"p\" data-group-id=\"5962054729-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_gateway</span><span class=\"p\">:</span><span class=\"nf\">start_link</span><span class=\"p\" data-group-id=\"5962054729-2\">(</span><span class=\"p\" data-group-id=\"5962054729-3\">[</span><span class=\"w\">\n       </span><span class=\"p\" data-group-id=\"5962054729-4\">{</span><span class=\"ss\">port</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">9443</span><span class=\"p\" data-group-id=\"5962054729-4\">}</span><span class=\"p\">,</span><span class=\"w\">\n       </span><span class=\"p\" data-group-id=\"5962054729-5\">{</span><span class=\"ss\">realm</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;com.example.realm&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\" data-group-id=\"5962054729-5\">}</span><span class=\"w\">\n   </span><span class=\"p\" data-group-id=\"5962054729-3\">]</span><span class=\"p\" data-group-id=\"5962054729-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n  \n   </span><span class=\"c1\">%% Register RPC handler</span><span class=\"w\">\n   </span><span class=\"nc\">macula_gateway</span><span class=\"p\">:</span><span class=\"nf\">register_handler</span><span class=\"p\" data-group-id=\"5962054729-6\">(</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;add&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">fun</span><span class=\"p\" data-group-id=\"5962054729-7\">(</span><span class=\"p\" data-group-id=\"5962054729-8\">#{</span><span class=\"ss\">a</span><span class=\"w\"> </span><span class=\"p\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">b</span><span class=\"w\"> </span><span class=\"p\">:=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\" data-group-id=\"5962054729-8\">}</span><span class=\"p\" data-group-id=\"5962054729-7\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\">\n       </span><span class=\"p\" data-group-id=\"5962054729-9\">#{</span><span class=\"ss\">result</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\" data-group-id=\"5962054729-9\">}</span><span class=\"w\">\n   </span><span class=\"k\">end</span><span class=\"p\" data-group-id=\"5962054729-6\">)</span><span class=\"p\">.</span> Usage (Standalone): <span class=\"w\">   </span><span class=\"nc\">application</span><span class=\"p\">:</span><span class=\"nf\">start</span><span class=\"p\" data-group-id=\"1712256696-1\">(</span><span class=\"ss\">macula_gateway</span><span class=\"p\" data-group-id=\"1712256696-1\">)</span><span class=\"p\">.</span>","ref":"macula_gateway.html"},{"type":"function","title":"macula_gateway.get_stats/1","doc":"Get gateway statistics.","ref":"macula_gateway.html#get_stats/1"},{"type":"function","title":"macula_gateway.handle_call/3","doc":"","ref":"macula_gateway.html#handle_call/3"},{"type":"function","title":"macula_gateway.handle_cast/2","doc":"Handle rpc_route message forwarded from connection","ref":"macula_gateway.html#handle_cast/2"},{"type":"function","title":"macula_gateway.handle_info/2","doc":"","ref":"macula_gateway.html#handle_info/2"},{"type":"function","title":"macula_gateway.init/1","doc":"","ref":"macula_gateway.html#init/1"},{"type":"function","title":"macula_gateway.register_handler/2","doc":"Register a handler for a procedure.","ref":"macula_gateway.html#register_handler/2"},{"type":"function","title":"macula_gateway.start_link/0","doc":"Start the gateway with default options.","ref":"macula_gateway.html#start_link/0"},{"type":"function","title":"macula_gateway.start_link/1","doc":"Start the gateway with custom options. Options: {port, Port} - Listen port (default: 9443) {realm, Realm} - Default realm (default: \"macula.default\")","ref":"macula_gateway.html#start_link/1"},{"type":"function","title":"macula_gateway.stop/1","doc":"Stop the gateway.","ref":"macula_gateway.html#stop/1"},{"type":"function","title":"macula_gateway.terminate/2","doc":"","ref":"macula_gateway.html#terminate/2"},{"type":"function","title":"macula_gateway.unregister_handler/1","doc":"Unregister a handler for a procedure.","ref":"macula_gateway.html#unregister_handler/1"},{"type":"module","title":"macula_gateway_client_manager","doc":"Client Manager GenServer - manages client lifecycle and tracking. Responsibilities: - Track connected clients with metadata (BOUNDED POOL) - Enforce max_clients limit with backpressure - Monitor client processes for automatic cleanup - Store bidirectional streams for client communication - Provide client query APIs Pattern: Bounded client pool with backpressure - Tracks clients with max_clients limit (default: 10,000) - Rejects new clients when pool is full (backpressure) - Allows updates to existing clients even when pool is full Configuration: - max_clients: Maximum concurrent clients (default: 10,000) Extracted from macula_gateway.erl (Phase 2)","ref":"macula_gateway_client_manager.html"},{"type":"function","title":"macula_gateway_client_manager.client_connected/3","doc":"Register a connected client with metadata. Monitors the client process for automatic cleanup on death.","ref":"macula_gateway_client_manager.html#client_connected/3"},{"type":"function","title":"macula_gateway_client_manager.client_disconnected/2","doc":"Unregister a disconnected client.","ref":"macula_gateway_client_manager.html#client_disconnected/2"},{"type":"type","title":"macula_gateway_client_manager.client_info/0","doc":"","ref":"macula_gateway_client_manager.html#t:client_info/0"},{"type":"function","title":"macula_gateway_client_manager.get_all_clients/1","doc":"Get all connected clients.","ref":"macula_gateway_client_manager.html#get_all_clients/1"},{"type":"function","title":"macula_gateway_client_manager.get_client_info/2","doc":"Get information about a specific client.","ref":"macula_gateway_client_manager.html#get_client_info/2"},{"type":"function","title":"macula_gateway_client_manager.get_client_stream/2","doc":"Get the stored stream for a client node.","ref":"macula_gateway_client_manager.html#get_client_stream/2"},{"type":"function","title":"macula_gateway_client_manager.handle_call/3","doc":"","ref":"macula_gateway_client_manager.html#handle_call/3"},{"type":"function","title":"macula_gateway_client_manager.handle_cast/2","doc":"","ref":"macula_gateway_client_manager.html#handle_cast/2"},{"type":"function","title":"macula_gateway_client_manager.handle_info/2","doc":"Handle client process death - automatic cleanup.","ref":"macula_gateway_client_manager.html#handle_info/2"},{"type":"function","title":"macula_gateway_client_manager.init/1","doc":"","ref":"macula_gateway_client_manager.html#init/1"},{"type":"function","title":"macula_gateway_client_manager.is_client_alive/2","doc":"Check if a client is alive (process still running).","ref":"macula_gateway_client_manager.html#is_client_alive/2"},{"type":"function","title":"macula_gateway_client_manager.start_link/1","doc":"Start the client manager with options.","ref":"macula_gateway_client_manager.html#start_link/1"},{"type":"function","title":"macula_gateway_client_manager.stop/1","doc":"Stop the client manager.","ref":"macula_gateway_client_manager.html#stop/1"},{"type":"function","title":"macula_gateway_client_manager.store_client_stream/3","doc":"Store a bidirectional stream for a client node.","ref":"macula_gateway_client_manager.html#store_client_stream/3"},{"type":"function","title":"macula_gateway_client_manager.terminate/2","doc":"","ref":"macula_gateway_client_manager.html#terminate/2"},{"type":"module","title":"macula_gateway_dht","doc":"DHT Query Handler Module - handles DHT message forwarding to routing server. Responsibilities: - Forward DHT STORE messages to routing server - Forward DHT FIND_VALUE messages to routing server, send encoded replies - Forward DHT FIND_NODE messages to routing server, send encoded replies - Handle DHT queries from process messages - Encode replies using protocol encoder - Handle errors gracefully Pattern: Stateless delegation module - No GenServer (no state to manage) - Pure functions forwarding to routing server - Consistent error handling ({ok, Result} | {error, Reason}) Extracted from macula_gateway.erl (Phase 10)","ref":"macula_gateway_dht.html"},{"type":"function","title":"macula_gateway_dht.handle_find_node/2","doc":"Handle DHT FIND_NODE message. Forwards to routing server and sends encoded reply over stream. Crashes on routing server or encoding failures - exposes DHT/protocol bugs.","ref":"macula_gateway_dht.html#handle_find_node/2"},{"type":"function","title":"macula_gateway_dht.handle_find_value/2","doc":"Handle DHT FIND_VALUE message. Forwards to routing server and sends encoded reply over stream. Crashes on routing server or encoding failures - exposes DHT/protocol bugs.","ref":"macula_gateway_dht.html#handle_find_value/2"},{"type":"function","title":"macula_gateway_dht.handle_query/3","doc":"Handle DHT query from process message. Decodes query, forwards to routing server, encodes reply, sends to requesting process. Crashes on decode or routing failures - exposes protocol/DHT bugs.","ref":"macula_gateway_dht.html#handle_query/3"},{"type":"function","title":"macula_gateway_dht.handle_store/2","doc":"Handle DHT STORE message. Forwards to routing server (no reply sent back). Crashes on routing server failures - this exposes DHT issues immediately.","ref":"macula_gateway_dht.html#handle_store/2"},{"type":"module","title":"macula_gateway_diagnostics","doc":"Macula Gateway Diagnostics Service Provides simple diagnostic procedures that clients can call to verify connectivity and test the gateway's RPC functionality. Available procedures: - com.macula.diagnostics.hello - Returns a friendly greeting with gateway info - com.macula.diagnostics.echo - Echoes back the arguments sent by client - com.macula.diagnostics.info - Returns detailed gateway information Usage: The diagnostics service automatically registers when the gateway starts. Clients can call these procedures using the Macula SDK: Elixir: {:ok, result} = MaculaSdk.Client.call(client, \"com.macula.diagnostics.hello\", %{}) Result: %{ \"message\" => \"Hello from Macula Gateway!\", \"gateway\" => \"macula@127.0.0.1\", \"realm\" => \"com.example.realm\", \"uptime_seconds\" => 42, \"timestamp\" => 1699612800 }","ref":"macula_gateway_diagnostics.html"},{"type":"function","title":"macula_gateway_diagnostics.handle_call/3","doc":"","ref":"macula_gateway_diagnostics.html#handle_call/3"},{"type":"function","title":"macula_gateway_diagnostics.handle_cast/2","doc":"","ref":"macula_gateway_diagnostics.html#handle_cast/2"},{"type":"function","title":"macula_gateway_diagnostics.handle_info/2","doc":"","ref":"macula_gateway_diagnostics.html#handle_info/2"},{"type":"function","title":"macula_gateway_diagnostics.init/1","doc":"","ref":"macula_gateway_diagnostics.html#init/1"},{"type":"function","title":"macula_gateway_diagnostics.register_procedures/1","doc":"Register diagnostic procedures with the gateway","ref":"macula_gateway_diagnostics.html#register_procedures/1"},{"type":"function","title":"macula_gateway_diagnostics.start_link/1","doc":"Start the diagnostics service","ref":"macula_gateway_diagnostics.html#start_link/1"},{"type":"function","title":"macula_gateway_diagnostics.terminate/2","doc":"","ref":"macula_gateway_diagnostics.html#terminate/2"},{"type":"module","title":"macula_gateway_health","doc":"Macula Gateway Health Check Server Provides HTTP health endpoints for Kubernetes liveness and readiness probes. Runs on a separate port (8080) from the main QUIC gateway (9443). Endpoints: GET /health - Overall health status GET /ready - Readiness check (can accept traffic) GET /live - Liveness check (process is alive) GET /metrics - Basic metrics (optional)","ref":"macula_gateway_health.html"},{"type":"function","title":"macula_gateway_health.handle_call/3","doc":"","ref":"macula_gateway_health.html#handle_call/3"},{"type":"function","title":"macula_gateway_health.handle_cast/2","doc":"","ref":"macula_gateway_health.html#handle_cast/2"},{"type":"function","title":"macula_gateway_health.handle_info/2","doc":"","ref":"macula_gateway_health.html#handle_info/2"},{"type":"function","title":"macula_gateway_health.init/1","doc":"","ref":"macula_gateway_health.html#init/1"},{"type":"function","title":"macula_gateway_health.is_healthy/0","doc":"Check if the gateway is healthy.","ref":"macula_gateway_health.html#is_healthy/0"},{"type":"function","title":"macula_gateway_health.set_ready/1","doc":"Set the readiness state.","ref":"macula_gateway_health.html#set_ready/1"},{"type":"function","title":"macula_gateway_health.start_link/1","doc":"Start the health check server.","ref":"macula_gateway_health.html#start_link/1"},{"type":"function","title":"macula_gateway_health.stop/0","doc":"Stop the health check server.","ref":"macula_gateway_health.html#stop/0"},{"type":"function","title":"macula_gateway_health.terminate/2","doc":"","ref":"macula_gateway_health.html#terminate/2"},{"type":"module","title":"macula_gateway_mesh","doc":"Mesh Connection Manager GenServer - manages peer-to-peer QUIC connections. Responsibilities: - Pool QUIC connections to remote peers by node_id (BOUNDED POOL) - Enforce max_connections limit with LRU eviction - Check connection liveness before reuse - Open new streams on pooled connections - Monitor connection processes for automatic cleanup - Cache connection metadata with timestamps Pattern: Bounded connection pooling with LRU eviction - Cache connections by node_id (max: max_mesh_connections, default 1000) - Evict least recently used when pool is full - Verify liveness before reuse (open new stream) - Remove dead connections and recreate on demand Configuration: - max_mesh_connections: Maximum pooled connections (default: 1000) Extracted from macula_gateway.erl (Phase 9)","ref":"macula_gateway_mesh.html"},{"type":"type","title":"macula_gateway_mesh.connection_info/0","doc":"","ref":"macula_gateway_mesh.html#t:connection_info/0"},{"type":"function","title":"macula_gateway_mesh.get_connection_info/2","doc":"Get connection metadata for a node.","ref":"macula_gateway_mesh.html#get_connection_info/2"},{"type":"function","title":"macula_gateway_mesh.get_or_create_connection/3","doc":"Get existing connection or create new one. Returns opened stream ready for use.","ref":"macula_gateway_mesh.html#get_or_create_connection/3"},{"type":"function","title":"macula_gateway_mesh.handle_call/3","doc":"","ref":"macula_gateway_mesh.html#handle_call/3"},{"type":"function","title":"macula_gateway_mesh.handle_cast/2","doc":"","ref":"macula_gateway_mesh.html#handle_cast/2"},{"type":"function","title":"macula_gateway_mesh.handle_info/2","doc":"","ref":"macula_gateway_mesh.html#handle_info/2"},{"type":"function","title":"macula_gateway_mesh.init/1","doc":"","ref":"macula_gateway_mesh.html#init/1"},{"type":"function","title":"macula_gateway_mesh.list_connections/1","doc":"List all cached connections.","ref":"macula_gateway_mesh.html#list_connections/1"},{"type":"function","title":"macula_gateway_mesh.remove_connection/2","doc":"Explicitly remove connection from cache.","ref":"macula_gateway_mesh.html#remove_connection/2"},{"type":"function","title":"macula_gateway_mesh.start_link/1","doc":"Start the mesh connection manager with options. Options: - cert_file: Path to TLS certificate - key_file: Path to TLS private key","ref":"macula_gateway_mesh.html#start_link/1"},{"type":"function","title":"macula_gateway_mesh.stop/1","doc":"Stop the mesh connection manager.","ref":"macula_gateway_mesh.html#stop/1"},{"type":"function","title":"macula_gateway_mesh.terminate/2","doc":"","ref":"macula_gateway_mesh.html#terminate/2"},{"type":"module","title":"macula_gateway_pubsub","doc":"Pub/Sub Handler GenServer - manages topic subscriptions and message routing. Responsibilities: - Subscribe/unsubscribe streams to topics - Route published messages to matching subscribers - Support wildcard topics (* single-level, ** multi-level) - Track bidirectional mapping (topic ↔ stream) - Monitor stream processes for automatic cleanup Extracted from macula_gateway.erl (Phase 3)","ref":"macula_gateway_pubsub.html"},{"type":"function","title":"macula_gateway_pubsub.get_stream_topics/2","doc":"Get all topics a stream is subscribed to.","ref":"macula_gateway_pubsub.html#get_stream_topics/2"},{"type":"function","title":"macula_gateway_pubsub.get_subscribers/2","doc":"Get all subscribers for a topic (exact and wildcard matches).","ref":"macula_gateway_pubsub.html#get_subscribers/2"},{"type":"function","title":"macula_gateway_pubsub.handle_call/3","doc":"","ref":"macula_gateway_pubsub.html#handle_call/3"},{"type":"function","title":"macula_gateway_pubsub.handle_cast/2","doc":"","ref":"macula_gateway_pubsub.html#handle_cast/2"},{"type":"function","title":"macula_gateway_pubsub.handle_info/2","doc":"Handle stream process death - automatic cleanup.","ref":"macula_gateway_pubsub.html#handle_info/2"},{"type":"function","title":"macula_gateway_pubsub.init/1","doc":"","ref":"macula_gateway_pubsub.html#init/1"},{"type":"function","title":"macula_gateway_pubsub.publish/3","doc":"Publish a message to a topic (routes to matching subscribers).","ref":"macula_gateway_pubsub.html#publish/3"},{"type":"function","title":"macula_gateway_pubsub.start_link/1","doc":"Start the pub/sub handler with options.","ref":"macula_gateway_pubsub.html#start_link/1"},{"type":"function","title":"macula_gateway_pubsub.stop/1","doc":"Stop the pub/sub handler.","ref":"macula_gateway_pubsub.html#stop/1"},{"type":"function","title":"macula_gateway_pubsub.subscribe/3","doc":"Subscribe a stream to a topic (supports wildcards).","ref":"macula_gateway_pubsub.html#subscribe/3"},{"type":"function","title":"macula_gateway_pubsub.terminate/2","doc":"","ref":"macula_gateway_pubsub.html#terminate/2"},{"type":"function","title":"macula_gateway_pubsub.unsubscribe/3","doc":"Unsubscribe a stream from a topic.","ref":"macula_gateway_pubsub.html#unsubscribe/3"},{"type":"module","title":"macula_gateway_rpc","doc":"RPC Handler GenServer - manages RPC handler registration and call routing. Responsibilities: - Register/unregister RPC handlers for procedures - Route RPC calls to registered handlers - Handle call/response matching - Monitor handler processes for automatic cleanup Extracted from macula_gateway.erl (Phase 4)","ref":"macula_gateway_rpc.html"},{"type":"function","title":"macula_gateway_rpc.call/4","doc":"Make an RPC call to a procedure.","ref":"macula_gateway_rpc.html#call/4"},{"type":"function","title":"macula_gateway_rpc.get_handler/2","doc":"Get the handler for a procedure.","ref":"macula_gateway_rpc.html#get_handler/2"},{"type":"function","title":"macula_gateway_rpc.handle_call/3","doc":"","ref":"macula_gateway_rpc.html#handle_call/3"},{"type":"function","title":"macula_gateway_rpc.handle_cast/2","doc":"","ref":"macula_gateway_rpc.html#handle_cast/2"},{"type":"function","title":"macula_gateway_rpc.handle_info/2","doc":"Handle handler process death - automatic cleanup.","ref":"macula_gateway_rpc.html#handle_info/2"},{"type":"function","title":"macula_gateway_rpc.init/1","doc":"","ref":"macula_gateway_rpc.html#init/1"},{"type":"function","title":"macula_gateway_rpc.list_handlers/1","doc":"List all registered handlers.","ref":"macula_gateway_rpc.html#list_handlers/1"},{"type":"function","title":"macula_gateway_rpc.register_handler/3","doc":"Register a handler for an RPC procedure.","ref":"macula_gateway_rpc.html#register_handler/3"},{"type":"function","title":"macula_gateway_rpc.start_link/1","doc":"Start the RPC handler with options.","ref":"macula_gateway_rpc.html#start_link/1"},{"type":"function","title":"macula_gateway_rpc.stop/1","doc":"Stop the RPC handler.","ref":"macula_gateway_rpc.html#stop/1"},{"type":"function","title":"macula_gateway_rpc.terminate/2","doc":"","ref":"macula_gateway_rpc.html#terminate/2"},{"type":"function","title":"macula_gateway_rpc.unregister_handler/2","doc":"Unregister a handler for an RPC procedure.","ref":"macula_gateway_rpc.html#unregister_handler/2"},{"type":"module","title":"macula_gateway_rpc_router","doc":"RPC Router Module - handles routed RPC messages (CALL/REPLY). Responsibilities: - Process routed CALL messages delivered locally - Process routed REPLY messages delivered locally - Send REPLY back via routing path - Forward rpc_route messages to next hop - Coordinate between RPC handler, mesh, and routing modules Pattern: Stateless delegation module - No GenServer (no state to manage) - Pure functions coordinating between modules - Consistent error handling ({ok, Result} | {error, Reason}) Extracted from macula_gateway.erl (Phase 11)","ref":"macula_gateway_rpc_router.html"},{"type":"function","title":"macula_gateway_rpc_router.forward_rpc_route/3","doc":"Forward rpc_route message to next hop. Gets mesh connection and sends encoded message. Crashes on connection/encoding failures - exposes mesh/protocol issues.","ref":"macula_gateway_rpc_router.html#forward_rpc_route/3"},{"type":"function","title":"macula_gateway_rpc_router.handle_routed_call/5","doc":"Handle routed CALL message delivered locally. Looks up RPC handler, invokes it, sends reply via routing path.","ref":"macula_gateway_rpc_router.html#handle_routed_call/5"},{"type":"function","title":"macula_gateway_rpc_router.handle_routed_reply/4","doc":"Handle routed REPLY message delivered locally. Routes to connection via gproc (local node) or to client stream (remote client).","ref":"macula_gateway_rpc_router.html#handle_routed_reply/4"},{"type":"function","title":"macula_gateway_rpc_router.send_reply_via_routing/4","doc":"Send REPLY back via routing path. Wraps reply in rpc_route envelope and routes to destination. Crashes on routing failures - exposes mesh/routing issues immediately.","ref":"macula_gateway_rpc_router.html#send_reply_via_routing/4"},{"type":"module","title":"macula_gateway_sup","doc":"Gateway Supervisor - supervises all gateway worker processes. Supervision Strategy: - rest_for_one: If child N crashes, restart N and all children after N - Rationale: Only client_manager is foundational; pubsub/rpc/mesh depend on it but are independent of each other. This strategy provides fault isolation while maintaining consistency when client_manager restarts. Children (in dependency order): - macula_gateway_client_manager: Client lifecycle management (foundational) - macula_gateway_pubsub: Pub/Sub message routing (depends on client_manager) - macula_gateway_rpc: RPC handler registration and routing (depends on client_manager) - macula_gateway_mesh: Mesh connection pooling and management (independent) Fault Isolation Examples: - mesh crash → only mesh restarts (0 clients disconnected) - rpc crash → rpc + mesh restart (0 clients disconnected) - pubsub crash → pubsub + rpc + mesh restart (0 clients disconnected) - client_manager crash → all restart (unavoidable - foundational) Extracted from macula_gateway.erl (Phase 6, 9)","ref":"macula_gateway_sup.html"},{"type":"function","title":"macula_gateway_sup.get_client_manager/1","doc":"Get the client manager child PID.","ref":"macula_gateway_sup.html#get_client_manager/1"},{"type":"function","title":"macula_gateway_sup.get_mesh/1","doc":"Get the mesh connection manager child PID.","ref":"macula_gateway_sup.html#get_mesh/1"},{"type":"function","title":"macula_gateway_sup.get_pubsub/1","doc":"Get the pubsub handler child PID.","ref":"macula_gateway_sup.html#get_pubsub/1"},{"type":"function","title":"macula_gateway_sup.get_rpc/1","doc":"Get the RPC handler child PID.","ref":"macula_gateway_sup.html#get_rpc/1"},{"type":"function","title":"macula_gateway_sup.init/1","doc":"","ref":"macula_gateway_sup.html#init/1"},{"type":"function","title":"macula_gateway_sup.start_link/1","doc":"Start the gateway supervisor with configuration.","ref":"macula_gateway_sup.html#start_link/1"},{"type":"module","title":"macula_id","doc":"ID generation utilities for Macula. Provides functions for generating various types of IDs.","ref":"macula_id.html"},{"type":"function","title":"macula_id.from_hex/1","doc":"Convert hex string to binary. Crashes on invalid hex - exposes bugs in validation logic.","ref":"macula_id.html#from_hex/1"},{"type":"function","title":"macula_id.from_uuid/1","doc":"Convert UUID string to 16-byte binary ID. Crashes on invalid UUID format - exposes bugs in validation logic.","ref":"macula_id.html#from_uuid/1"},{"type":"function","title":"macula_id.hash_id/1","doc":"Generate deterministic 256-bit hash ID from data.","ref":"macula_id.html#hash_id/1"},{"type":"function","title":"macula_id.message_id/0","doc":"Generate 128-bit (16-byte) random message ID.","ref":"macula_id.html#message_id/0"},{"type":"function","title":"macula_id.node_id/0","doc":"Generate 256-bit (32-byte) random node ID.","ref":"macula_id.html#node_id/0"},{"type":"function","title":"macula_id.session_id/0","doc":"Generate 128-bit (16-byte) random session ID.","ref":"macula_id.html#session_id/0"},{"type":"function","title":"macula_id.to_hex/1","doc":"Convert binary to lowercase hex string.","ref":"macula_id.html#to_hex/1"},{"type":"function","title":"macula_id.to_uuid/1","doc":"Convert 16-byte or 32-byte binary ID to UUID string format. For 16-byte: 8-4-4-4-12 (e.g., \"12345678-90ab-cdef-1234-567890abcdef\") For 32-byte: Uses first 16 bytes","ref":"macula_id.html#to_uuid/1"},{"type":"module","title":"macula_membership_detector","doc":"SWIM failure detector (pure logic, no GenServer). Orchestrates member list, gossip, and protocol timing.","ref":"macula_membership_detector.html"},{"type":"function","title":"macula_membership_detector.add_member/2","doc":"Add a member to the list.","ref":"macula_membership_detector.html#add_member/2"},{"type":"function","title":"macula_membership_detector.apply_gossip_updates/2","doc":"Apply received gossip updates.","ref":"macula_membership_detector.html#apply_gossip_updates/2"},{"type":"type","title":"macula_membership_detector.detector_state/0","doc":"","ref":"macula_membership_detector.html#t:detector_state/0"},{"type":"function","title":"macula_membership_detector.get_alive_members/1","doc":"Get all alive members.","ref":"macula_membership_detector.html#get_alive_members/1"},{"type":"function","title":"macula_membership_detector.get_gossip_updates/2","doc":"Get gossip updates to piggyback on messages.","ref":"macula_membership_detector.html#get_gossip_updates/2"},{"type":"function","title":"macula_membership_detector.get_member/2","doc":"Get a member by node ID.","ref":"macula_membership_detector.html#get_member/2"},{"type":"function","title":"macula_membership_detector.local_node_id/1","doc":"Get local node ID.","ref":"macula_membership_detector.html#local_node_id/1"},{"type":"function","title":"macula_membership_detector.mark_dead/2","doc":"Mark a member as dead.","ref":"macula_membership_detector.html#mark_dead/2"},{"type":"function","title":"macula_membership_detector.mark_suspect/2","doc":"Mark a member as suspect.","ref":"macula_membership_detector.html#mark_suspect/2"},{"type":"function","title":"macula_membership_detector.new/2","doc":"Create a new detector state.","ref":"macula_membership_detector.html#new/2"},{"type":"function","title":"macula_membership_detector.protocol_period/1","doc":"Get protocol period.","ref":"macula_membership_detector.html#protocol_period/1"},{"type":"function","title":"macula_membership_detector.refute_suspicion/1","doc":"Refute suspicion (increment local incarnation).","ref":"macula_membership_detector.html#refute_suspicion/1"},{"type":"function","title":"macula_membership_detector.select_probe_target/1","doc":"Select a random member to probe (excluding self).","ref":"macula_membership_detector.html#select_probe_target/1"},{"type":"module","title":"macula_membership_gossip","doc":"Gossip dissemination for SWIM protocol. Tracks membership updates and provides them for piggybacking. Uses exponential decay: log(N) messages per update.","ref":"macula_membership_gossip.html"},{"type":"function","title":"macula_membership_gossip.add_update/4","doc":"Add a membership update to gossip. If a more recent update exists, it's replaced.","ref":"macula_membership_gossip.html#add_update/4"},{"type":"function","title":"macula_membership_gossip.get_updates/2","doc":"Get updates to piggyback on messages. Returns most recent updates first, limited by max_updates.","ref":"macula_membership_gossip.html#get_updates/2"},{"type":"type","title":"macula_membership_gossip.gossip_state/0","doc":"","ref":"macula_membership_gossip.html#t:gossip_state/0"},{"type":"function","title":"macula_membership_gossip.mark_transmitted/2","doc":"Mark an update as transmitted (increment transmit count).","ref":"macula_membership_gossip.html#mark_transmitted/2"},{"type":"function","title":"macula_membership_gossip.merge_updates/2","doc":"Merge received gossip updates into local state. Uses SWIM merge semantics (higher incarnation wins, etc.).","ref":"macula_membership_gossip.html#merge_updates/2"},{"type":"function","title":"macula_membership_gossip.new/0","doc":"Create a new gossip state.","ref":"macula_membership_gossip.html#new/0"},{"type":"function","title":"macula_membership_gossip.prune/2","doc":"Prune updates that have been transmitted enough times. Target is typically log(N) where N is cluster size.","ref":"macula_membership_gossip.html#prune/2"},{"type":"type","title":"macula_membership_gossip.update/0","doc":"","ref":"macula_membership_gossip.html#t:update/0"},{"type":"module","title":"macula_membership_list","doc":"Membership list for SWIM protocol. Maintains cluster membership view with fast concurrent access. Uses map-based storage (could be ETS in production).","ref":"macula_membership_list.html"},{"type":"function","title":"macula_membership_list.add_member/2","doc":"Add a new member to the list. If member already exists, this is a no-op (use update_member instead).","ref":"macula_membership_list.html#add_member/2"},{"type":"function","title":"macula_membership_list.get_alive_members/1","doc":"Get all alive members.","ref":"macula_membership_list.html#get_alive_members/1"},{"type":"function","title":"macula_membership_list.get_all_members/1","doc":"Get all members.","ref":"macula_membership_list.html#get_all_members/1"},{"type":"function","title":"macula_membership_list.get_member/2","doc":"Get a member by node ID.","ref":"macula_membership_list.html#get_member/2"},{"type":"function","title":"macula_membership_list.get_random_members/2","doc":"Get N random members from the list.","ref":"macula_membership_list.html#get_random_members/2"},{"type":"function","title":"macula_membership_list.get_random_members/3","doc":"Get N random members excluding specified node ID.","ref":"macula_membership_list.html#get_random_members/3"},{"type":"function","title":"macula_membership_list.get_suspect_members/1","doc":"Get all suspect members.","ref":"macula_membership_list.html#get_suspect_members/1"},{"type":"type","title":"macula_membership_list.member_list/0","doc":"","ref":"macula_membership_list.html#t:member_list/0"},{"type":"function","title":"macula_membership_list.new/1","doc":"Create a new membership list with the local node.","ref":"macula_membership_list.html#new/1"},{"type":"function","title":"macula_membership_list.remove_member/2","doc":"Remove a member from the list.","ref":"macula_membership_list.html#remove_member/2"},{"type":"function","title":"macula_membership_list.size/1","doc":"Get the number of members in the list.","ref":"macula_membership_list.html#size/1"},{"type":"function","title":"macula_membership_list.update_member/2","doc":"Update an existing member (or add if not present). Uses merge semantics to resolve conflicts.","ref":"macula_membership_list.html#update_member/2"},{"type":"module","title":"macula_membership_member","doc":"Member record and state transitions for SWIM protocol. Represents a single node in the membership list.","ref":"macula_membership_member.html"},{"type":"function","title":"macula_membership_member.address/1","doc":"Get address.","ref":"macula_membership_member.html#address/1"},{"type":"function","title":"macula_membership_member.compare/2","doc":"Compare two members to determine which is more recent. Returns: gt (M1 is newer), lt (M1 is older), eq (same)","ref":"macula_membership_member.html#compare/2"},{"type":"function","title":"macula_membership_member.incarnation/1","doc":"Get incarnation number.","ref":"macula_membership_member.html#incarnation/1"},{"type":"function","title":"macula_membership_member.mark_alive/2","doc":"Mark member as alive with new incarnation (refutation). Dead members cannot be revived.","ref":"macula_membership_member.html#mark_alive/2"},{"type":"function","title":"macula_membership_member.mark_dead/1","doc":"Mark member as dead (confirmed failure).","ref":"macula_membership_member.html#mark_dead/1"},{"type":"function","title":"macula_membership_member.mark_suspect/1","doc":"Mark member as suspect (failed to respond to ping).","ref":"macula_membership_member.html#mark_suspect/1"},{"type":"type","title":"macula_membership_member.member/0","doc":"","ref":"macula_membership_member.html#t:member/0"},{"type":"function","title":"macula_membership_member.merge/2","doc":"Merge two member states, keeping the most recent information. Rules: 1. Dead always wins 2. Higher incarnation wins 3. Same incarnation: suspect > alive","ref":"macula_membership_member.html#merge/2"},{"type":"function","title":"macula_membership_member.metadata/1","doc":"Get metadata.","ref":"macula_membership_member.html#metadata/1"},{"type":"function","title":"macula_membership_member.new/2","doc":"Create a new member with alive status and incarnation 0.","ref":"macula_membership_member.html#new/2"},{"type":"function","title":"macula_membership_member.new/3","doc":"Create a new member with custom metadata.","ref":"macula_membership_member.html#new/3"},{"type":"function","title":"macula_membership_member.node_id/1","doc":"Get node ID.","ref":"macula_membership_member.html#node_id/1"},{"type":"type","title":"macula_membership_member.status/0","doc":"","ref":"macula_membership_member.html#t:status/0"},{"type":"function","title":"macula_membership_member.status/1","doc":"Get status.","ref":"macula_membership_member.html#status/1"},{"type":"module","title":"macula_names","doc":"Shared naming utilities for hierarchical dot-separated names. Used by both pub/sub topics and RPC procedure names. Supports DNS-style reverse notation: org.domain.service.method","ref":"macula_names.html"},{"type":"type","title":"macula_names.name/0","doc":"","ref":"macula_names.html#t:name/0"},{"type":"function","title":"macula_names.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_names.html#namespace/1"},{"type":"function","title":"macula_names.normalize/1","doc":"Normalize name (lowercase, trim, remove double dots).","ref":"macula_names.html#normalize/1"},{"type":"type","title":"macula_names.options/0","doc":"","ref":"macula_names.html#t:options/0"},{"type":"function","title":"macula_names.segment_count/1","doc":"Count number of segments in name.","ref":"macula_names.html#segment_count/1"},{"type":"function","title":"macula_names.validate/1","doc":"Validate name syntax with default options (no wildcards).","ref":"macula_names.html#validate/1"},{"type":"function","title":"macula_names.validate/2","doc":"Validate name syntax with options. Valid names: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen - Optionally allow wildcards (* and #) for patterns - No leading or trailing dots - No double dots","ref":"macula_names.html#validate/2"},{"type":"module","title":"macula_node","doc":"Node identity and metadata management. Represents a single node in the Macula mesh.","ref":"macula_node.html"},{"type":"type","title":"macula_node.address/0","doc":"","ref":"macula_node.html#t:address/0"},{"type":"function","title":"macula_node.equals/2","doc":"Check if two nodes are equal (by ID).","ref":"macula_node.html#equals/2"},{"type":"function","title":"macula_node.from_binary/1","doc":"Decode node from binary. Crashes on invalid binary or structure - exposes bugs in encoding/decoding logic.","ref":"macula_node.html#from_binary/1"},{"type":"function","title":"macula_node.get_address/1","doc":"Get address.","ref":"macula_node.html#get_address/1"},{"type":"function","title":"macula_node.get_id/1","doc":"Get node ID.","ref":"macula_node.html#get_id/1"},{"type":"function","title":"macula_node.get_metadata/1","doc":"Get metadata.","ref":"macula_node.html#get_metadata/1"},{"type":"function","title":"macula_node.get_realm/1","doc":"Get realm.","ref":"macula_node.html#get_realm/1"},{"type":"type","title":"macula_node.macula_node/0","doc":"","ref":"macula_node.html#t:macula_node/0"},{"type":"type","title":"macula_node.metadata/0","doc":"","ref":"macula_node.html#t:metadata/0"},{"type":"function","title":"macula_node.new/1","doc":"Create new node with random ID.","ref":"macula_node.html#new/1"},{"type":"function","title":"macula_node.new/2","doc":"Create new node with random ID and metadata.","ref":"macula_node.html#new/2"},{"type":"type","title":"macula_node.node_id/0","doc":"32-byte unique identifier","ref":"macula_node.html#t:node_id/0"},{"type":"type","title":"macula_node.realm/0","doc":"","ref":"macula_node.html#t:realm/0"},{"type":"function","title":"macula_node.set_address/2","doc":"Set address.","ref":"macula_node.html#set_address/2"},{"type":"function","title":"macula_node.set_metadata/2","doc":"Set metadata (replaces existing).","ref":"macula_node.html#set_metadata/2"},{"type":"function","title":"macula_node.to_binary/1","doc":"Encode node to binary.","ref":"macula_node.html#to_binary/1"},{"type":"function","title":"macula_node.update_metadata/2","doc":"Update metadata (merges with existing).","ref":"macula_node.html#update_metadata/2"},{"type":"module","title":"macula_peer","doc":"Macula Peer - Mesh Participant API (v0.7.0+). This module provides the high-level API for mesh participants. It acts as a facade/coordinator, delegating to specialized child processes: - macula_connection: QUIC transport layer (send/receive, encoding/decoding) - macula_pubsub_handler: Pub/sub message routing - macula_rpc_handler: RPC call/response handling - macula_advertisement_manager: DHT service advertisements Renamed from macula_connection in v0.7.0 for clarity: - macula_peer = mesh participant (this module) - macula_connection = QUIC transport (low-level)","ref":"macula_peer.html"},{"type":"function","title":"macula_peer.advertise/4","doc":"Advertise a service handler for a procedure. This makes the local handler available to other mesh nodes via DHT. The handler will be periodically re-advertised based on TTL.","ref":"macula_peer.html#advertise/4"},{"type":"function","title":"macula_peer.call/3","doc":"Make an RPC call through this client (default timeout).","ref":"macula_peer.html#call/3"},{"type":"function","title":"macula_peer.call/4","doc":"Make an RPC call through this client with options.","ref":"macula_peer.html#call/4"},{"type":"function","title":"macula_peer.publish/3","doc":"Publish an event through this client (no options).","ref":"macula_peer.html#publish/3"},{"type":"function","title":"macula_peer.publish/4","doc":"Publish an event through this client with options.","ref":"macula_peer.html#publish/4"},{"type":"function","title":"macula_peer.start_link/2","doc":"Start a client connection to a Macula mesh.","ref":"macula_peer.html#start_link/2"},{"type":"function","title":"macula_peer.stop/1","doc":"Stop the client connection.","ref":"macula_peer.html#stop/1"},{"type":"function","title":"macula_peer.subscribe/3","doc":"Subscribe to a topic through this client.","ref":"macula_peer.html#subscribe/3"},{"type":"function","title":"macula_peer.unadvertise/2","doc":"Stop advertising a service. Removes the local handler and stops advertising to the DHT.","ref":"macula_peer.html#unadvertise/2"},{"type":"function","title":"macula_peer.unsubscribe/2","doc":"Unsubscribe from a topic.","ref":"macula_peer.html#unsubscribe/2"},{"type":"module","title":"macula_protocol_decoder","doc":"Protocol message decoder for Macula mesh. Decodes binary wire format to message maps.","ref":"macula_protocol_decoder.html"},{"type":"function","title":"macula_protocol_decoder.decode/1","doc":"Decode a binary message to {Type, Msg} tuple. Returns {ok, {Type, Msg}} on success or {error, Reason} on failure.","ref":"macula_protocol_decoder.html#decode/1"},{"type":"module","title":"macula_protocol_encoder","doc":"Protocol message encoder for Macula mesh. Encodes message maps to binary wire format. Frame Format (8-byte header + payload): - Version (1 byte): Protocol version (currently 0x01) - Type (1 byte): Message type ID - Flags (1 byte): Reserved for future use (0x00) - Reserved (1 byte): Must be 0x00 - Payload Length (4 bytes): Big-endian uint32 - Payload (N bytes): MessagePack-encoded message data","ref":"macula_protocol_encoder.html"},{"type":"function","title":"macula_protocol_encoder.encode/2","doc":"Encode a message to binary format. Returns a binary with 8-byte header + MessagePack payload.","ref":"macula_protocol_encoder.html#encode/2"},{"type":"module","title":"macula_protocol_types","doc":"Protocol message type definitions and constants for Macula mesh. Defines all message types that can be sent over QUIC streams.","ref":"macula_protocol_types.html"},{"type":"type","title":"macula_protocol_types.call_msg/0","doc":"","ref":"macula_protocol_types.html#t:call_msg/0"},{"type":"type","title":"macula_protocol_types.cast_msg/0","doc":"","ref":"macula_protocol_types.html#t:cast_msg/0"},{"type":"type","title":"macula_protocol_types.connect_msg/0","doc":"","ref":"macula_protocol_types.html#t:connect_msg/0"},{"type":"type","title":"macula_protocol_types.disconnect_msg/0","doc":"","ref":"macula_protocol_types.html#t:disconnect_msg/0"},{"type":"type","title":"macula_protocol_types.message/0","doc":"","ref":"macula_protocol_types.html#t:message/0"},{"type":"type","title":"macula_protocol_types.message_type/0","doc":"","ref":"macula_protocol_types.html#t:message_type/0"},{"type":"function","title":"macula_protocol_types.message_type_id/1","doc":"Get numeric ID for a message type.","ref":"macula_protocol_types.html#message_type_id/1"},{"type":"function","title":"macula_protocol_types.message_type_name/1","doc":"Get message type name from numeric ID.","ref":"macula_protocol_types.html#message_type_name/1"},{"type":"type","title":"macula_protocol_types.ping_msg/0","doc":"","ref":"macula_protocol_types.html#t:ping_msg/0"},{"type":"type","title":"macula_protocol_types.pong_msg/0","doc":"","ref":"macula_protocol_types.html#t:pong_msg/0"},{"type":"type","title":"macula_protocol_types.publish_msg/0","doc":"","ref":"macula_protocol_types.html#t:publish_msg/0"},{"type":"type","title":"macula_protocol_types.reply_msg/0","doc":"","ref":"macula_protocol_types.html#t:reply_msg/0"},{"type":"type","title":"macula_protocol_types.rpc_route_msg/0","doc":"","ref":"macula_protocol_types.html#t:rpc_route_msg/0"},{"type":"type","title":"macula_protocol_types.subscribe_msg/0","doc":"","ref":"macula_protocol_types.html#t:subscribe_msg/0"},{"type":"type","title":"macula_protocol_types.unsubscribe_msg/0","doc":"","ref":"macula_protocol_types.html#t:unsubscribe_msg/0"},{"type":"module","title":"macula_provider_selector","doc":"Provider selection strategies for multi-provider RPC load balancing. Supports multiple strategies for choosing which provider to use when multiple providers advertise the same service. Strategies: - round_robin: Distribute calls evenly across providers - random: Random provider selection - first: Always use first provider (default/simple)","ref":"macula_provider_selector.html"},{"type":"type","title":"macula_provider_selector.provider_info/0","doc":"Provider information returned from DHT.","ref":"macula_provider_selector.html#t:provider_info/0"},{"type":"function","title":"macula_provider_selector.select_provider/2","doc":"Select a provider from a list using the default strategy (random). Returns the selected provider or error if list is empty.","ref":"macula_provider_selector.html#select_provider/2"},{"type":"function","title":"macula_provider_selector.select_provider/3","doc":"Select a provider from a list using a specific strategy. Strategies: - first: Always select the first provider (simple, no state) - random: Randomly select a provider - round_robin: Distribute calls evenly using a counter Examples: <span class=\"w\">  </span><span class=\"c1\">%% Random selection</span><span class=\"w\">\n  </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">new_state</span><span class=\"p\" data-group-id=\"3632151836-1\">(</span><span class=\"ss\">random</span><span class=\"p\" data-group-id=\"3632151836-1\">)</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"3632151836-2\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Provider</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"p\" data-group-id=\"3632151836-2\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">select_provider</span><span class=\"p\" data-group-id=\"3632151836-3\">(</span><span class=\"n\">Providers</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">random</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"p\" data-group-id=\"3632151836-3\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Round-robin selection</span><span class=\"w\">\n  </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">new_state</span><span class=\"p\" data-group-id=\"3632151836-4\">(</span><span class=\"ss\">round_robin</span><span class=\"p\" data-group-id=\"3632151836-4\">)</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"3632151836-5\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"p\" data-group-id=\"3632151836-5\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">select_provider</span><span class=\"p\" data-group-id=\"3632151836-6\">(</span><span class=\"n\">Providers</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">round_robin</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"p\" data-group-id=\"3632151836-6\">)</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"3632151836-7\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State3</span><span class=\"p\" data-group-id=\"3632151836-7\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">select_provider</span><span class=\"p\" data-group-id=\"3632151836-8\">(</span><span class=\"n\">Providers</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">round_robin</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"p\" data-group-id=\"3632151836-8\">)</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"c1\">%% P1 and P2 will be different providers (if multiple available)</span>","ref":"macula_provider_selector.html#select_provider/3"},{"type":"type","title":"macula_provider_selector.selection_state/0","doc":"","ref":"macula_provider_selector.html#t:selection_state/0"},{"type":"type","title":"macula_provider_selector.strategy/0","doc":"Selection strategy for choosing a provider from multiple options.","ref":"macula_provider_selector.html#t:strategy/0"},{"type":"module","title":"macula_pubsub_cache","doc":"LRU cache for remote subscriber lists. Caches DHT query results to avoid repeated lookups. Wraps macula_cache with subscriber-specific logic.","ref":"macula_pubsub_cache.html"},{"type":"type","title":"macula_pubsub_cache.cache/0","doc":"","ref":"macula_pubsub_cache.html#t:cache/0"},{"type":"function","title":"macula_pubsub_cache.clear/1","doc":"Clear all entries.","ref":"macula_pubsub_cache.html#clear/1"},{"type":"function","title":"macula_pubsub_cache.get/2","doc":"Get entry from cache. Returns {ok, Subscribers, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU).","ref":"macula_pubsub_cache.html#get/2"},{"type":"function","title":"macula_pubsub_cache.invalidate/2","doc":"Invalidate (remove) entry.","ref":"macula_pubsub_cache.html#invalidate/2"},{"type":"function","title":"macula_pubsub_cache.is_expired/3","doc":"Check if entry is expired based on TTL. This checks if entry exists and its age exceeds TTL.","ref":"macula_pubsub_cache.html#is_expired/3"},{"type":"function","title":"macula_pubsub_cache.max_size/1","doc":"Get max size.","ref":"macula_pubsub_cache.html#max_size/1"},{"type":"function","title":"macula_pubsub_cache.new/1","doc":"Create new cache with max size.","ref":"macula_pubsub_cache.html#new/1"},{"type":"function","title":"macula_pubsub_cache.put/3","doc":"Put entry in cache.","ref":"macula_pubsub_cache.html#put/3"},{"type":"function","title":"macula_pubsub_cache.put_with_timestamp/4","doc":"Put entry with custom timestamp (for testing).","ref":"macula_pubsub_cache.html#put_with_timestamp/4"},{"type":"function","title":"macula_pubsub_cache.size/1","doc":"Get number of entries.","ref":"macula_pubsub_cache.html#size/1"},{"type":"module","title":"macula_pubsub_delivery","doc":"Message routing and delivery to local and remote subscribers. Combines local registry and remote discovery for full fan-out.","ref":"macula_pubsub_delivery.html"},{"type":"function","title":"macula_pubsub_delivery.deliver_local/2","doc":"Deliver message to all matching local subscribers. Crashes if subscriber callback fails - indicates dead subscriber process.","ref":"macula_pubsub_delivery.html#deliver_local/2"},{"type":"function","title":"macula_pubsub_delivery.deliver_remote/3","doc":"Deliver message to remote subscribers via QUIC.","ref":"macula_pubsub_delivery.html#deliver_remote/3"},{"type":"type","title":"macula_pubsub_delivery.delivery_result/0","doc":"","ref":"macula_pubsub_delivery.html#t:delivery_result/0"},{"type":"type","title":"macula_pubsub_delivery.discovery_fun/0","doc":"","ref":"macula_pubsub_delivery.html#t:discovery_fun/0"},{"type":"function","title":"macula_pubsub_delivery.get_matching_patterns/2","doc":"Get all unique patterns that match the topic. Used for remote subscriber discovery.","ref":"macula_pubsub_delivery.html#get_matching_patterns/2"},{"type":"type","title":"macula_pubsub_delivery.message/0","doc":"","ref":"macula_pubsub_delivery.html#t:message/0"},{"type":"function","title":"macula_pubsub_delivery.publish/4","doc":"Publish message to both local and remote subscribers. Returns {LocalResults, RemoteResults}.","ref":"macula_pubsub_delivery.html#publish/4"},{"type":"type","title":"macula_pubsub_delivery.send_fun/0","doc":"","ref":"macula_pubsub_delivery.html#t:send_fun/0"},{"type":"module","title":"macula_pubsub_dht","doc":"DHT operations for pub/sub - handles subscription advertisement and discovery. Responsibilities: - Advertise subscriptions in DHT with TTL - Schedule re-advertisement timers - Discover remote subscribers via DHT queries - Route messages to remote subscribers - Track pending DHT queries Extracted from macula_pubsub_handler.erl (Phase 3)","ref":"macula_pubsub_dht.html"},{"type":"function","title":"macula_pubsub_dht.advertise_subscription/5","doc":"Advertise a subscription in the DHT. Sends STORE message to DHT and schedules re-advertisement. Returns {ok, SubInfo}.","ref":"macula_pubsub_dht.html#advertise_subscription/5"},{"type":"type","title":"macula_pubsub_dht.advertised_subscriptions/0","doc":"","ref":"macula_pubsub_dht.html#t:advertised_subscriptions/0"},{"type":"function","title":"macula_pubsub_dht.cancel_advertisement/2","doc":"Cancel advertisement for a topic. Cancels the re-advertisement timer. Returns updated advertised_subscriptions map.","ref":"macula_pubsub_dht.html#cancel_advertisement/2"},{"type":"type","title":"macula_pubsub_dht.connection_manager_pid/0","doc":"","ref":"macula_pubsub_dht.html#t:connection_manager_pid/0"},{"type":"function","title":"macula_pubsub_dht.discover_subscribers/6","doc":"Discover remote subscribers for a topic. Checks cache first, queries DHT on cache miss. Returns {cached, Subscribers, Registry} | {query_sent, Pending, MsgId, Registry}.","ref":"macula_pubsub_dht.html#discover_subscribers/6"},{"type":"function","title":"macula_pubsub_dht.handle_discovery_response/3","doc":"Handle DHT discovery response. Routes messages to discovered subscribers. Returns updated pending queries map.","ref":"macula_pubsub_dht.html#handle_discovery_response/3"},{"type":"type","title":"macula_pubsub_dht.node_id/0","doc":"","ref":"macula_pubsub_dht.html#t:node_id/0"},{"type":"type","title":"macula_pubsub_dht.payload/0","doc":"","ref":"macula_pubsub_dht.html#t:payload/0"},{"type":"type","title":"macula_pubsub_dht.pending_queries/0","doc":"","ref":"macula_pubsub_dht.html#t:pending_queries/0"},{"type":"type","title":"macula_pubsub_dht.qos/0","doc":"","ref":"macula_pubsub_dht.html#t:qos/0"},{"type":"function","title":"macula_pubsub_dht.route_to_subscribers/5","doc":"Route message to remote subscribers. Sends publish message to each subscriber endpoint.","ref":"macula_pubsub_dht.html#route_to_subscribers/5"},{"type":"type","title":"macula_pubsub_dht.subscription_ref/0","doc":"","ref":"macula_pubsub_dht.html#t:subscription_ref/0"},{"type":"type","title":"macula_pubsub_dht.topic/0","doc":"","ref":"macula_pubsub_dht.html#t:topic/0"},{"type":"type","title":"macula_pubsub_dht.url/0","doc":"","ref":"macula_pubsub_dht.html#t:url/0"},{"type":"module","title":"macula_pubsub_discovery","doc":"DHT integration for finding remote subscribers. Uses Kademlia DHT to publish and discover subscriptions. Wraps macula_discovery with pub/sub-specific types.","ref":"macula_pubsub_discovery.html"},{"type":"type","title":"macula_pubsub_discovery.address/0","doc":"","ref":"macula_pubsub_discovery.html#t:address/0"},{"type":"function","title":"macula_pubsub_discovery.announce/4","doc":"Announce local subscription to DHT.","ref":"macula_pubsub_discovery.html#announce/4"},{"type":"type","title":"macula_pubsub_discovery.dht_lookup_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_lookup_fun/0"},{"type":"type","title":"macula_pubsub_discovery.dht_publish_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_publish_fun/0"},{"type":"type","title":"macula_pubsub_discovery.dht_unpublish_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_unpublish_fun/0"},{"type":"function","title":"macula_pubsub_discovery.find_subscribers/2","doc":"Find remote subscribers for a pattern via DHT.","ref":"macula_pubsub_discovery.html#find_subscribers/2"},{"type":"function","title":"macula_pubsub_discovery.find_with_cache/3","doc":"Find subscribers with cache (default TTL: 300 seconds).","ref":"macula_pubsub_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_pubsub_discovery.find_with_cache/4","doc":"Find subscribers with cache and custom TTL.","ref":"macula_pubsub_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_pubsub_discovery.node_id/0","doc":"","ref":"macula_pubsub_discovery.html#t:node_id/0"},{"type":"type","title":"macula_pubsub_discovery.pattern/0","doc":"","ref":"macula_pubsub_discovery.html#t:pattern/0"},{"type":"type","title":"macula_pubsub_discovery.subscriber/0","doc":"","ref":"macula_pubsub_discovery.html#t:subscriber/0"},{"type":"function","title":"macula_pubsub_discovery.unannounce/3","doc":"Remove local subscription from DHT.","ref":"macula_pubsub_discovery.html#unannounce/3"},{"type":"module","title":"macula_pubsub_handler","doc":"PubSub handler GenServer - facade that orchestrates pub/sub operations. This module acts as a facade/coordinator, delegating business logic to: - macula_pubsub_subscription: Subscription storage, pattern matching, callbacks - macula_pubsub_dht: DHT advertisement, discovery, routing - macula_pubsub_qos: QoS 1 tracking and retry logic Responsibilities: - API facade for subscribe/unsubscribe/publish operations - Message routing coordination between specialized modules - GenServer lifecycle management - State management (delegates actual operations to modules) Extracted from macula_connection.erl (Phase 4) Refactored using TDD to extract god module (Phase 5)","ref":"macula_pubsub_handler.html"},{"type":"function","title":"macula_pubsub_handler.handle_call/3","doc":"","ref":"macula_pubsub_handler.html#handle_call/3"},{"type":"function","title":"macula_pubsub_handler.handle_cast/2","doc":"","ref":"macula_pubsub_handler.html#handle_cast/2"},{"type":"function","title":"macula_pubsub_handler.handle_incoming_publish/2","doc":"","ref":"macula_pubsub_handler.html#handle_incoming_publish/2"},{"type":"function","title":"macula_pubsub_handler.handle_info/2","doc":"","ref":"macula_pubsub_handler.html#handle_info/2"},{"type":"function","title":"macula_pubsub_handler.init/1","doc":"","ref":"macula_pubsub_handler.html#init/1"},{"type":"function","title":"macula_pubsub_handler.publish/4","doc":"","ref":"macula_pubsub_handler.html#publish/4"},{"type":"function","title":"macula_pubsub_handler.start_link/1","doc":"","ref":"macula_pubsub_handler.html#start_link/1"},{"type":"function","title":"macula_pubsub_handler.subscribe/3","doc":"","ref":"macula_pubsub_handler.html#subscribe/3"},{"type":"function","title":"macula_pubsub_handler.terminate/2","doc":"","ref":"macula_pubsub_handler.html#terminate/2"},{"type":"function","title":"macula_pubsub_handler.unsubscribe/2","doc":"","ref":"macula_pubsub_handler.html#unsubscribe/2"},{"type":"module","title":"macula_pubsub_qos","doc":"QoS (Quality of Service) manager for pub/sub. Handles QoS 1 (at-least-once delivery) logic: - Message tracking with timeout timers - Automatic retry on timeout (up to max retries) - Acknowledgment handling Extracted from macula_pubsub_handler.erl (Phase 2)","ref":"macula_pubsub_qos.html"},{"type":"type","title":"macula_pubsub_qos.connection_manager_pid/0","doc":"","ref":"macula_pubsub_qos.html#t:connection_manager_pid/0"},{"type":"function","title":"macula_pubsub_qos.get_pending/1","doc":"Get list of pending message IDs (for testing/debugging).","ref":"macula_pubsub_qos.html#get_pending/1"},{"type":"function","title":"macula_pubsub_qos.handle_ack/2","doc":"Handle acknowledgment for a message. Cancels timer and removes message from pending map. Returns updated pending_pubacks map.","ref":"macula_pubsub_qos.html#handle_ack/2"},{"type":"function","title":"macula_pubsub_qos.handle_timeout/3","doc":"Handle timeout for a pending message. Retries sending if under max retries, otherwise gives up. Returns {retry, UpdatedPending, PublishMsg} | {give_up, UpdatedPending}.","ref":"macula_pubsub_qos.html#handle_timeout/3"},{"type":"type","title":"macula_pubsub_qos.message_id/0","doc":"","ref":"macula_pubsub_qos.html#t:message_id/0"},{"type":"type","title":"macula_pubsub_qos.payload/0","doc":"","ref":"macula_pubsub_qos.html#t:payload/0"},{"type":"type","title":"macula_pubsub_qos.pending_pubacks/0","doc":"","ref":"macula_pubsub_qos.html#t:pending_pubacks/0"},{"type":"type","title":"macula_pubsub_qos.qos/0","doc":"","ref":"macula_pubsub_qos.html#t:qos/0"},{"type":"type","title":"macula_pubsub_qos.retry_count/0","doc":"","ref":"macula_pubsub_qos.html#t:retry_count/0"},{"type":"type","title":"macula_pubsub_qos.timer_ref/0","doc":"","ref":"macula_pubsub_qos.html#t:timer_ref/0"},{"type":"type","title":"macula_pubsub_qos.topic/0","doc":"","ref":"macula_pubsub_qos.html#t:topic/0"},{"type":"function","title":"macula_pubsub_qos.track_message/5","doc":"Track a message for QoS 1 acknowledgment. Starts a timeout timer and stores message in pending map. Returns updated pending_pubacks map.","ref":"macula_pubsub_qos.html#track_message/5"},{"type":"module","title":"macula_pubsub_registry","doc":"Local subscription registry for pub/sub. Maps topic patterns to local subscribers (callback PIDs).","ref":"macula_pubsub_registry.html"},{"type":"function","title":"macula_pubsub_registry.get_subscription/3","doc":"Get specific subscription.","ref":"macula_pubsub_registry.html#get_subscription/3"},{"type":"function","title":"macula_pubsub_registry.list_patterns/1","doc":"List all unique patterns.","ref":"macula_pubsub_registry.html#list_patterns/1"},{"type":"function","title":"macula_pubsub_registry.match/2","doc":"Find subscriptions matching a topic.","ref":"macula_pubsub_registry.html#match/2"},{"type":"function","title":"macula_pubsub_registry.new/0","doc":"Create new empty registry.","ref":"macula_pubsub_registry.html#new/0"},{"type":"type","title":"macula_pubsub_registry.registry/0","doc":"","ref":"macula_pubsub_registry.html#t:registry/0"},{"type":"function","title":"macula_pubsub_registry.size/1","doc":"Get number of subscriptions.","ref":"macula_pubsub_registry.html#size/1"},{"type":"function","title":"macula_pubsub_registry.subscribe/4","doc":"Subscribe to a pattern. If subscription already exists (same subscriber_id + pattern), updates callback.","ref":"macula_pubsub_registry.html#subscribe/4"},{"type":"type","title":"macula_pubsub_registry.subscription/0","doc":"","ref":"macula_pubsub_registry.html#t:subscription/0"},{"type":"function","title":"macula_pubsub_registry.unsubscribe/3","doc":"Unsubscribe from a pattern.","ref":"macula_pubsub_registry.html#unsubscribe/3"},{"type":"module","title":"macula_pubsub_server","doc":"Pub/Sub GenServer - manages subscriptions and message delivery. Ties together registry, cache, discovery, and delivery layers.","ref":"macula_pubsub_server.html"},{"type":"function","title":"macula_pubsub_server.cache_stats/1","doc":"Get cache statistics.","ref":"macula_pubsub_server.html#cache_stats/1"},{"type":"function","title":"macula_pubsub_server.list_patterns/1","doc":"List all unique patterns.","ref":"macula_pubsub_server.html#list_patterns/1"},{"type":"function","title":"macula_pubsub_server.list_subscriptions/1","doc":"List all subscriptions.","ref":"macula_pubsub_server.html#list_subscriptions/1"},{"type":"type","title":"macula_pubsub_server.options/0","doc":"","ref":"macula_pubsub_server.html#t:options/0"},{"type":"function","title":"macula_pubsub_server.publish/2","doc":"Publish message to all matching subscribers.","ref":"macula_pubsub_server.html#publish/2"},{"type":"function","title":"macula_pubsub_server.start_link/0","doc":"Start server with default options.","ref":"macula_pubsub_server.html#start_link/0"},{"type":"function","title":"macula_pubsub_server.start_link/1","doc":"Start server with options.","ref":"macula_pubsub_server.html#start_link/1"},{"type":"function","title":"macula_pubsub_server.stop/1","doc":"Stop server.","ref":"macula_pubsub_server.html#stop/1"},{"type":"function","title":"macula_pubsub_server.subscribe/4","doc":"Subscribe to a pattern.","ref":"macula_pubsub_server.html#subscribe/4"},{"type":"function","title":"macula_pubsub_server.subscription_count/1","doc":"Get subscription count.","ref":"macula_pubsub_server.html#subscription_count/1"},{"type":"function","title":"macula_pubsub_server.unsubscribe/3","doc":"Unsubscribe from a pattern.","ref":"macula_pubsub_server.html#unsubscribe/3"},{"type":"module","title":"macula_pubsub_subscription","doc":"Subscription management for pub/sub. Responsibilities: - Store and retrieve subscriptions - Pattern matching with wildcards (*, **) - Find matching subscriptions for a topic - Invoke subscriber callbacks Extracted from macula_pubsub_handler.erl (Phase 4)","ref":"macula_pubsub_subscription.html"},{"type":"function","title":"macula_pubsub_subscription.add_subscription/4","doc":"Add a subscription. Returns {ok, UpdatedSubscriptions, SubRef}.","ref":"macula_pubsub_subscription.html#add_subscription/4"},{"type":"type","title":"macula_pubsub_subscription.callback/0","doc":"","ref":"macula_pubsub_subscription.html#t:callback/0"},{"type":"function","title":"macula_pubsub_subscription.find_matches/3","doc":"Find matching subscriptions for a topic. Returns list of {SubRef, {Pattern, Callback}} tuples.","ref":"macula_pubsub_subscription.html#find_matches/3"},{"type":"function","title":"macula_pubsub_subscription.invoke_callbacks/4","doc":"Invoke callbacks for matching subscriptions. Spawns async tasks to invoke each callback.","ref":"macula_pubsub_subscription.html#invoke_callbacks/4"},{"type":"type","title":"macula_pubsub_subscription.node_id/0","doc":"","ref":"macula_pubsub_subscription.html#t:node_id/0"},{"type":"type","title":"macula_pubsub_subscription.payload/0","doc":"","ref":"macula_pubsub_subscription.html#t:payload/0"},{"type":"function","title":"macula_pubsub_subscription.remove_subscription/2","doc":"Remove a subscription. Returns {ok, UpdatedSubscriptions, Topic} | {error, not_found}.","ref":"macula_pubsub_subscription.html#remove_subscription/2"},{"type":"type","title":"macula_pubsub_subscription.subscription_ref/0","doc":"","ref":"macula_pubsub_subscription.html#t:subscription_ref/0"},{"type":"type","title":"macula_pubsub_subscription.subscriptions/0","doc":"","ref":"macula_pubsub_subscription.html#t:subscriptions/0"},{"type":"type","title":"macula_pubsub_subscription.topic/0","doc":"","ref":"macula_pubsub_subscription.html#t:topic/0"},{"type":"module","title":"macula_pubsub_topic","doc":"Topic utilities for pub/sub system. Handles topic validation, pattern matching, and normalization. Supports MQTT-style wildcards: * (single-level) and # (multi-level).","ref":"macula_pubsub_topic.html"},{"type":"function","title":"macula_pubsub_topic.matches/2","doc":"Check if topic matches pattern. Patterns can contain: - * matches exactly one segment - # matches zero or more segments","ref":"macula_pubsub_topic.html#matches/2"},{"type":"function","title":"macula_pubsub_topic.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_pubsub_topic.html#namespace/1"},{"type":"function","title":"macula_pubsub_topic.normalize/1","doc":"Normalize topic (lowercase, trim, remove double dots).","ref":"macula_pubsub_topic.html#normalize/1"},{"type":"type","title":"macula_pubsub_topic.pattern/0","doc":"","ref":"macula_pubsub_topic.html#t:pattern/0"},{"type":"function","title":"macula_pubsub_topic.segment_count/1","doc":"Count number of segments in topic.","ref":"macula_pubsub_topic.html#segment_count/1"},{"type":"type","title":"macula_pubsub_topic.topic/0","doc":"","ref":"macula_pubsub_topic.html#t:topic/0"},{"type":"function","title":"macula_pubsub_topic.validate/1","doc":"Validate topic syntax. Valid topics: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen, wildcards - No leading or trailing dots","ref":"macula_pubsub_topic.html#validate/1"},{"type":"module","title":"macula_quic","doc":"Main API module for Macula QUIC transport. Provides a simplified wrapper around the quicer library.","ref":"macula_quic.html"},{"type":"function","title":"macula_quic.accept/2","doc":"Accept an incoming connection on a listener. After accepting, the connection needs handshake to complete.","ref":"macula_quic.html#accept/2"},{"type":"function","title":"macula_quic.accept_stream/2","doc":"Accept an incoming stream on a connection.","ref":"macula_quic.html#accept_stream/2"},{"type":"function","title":"macula_quic.async_send/2","doc":"Send data on a stream asynchronously (non-blocking). This returns immediately without waiting for QUIC flow control.","ref":"macula_quic.html#async_send/2"},{"type":"function","title":"macula_quic.close/1","doc":"Close a listener, connection, or stream.","ref":"macula_quic.html#close/1"},{"type":"function","title":"macula_quic.connect/4","doc":"Connect to a QUIC server. Options: {alpn, [Protocol]} - List of ALPN protocols {verify, none | verify_peer} - Certificate verification mode","ref":"macula_quic.html#connect/4"},{"type":"function","title":"macula_quic.listen/2","doc":"Start a QUIC listener on the specified port. Options: {cert, CertFile} - Path to PEM certificate file {key, KeyFile} - Path to PEM private key file {alpn, [Protocol]} - List of ALPN protocols (e.g., [\"macula\"]) {peer_unidi_stream_count, N} - Max unidirectional streams {peer_bidi_stream_count, N} - Max bidirectional streams","ref":"macula_quic.html#listen/2"},{"type":"function","title":"macula_quic.open_stream/1","doc":"Open a new bidirectional stream on a connection.","ref":"macula_quic.html#open_stream/1"},{"type":"function","title":"macula_quic.recv/2","doc":"Receive data from a stream (blocking).","ref":"macula_quic.html#recv/2"},{"type":"function","title":"macula_quic.send/2","doc":"Send data on a stream (blocking).","ref":"macula_quic.html#send/2"},{"type":"module","title":"macula_quic_cert","doc":"Macula QUIC certificate utilities. Provides functions for generating and validating self-signed certificates for QUIC connections via OpenSSL command-line tool.","ref":"macula_quic_cert.html"},{"type":"function","title":"macula_quic_cert.generate_self_signed/0","doc":"Generate a self-signed certificate and key in a temporary directory. Returns {ok, CertFile, KeyFile} with paths to generated files. The files are created in /tmp/macula_certs_PID for test isolation.","ref":"macula_quic_cert.html#generate_self_signed/0"},{"type":"function","title":"macula_quic_cert.generate_self_signed/1","doc":"Generate a self-signed certificate and key in the given directory. Returns {ok, {CertFile, KeyFile}} with paths to generated files.","ref":"macula_quic_cert.html#generate_self_signed/1"},{"type":"function","title":"macula_quic_cert.generate_self_signed/2","doc":"Generate a self-signed certificate with custom options. Options: subject - Certificate subject (default: \"/CN=macula.local\") validity_days - Validity period in days (default: 365)","ref":"macula_quic_cert.html#generate_self_signed/2"},{"type":"function","title":"macula_quic_cert.validate_files/2","doc":"Validate that both certificate and key files exist and are readable.","ref":"macula_quic_cert.html#validate_files/2"},{"type":"module","title":"macula_quic_conn_callback","doc":"QUIC connection callback module for Macula. Implements quicer_connection behavior to handle connection lifecycle.","ref":"macula_quic_conn_callback.html"},{"type":"function","title":"macula_quic_conn_callback.closed/3","doc":"Handle connection closed","ref":"macula_quic_conn_callback.html#closed/3"},{"type":"function","title":"macula_quic_conn_callback.connected/3","doc":"Handle connection established","ref":"macula_quic_conn_callback.html#connected/3"},{"type":"function","title":"macula_quic_conn_callback.handle_info/2","doc":"Handle other messages","ref":"macula_quic_conn_callback.html#handle_info/2"},{"type":"function","title":"macula_quic_conn_callback.init/1","doc":"Initialize connection callback state","ref":"macula_quic_conn_callback.html#init/1"},{"type":"function","title":"macula_quic_conn_callback.local_address_changed/3","doc":"Handle local address changed","ref":"macula_quic_conn_callback.html#local_address_changed/3"},{"type":"function","title":"macula_quic_conn_callback.new_conn/3","doc":"Handle new connection With quicer_server, streams are delivered automatically via new_stream/3","ref":"macula_quic_conn_callback.html#new_conn/3"},{"type":"function","title":"macula_quic_conn_callback.new_stream/3","doc":"Handle new stream With quicer_server, ALL streams are delivered here (not just orphans) Forward them to the gateway for processing","ref":"macula_quic_conn_callback.html#new_stream/3"},{"type":"function","title":"macula_quic_conn_callback.nst_received/3","doc":"Handle NST received (not used for server)","ref":"macula_quic_conn_callback.html#nst_received/3"},{"type":"function","title":"macula_quic_conn_callback.peer_address_changed/3","doc":"Handle peer address changed","ref":"macula_quic_conn_callback.html#peer_address_changed/3"},{"type":"function","title":"macula_quic_conn_callback.peer_needs_streams/3","doc":"Handle peer needs streams","ref":"macula_quic_conn_callback.html#peer_needs_streams/3"},{"type":"function","title":"macula_quic_conn_callback.resumed/3","doc":"Handle connection resumed","ref":"macula_quic_conn_callback.html#resumed/3"},{"type":"function","title":"macula_quic_conn_callback.shutdown/3","doc":"Handle connection shutdown","ref":"macula_quic_conn_callback.html#shutdown/3"},{"type":"function","title":"macula_quic_conn_callback.streams_available/3","doc":"Handle streams available","ref":"macula_quic_conn_callback.html#streams_available/3"},{"type":"function","title":"macula_quic_conn_callback.transport_shutdown/3","doc":"Handle transport shutdown","ref":"macula_quic_conn_callback.html#transport_shutdown/3"},{"type":"module","title":"macula_quic_stream_acceptor","doc":"QUIC stream acceptor process. Dedicated process that waits for incoming streams on a connection and forwards them to the gateway for processing.","ref":"macula_quic_stream_acceptor.html"},{"type":"function","title":"macula_quic_stream_acceptor.handle_call/3","doc":"","ref":"macula_quic_stream_acceptor.html#handle_call/3"},{"type":"function","title":"macula_quic_stream_acceptor.handle_cast/2","doc":"","ref":"macula_quic_stream_acceptor.html#handle_cast/2"},{"type":"function","title":"macula_quic_stream_acceptor.handle_info/2","doc":"Handle new stream from peer - THIS IS THE KEY MESSAGE!","ref":"macula_quic_stream_acceptor.html#handle_info/2"},{"type":"function","title":"macula_quic_stream_acceptor.init/1","doc":"","ref":"macula_quic_stream_acceptor.html#init/1"},{"type":"function","title":"macula_quic_stream_acceptor.start_link/2","doc":"Start stream acceptor process","ref":"macula_quic_stream_acceptor.html#start_link/2"},{"type":"function","title":"macula_quic_stream_acceptor.terminate/2","doc":"","ref":"macula_quic_stream_acceptor.html#terminate/2"},{"type":"module","title":"macula_realm","doc":"Realm management and validation. Realms provide logical isolation boundaries in the mesh. Realm names follow reverse DNS notation (e.g., \"org.example.mesh\").","ref":"macula_realm.html"},{"type":"function","title":"macula_realm.equals/2","doc":"Check if two realm names are equal.","ref":"macula_realm.html#equals/2"},{"type":"function","title":"macula_realm.from_binary/1","doc":"Decode realm name from binary.","ref":"macula_realm.html#from_binary/1"},{"type":"function","title":"macula_realm.id/1","doc":"Generate deterministic realm ID from name. Uses SHA-256 hash for 256-bit realm IDs.","ref":"macula_realm.html#id/1"},{"type":"function","title":"macula_realm.namespace/1","doc":"Extract namespace (top-level domain) from realm name. Example: \"org.example.mesh\" -> \"org\"","ref":"macula_realm.html#namespace/1"},{"type":"function","title":"macula_realm.normalize/1","doc":"Normalize realm name (lowercase, trim).","ref":"macula_realm.html#normalize/1"},{"type":"type","title":"macula_realm.realm_id/0","doc":"32-byte SHA-256 hash","ref":"macula_realm.html#t:realm_id/0"},{"type":"type","title":"macula_realm.realm_name/0","doc":"","ref":"macula_realm.html#t:realm_name/0"},{"type":"function","title":"macula_realm.to_binary/1","doc":"Encode realm name to binary.","ref":"macula_realm.html#to_binary/1"},{"type":"function","title":"macula_realm.validate/1","doc":"Validate realm name format. Rules: - Reverse DNS notation (org.example.mesh) - Lowercase alphanumeric, dots, hyphens, underscores - No leading/trailing dots - No consecutive dots","ref":"macula_realm.html#validate/1"},{"type":"module","title":"macula_routing_bucket","doc":"K-bucket for Kademlia routing table. Stores up to k nodes with LRU eviction policy.","ref":"macula_routing_bucket.html"},{"type":"function","title":"macula_routing_bucket.add_node/2","doc":"Add a node to the bucket. If node exists, move to tail (most recent). If bucket full, return {error, bucket_full}.","ref":"macula_routing_bucket.html#add_node/2"},{"type":"type","title":"macula_routing_bucket.bucket/0","doc":"","ref":"macula_routing_bucket.html#t:bucket/0"},{"type":"function","title":"macula_routing_bucket.capacity/1","doc":"Get bucket capacity.","ref":"macula_routing_bucket.html#capacity/1"},{"type":"function","title":"macula_routing_bucket.find_closest/3","doc":"Find n closest nodes to target (sorted by XOR distance).","ref":"macula_routing_bucket.html#find_closest/3"},{"type":"function","title":"macula_routing_bucket.find_node/2","doc":"Find a node by ID.","ref":"macula_routing_bucket.html#find_node/2"},{"type":"function","title":"macula_routing_bucket.get_nodes/1","doc":"Get all nodes in the bucket (ordered: oldest first).","ref":"macula_routing_bucket.html#get_nodes/1"},{"type":"function","title":"macula_routing_bucket.has_node/2","doc":"Check if bucket contains node.","ref":"macula_routing_bucket.html#has_node/2"},{"type":"function","title":"macula_routing_bucket.new/1","doc":"Create a new bucket with capacity k.","ref":"macula_routing_bucket.html#new/1"},{"type":"type","title":"macula_routing_bucket.node_info/0","doc":"","ref":"macula_routing_bucket.html#t:node_info/0"},{"type":"function","title":"macula_routing_bucket.remove_node/2","doc":"Remove a node from the bucket.","ref":"macula_routing_bucket.html#remove_node/2"},{"type":"function","title":"macula_routing_bucket.size/1","doc":"Get number of nodes in bucket.","ref":"macula_routing_bucket.html#size/1"},{"type":"function","title":"macula_routing_bucket.update_timestamp/2","doc":"Update node's last_seen timestamp (moves to tail).","ref":"macula_routing_bucket.html#update_timestamp/2"},{"type":"module","title":"macula_routing_dht","doc":"Core DHT algorithms for Kademlia routing. Implements iterative lookup, store, and find operations. Pure functions - no GenServer, designed to be called by macula_routing_server.","ref":"macula_routing_dht.html"},{"type":"function","title":"macula_routing_dht.find_value/4","doc":"Find value in DHT. Returns {ok, Value} if found, {nodes, [NodeInfo]} if not found.","ref":"macula_routing_dht.html#find_value/4"},{"type":"function","title":"macula_routing_dht.iterative_find_node/4","doc":"Iterative lookup to find k closest nodes to target. Uses alpha concurrent queries (default: 3).","ref":"macula_routing_dht.html#iterative_find_node/4"},{"type":"type","title":"macula_routing_dht.query_fn/0","doc":"","ref":"macula_routing_dht.html#t:query_fn/0"},{"type":"function","title":"macula_routing_dht.select_alpha/3","doc":"Select up to alpha unqueried nodes from closest set.","ref":"macula_routing_dht.html#select_alpha/3"},{"type":"type","title":"macula_routing_dht.store_fn/0","doc":"","ref":"macula_routing_dht.html#t:store_fn/0"},{"type":"function","title":"macula_routing_dht.store_value/6","doc":"Store value at k closest nodes to key.","ref":"macula_routing_dht.html#store_value/6"},{"type":"function","title":"macula_routing_dht.update_closest/4","doc":"Update closest set with new nodes, maintaining k closest and removing duplicates.","ref":"macula_routing_dht.html#update_closest/4"},{"type":"module","title":"macula_routing_nodeid","doc":"Node ID utilities for Kademlia DHT. 256-bit node identifiers with XOR distance metric.","ref":"macula_routing_nodeid.html"},{"type":"function","title":"macula_routing_nodeid.bucket_index/2","doc":"Calculate bucket index for a node relative to local node. Returns leading zero count of XOR distance (0..255). Special case: distance 0 (same node) returns 256. Normalizes inputs to 32 bytes if needed.","ref":"macula_routing_nodeid.html#bucket_index/2"},{"type":"function","title":"macula_routing_nodeid.closer_to/3","doc":"Check if NodeA is closer to Target than NodeB. Normalizes inputs to 32 bytes if needed.","ref":"macula_routing_nodeid.html#closer_to/3"},{"type":"function","title":"macula_routing_nodeid.compare/3","doc":"Compare distances of NodeA and NodeB to Target. Returns: less (A closer), equal (same distance), greater (B closer). Normalizes inputs to 32 bytes if needed.","ref":"macula_routing_nodeid.html#compare/3"},{"type":"function","title":"macula_routing_nodeid.distance/2","doc":"Calculate XOR distance between two node IDs. Normalizes inputs to 32 bytes if needed.","ref":"macula_routing_nodeid.html#distance/2"},{"type":"function","title":"macula_routing_nodeid.from_binary/1","doc":"Create node ID from binary (validates size).","ref":"macula_routing_nodeid.html#from_binary/1"},{"type":"function","title":"macula_routing_nodeid.from_hex/1","doc":"Parse node ID from hex string. Crashes on invalid hex or wrong length - exposes bugs in validation logic.","ref":"macula_routing_nodeid.html#from_hex/1"},{"type":"function","title":"macula_routing_nodeid.generate/0","doc":"Generate a random 256-bit node ID.","ref":"macula_routing_nodeid.html#generate/0"},{"type":"function","title":"macula_routing_nodeid.leading_zeros/1","doc":"Count leading zero bits in binary.","ref":"macula_routing_nodeid.html#leading_zeros/1"},{"type":"type","title":"macula_routing_nodeid.node_id/0","doc":"32 bytes (256 bits)","ref":"macula_routing_nodeid.html#t:node_id/0"},{"type":"function","title":"macula_routing_nodeid.normalize/1","doc":"Normalize any binary to a 32-byte node ID. If already 32 bytes, returns as-is. Otherwise, hashes with SHA-256.","ref":"macula_routing_nodeid.html#normalize/1"},{"type":"function","title":"macula_routing_nodeid.to_hex/1","doc":"Convert node ID to hex string.","ref":"macula_routing_nodeid.html#to_hex/1"},{"type":"module","title":"macula_routing_protocol","doc":"DHT protocol message encoding/decoding. Maps DHT operations to/from message format.","ref":"macula_routing_protocol.html"},{"type":"function","title":"macula_routing_protocol.decode_find_node/1","doc":"Decode FIND_NODE request.","ref":"macula_routing_protocol.html#decode_find_node/1"},{"type":"function","title":"macula_routing_protocol.decode_find_node_reply/1","doc":"Decode FIND_NODE reply.","ref":"macula_routing_protocol.html#decode_find_node_reply/1"},{"type":"function","title":"macula_routing_protocol.decode_find_value/1","doc":"Decode FIND_VALUE request.","ref":"macula_routing_protocol.html#decode_find_value/1"},{"type":"function","title":"macula_routing_protocol.decode_find_value_reply/1","doc":"Decode FIND_VALUE reply.","ref":"macula_routing_protocol.html#decode_find_value_reply/1"},{"type":"function","title":"macula_routing_protocol.decode_node_info/1","doc":"Decode node info.","ref":"macula_routing_protocol.html#decode_node_info/1"},{"type":"function","title":"macula_routing_protocol.decode_store/1","doc":"Decode STORE request.","ref":"macula_routing_protocol.html#decode_store/1"},{"type":"function","title":"macula_routing_protocol.encode_find_node/1","doc":"Encode FIND_NODE request.","ref":"macula_routing_protocol.html#encode_find_node/1"},{"type":"function","title":"macula_routing_protocol.encode_find_node_reply/1","doc":"Encode FIND_NODE reply.","ref":"macula_routing_protocol.html#encode_find_node_reply/1"},{"type":"function","title":"macula_routing_protocol.encode_find_value/1","doc":"Encode FIND_VALUE request.","ref":"macula_routing_protocol.html#encode_find_value/1"},{"type":"function","title":"macula_routing_protocol.encode_find_value_reply/1","doc":"Encode FIND_VALUE reply.","ref":"macula_routing_protocol.html#encode_find_value_reply/1"},{"type":"function","title":"macula_routing_protocol.encode_node_info/1","doc":"Encode node info (for transmission).","ref":"macula_routing_protocol.html#encode_node_info/1"},{"type":"function","title":"macula_routing_protocol.encode_store/2","doc":"Encode STORE request.","ref":"macula_routing_protocol.html#encode_store/2"},{"type":"function","title":"macula_routing_protocol.is_find_node/1","doc":"Check if message is FIND_NODE.","ref":"macula_routing_protocol.html#is_find_node/1"},{"type":"function","title":"macula_routing_protocol.is_find_value/1","doc":"Check if message is FIND_VALUE.","ref":"macula_routing_protocol.html#is_find_value/1"},{"type":"function","title":"macula_routing_protocol.is_store/1","doc":"Check if message is STORE.","ref":"macula_routing_protocol.html#is_store/1"},{"type":"type","title":"macula_routing_protocol.message/0","doc":"","ref":"macula_routing_protocol.html#t:message/0"},{"type":"module","title":"macula_routing_server","doc":"GenServer managing Kademlia DHT routing table and operations. Integrates all routing components: table, DHT algorithms, protocol.","ref":"macula_routing_server.html"},{"type":"function","title":"macula_routing_server.add_node/2","doc":"Add node to routing table.","ref":"macula_routing_server.html#add_node/2"},{"type":"function","title":"macula_routing_server.find_closest/3","doc":"Find k closest nodes to target.","ref":"macula_routing_server.html#find_closest/3"},{"type":"function","title":"macula_routing_server.find_value/3","doc":"Find value in DHT using iterative lookup. Returns {ok, Value} if found, {nodes, Nodes} if not found.","ref":"macula_routing_server.html#find_value/3"},{"type":"function","title":"macula_routing_server.get_local/2","doc":"Get value from local storage.","ref":"macula_routing_server.html#get_local/2"},{"type":"function","title":"macula_routing_server.get_routing_table/1","doc":"Get routing table snapshot.","ref":"macula_routing_server.html#get_routing_table/1"},{"type":"function","title":"macula_routing_server.handle_message/2","doc":"Handle incoming DHT message and return reply.","ref":"macula_routing_server.html#handle_message/2"},{"type":"function","title":"macula_routing_server.size/1","doc":"Get number of nodes in routing table.","ref":"macula_routing_server.html#size/1"},{"type":"function","title":"macula_routing_server.start_link/2","doc":"Start routing server with registered name macula_routing_server.","ref":"macula_routing_server.html#start_link/2"},{"type":"function","title":"macula_routing_server.store_local/3","doc":"Store value locally.","ref":"macula_routing_server.html#store_local/3"},{"type":"module","title":"macula_routing_table","doc":"Routing table for Kademlia DHT. Manages 256 k-buckets organized by XOR distance.","ref":"macula_routing_table.html"},{"type":"function","title":"macula_routing_table.add_node/2","doc":"Add a node to the routing table. Calculates bucket index and adds to appropriate bucket.","ref":"macula_routing_table.html#add_node/2"},{"type":"function","title":"macula_routing_table.bucket_size/2","doc":"Get size of a specific bucket.","ref":"macula_routing_table.html#bucket_size/2"},{"type":"function","title":"macula_routing_table.find_closest/3","doc":"Find k closest nodes to target.","ref":"macula_routing_table.html#find_closest/3"},{"type":"function","title":"macula_routing_table.get_all_nodes/1","doc":"Get all nodes from all buckets.","ref":"macula_routing_table.html#get_all_nodes/1"},{"type":"function","title":"macula_routing_table.get_bucket/2","doc":"Get bucket by index.","ref":"macula_routing_table.html#get_bucket/2"},{"type":"function","title":"macula_routing_table.k/1","doc":"Get k (bucket capacity).","ref":"macula_routing_table.html#k/1"},{"type":"function","title":"macula_routing_table.local_node_id/1","doc":"Get local node ID.","ref":"macula_routing_table.html#local_node_id/1"},{"type":"function","title":"macula_routing_table.new/2","doc":"Create a new routing table.","ref":"macula_routing_table.html#new/2"},{"type":"function","title":"macula_routing_table.remove_node/2","doc":"Remove a node from the routing table.","ref":"macula_routing_table.html#remove_node/2"},{"type":"type","title":"macula_routing_table.routing_table/0","doc":"","ref":"macula_routing_table.html#t:routing_table/0"},{"type":"function","title":"macula_routing_table.size/1","doc":"Get total number of nodes in routing table.","ref":"macula_routing_table.html#size/1"},{"type":"function","title":"macula_routing_table.update_timestamp/2","doc":"Update timestamp for a node (moves to tail in its bucket).","ref":"macula_routing_table.html#update_timestamp/2"},{"type":"module","title":"macula_rpc_cache","doc":"LRU cache for RPC procedure results. Caches results of idempotent procedures to avoid repeated execution. Wraps macula_cache with RPC-specific logic and TTL handling.","ref":"macula_rpc_cache.html"},{"type":"type","title":"macula_rpc_cache.cache/0","doc":"","ref":"macula_rpc_cache.html#t:cache/0"},{"type":"function","title":"macula_rpc_cache.clear/1","doc":"Clear all entries.","ref":"macula_rpc_cache.html#clear/1"},{"type":"function","title":"macula_rpc_cache.get/3","doc":"Get entry from cache. Returns {ok, Result, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU). Automatically removes expired entries.","ref":"macula_rpc_cache.html#get/3"},{"type":"function","title":"macula_rpc_cache.invalidate/3","doc":"Invalidate (remove) entry.","ref":"macula_rpc_cache.html#invalidate/3"},{"type":"function","title":"macula_rpc_cache.is_expired/3","doc":"Check if entry is expired.","ref":"macula_rpc_cache.html#is_expired/3"},{"type":"function","title":"macula_rpc_cache.make_key/2","doc":"Make cache key from URI and args. Uses hash of URI and args for consistent key generation.","ref":"macula_rpc_cache.html#make_key/2"},{"type":"function","title":"macula_rpc_cache.max_size/1","doc":"Get max size.","ref":"macula_rpc_cache.html#max_size/1"},{"type":"function","title":"macula_rpc_cache.new/1","doc":"Create new cache with max size.","ref":"macula_rpc_cache.html#new/1"},{"type":"function","title":"macula_rpc_cache.put/5","doc":"Put entry in cache.","ref":"macula_rpc_cache.html#put/5"},{"type":"function","title":"macula_rpc_cache.put_with_timestamp/6","doc":"Put entry with custom timestamp (for testing).","ref":"macula_rpc_cache.html#put_with_timestamp/6"},{"type":"function","title":"macula_rpc_cache.size/1","doc":"Get number of entries.","ref":"macula_rpc_cache.html#size/1"},{"type":"module","title":"macula_rpc_discovery","doc":"DHT integration for finding RPC service providers. Uses Kademlia DHT to publish and discover RPC registrations. Wraps macula_discovery with RPC-specific types.","ref":"macula_rpc_discovery.html"},{"type":"type","title":"macula_rpc_discovery.address/0","doc":"","ref":"macula_rpc_discovery.html#t:address/0"},{"type":"function","title":"macula_rpc_discovery.announce/5","doc":"Announce local registration to DHT.","ref":"macula_rpc_discovery.html#announce/5"},{"type":"type","title":"macula_rpc_discovery.dht_lookup_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_lookup_fun/0"},{"type":"type","title":"macula_rpc_discovery.dht_publish_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_publish_fun/0"},{"type":"type","title":"macula_rpc_discovery.dht_unpublish_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_unpublish_fun/0"},{"type":"function","title":"macula_rpc_discovery.filter_available/2","doc":"Filter providers to only available ones (based on last_seen TTL).","ref":"macula_rpc_discovery.html#filter_available/2"},{"type":"function","title":"macula_rpc_discovery.find_providers/2","doc":"Find service providers for a URI via DHT.","ref":"macula_rpc_discovery.html#find_providers/2"},{"type":"function","title":"macula_rpc_discovery.find_with_cache/3","doc":"Find providers with cache (default TTL: 300 seconds).","ref":"macula_rpc_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_rpc_discovery.find_with_cache/4","doc":"Find providers with cache and custom TTL.","ref":"macula_rpc_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_rpc_discovery.node_id/0","doc":"","ref":"macula_rpc_discovery.html#t:node_id/0"},{"type":"type","title":"macula_rpc_discovery.provider_info/0","doc":"","ref":"macula_rpc_discovery.html#t:provider_info/0"},{"type":"function","title":"macula_rpc_discovery.unannounce/3","doc":"Remove local registration from DHT.","ref":"macula_rpc_discovery.html#unannounce/3"},{"type":"type","title":"macula_rpc_discovery.uri/0","doc":"","ref":"macula_rpc_discovery.html#t:uri/0"},{"type":"module","title":"macula_rpc_executor","doc":"RPC call execution with timeout handling. Executes local handlers and remote calls via QUIC.","ref":"macula_rpc_executor.html"},{"type":"type","title":"macula_rpc_executor.address/0","doc":"","ref":"macula_rpc_executor.html#t:address/0"},{"type":"function","title":"macula_rpc_executor.execute_local/3","doc":"Execute local handler with timeout.","ref":"macula_rpc_executor.html#execute_local/3"},{"type":"function","title":"macula_rpc_executor.execute_remote/5","doc":"Execute remote call via QUIC with timeout.","ref":"macula_rpc_executor.html#execute_remote/5"},{"type":"function","title":"macula_rpc_executor.generate_call_id/0","doc":"Generate unique call ID (16-byte UUID).","ref":"macula_rpc_executor.html#generate_call_id/0"},{"type":"type","title":"macula_rpc_executor.handler_fn/0","doc":"","ref":"macula_rpc_executor.html#t:handler_fn/0"},{"type":"type","title":"macula_rpc_executor.provider_info/0","doc":"","ref":"macula_rpc_executor.html#t:provider_info/0"},{"type":"type","title":"macula_rpc_executor.send_fun/0","doc":"","ref":"macula_rpc_executor.html#t:send_fun/0"},{"type":"module","title":"macula_rpc_handler","doc":"RPC handler GenServer - manages RPC calls, replies, and failover. Responsibilities: - Execute RPC calls (local check first, then DHT discovery) - Handle incoming RPC replies from network - Manage call timeouts with automatic failover - Track pending calls with call IDs - Monitor caller processes for automatic cleanup - Provider selection strategies (random, round-robin, etc.) Memory Safety: - Monitors caller processes to prevent memory leaks - Cleans up immediately when caller dies (no waiting for timeout) - Cancels timers and removes pending entries on cleanup Extracted from macula_connection.erl (Phase 5)","ref":"macula_rpc_handler.html"},{"type":"function","title":"macula_rpc_handler.call/4","doc":"","ref":"macula_rpc_handler.html#call/4"},{"type":"function","title":"macula_rpc_handler.handle_call/3","doc":"","ref":"macula_rpc_handler.html#handle_call/3"},{"type":"function","title":"macula_rpc_handler.handle_cast/2","doc":"","ref":"macula_rpc_handler.html#handle_cast/2"},{"type":"function","title":"macula_rpc_handler.handle_incoming_reply/2","doc":"","ref":"macula_rpc_handler.html#handle_incoming_reply/2"},{"type":"function","title":"macula_rpc_handler.handle_info/2","doc":"","ref":"macula_rpc_handler.html#handle_info/2"},{"type":"function","title":"macula_rpc_handler.init/1","doc":"","ref":"macula_rpc_handler.html#init/1"},{"type":"function","title":"macula_rpc_handler.register_handler/2","doc":"","ref":"macula_rpc_handler.html#register_handler/2"},{"type":"function","title":"macula_rpc_handler.start_link/1","doc":"","ref":"macula_rpc_handler.html#start_link/1"},{"type":"function","title":"macula_rpc_handler.terminate/2","doc":"","ref":"macula_rpc_handler.html#terminate/2"},{"type":"function","title":"macula_rpc_handler.unregister_handler/1","doc":"","ref":"macula_rpc_handler.html#unregister_handler/1"},{"type":"module","title":"macula_rpc_names","doc":"Name validation and utilities for RPC procedures. Uses reverse DNS notation: org.domain.service.procedure","ref":"macula_rpc_names.html"},{"type":"function","title":"macula_rpc_names.matches/2","doc":"Check if name matches pattern. For now, only exact matching (no wildcards). Future: Could add wildcard patterns if needed.","ref":"macula_rpc_names.html#matches/2"},{"type":"type","title":"macula_rpc_names.name/0","doc":"","ref":"macula_rpc_names.html#t:name/0"},{"type":"function","title":"macula_rpc_names.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_rpc_names.html#namespace/1"},{"type":"function","title":"macula_rpc_names.normalize/1","doc":"Normalize name (lowercase, trim, remove double dots).","ref":"macula_rpc_names.html#normalize/1"},{"type":"function","title":"macula_rpc_names.segment_count/1","doc":"Count number of segments in name.","ref":"macula_rpc_names.html#segment_count/1"},{"type":"function","title":"macula_rpc_names.validate/1","doc":"Validate RPC procedure name syntax. Valid names: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen - No leading or trailing dots - No double dots - No wildcards allowed (unlike topics)","ref":"macula_rpc_names.html#validate/1"},{"type":"module","title":"macula_rpc_registry","doc":"Local RPC procedure registration registry. Maps URIs to handler functions. Supports multiple handlers per URI (for load balancing).","ref":"macula_rpc_registry.html"},{"type":"function","title":"macula_rpc_registry.find/2","doc":"Find all registrations for a URI.","ref":"macula_rpc_registry.html#find/2"},{"type":"function","title":"macula_rpc_registry.find_handlers/2","doc":"Find all handlers for a URI.","ref":"macula_rpc_registry.html#find_handlers/2"},{"type":"type","title":"macula_rpc_registry.handler_fn/0","doc":"","ref":"macula_rpc_registry.html#t:handler_fn/0"},{"type":"type","title":"macula_rpc_registry.invocation_strategy/0","doc":"","ref":"macula_rpc_registry.html#t:invocation_strategy/0"},{"type":"function","title":"macula_rpc_registry.list_registrations/1","doc":"List all registrations.","ref":"macula_rpc_registry.html#list_registrations/1"},{"type":"function","title":"macula_rpc_registry.list_uris/1","doc":"List all unique URIs in registry.","ref":"macula_rpc_registry.html#list_uris/1"},{"type":"function","title":"macula_rpc_registry.new/0","doc":"Create new empty registry with default strategy (round_robin).","ref":"macula_rpc_registry.html#new/0"},{"type":"function","title":"macula_rpc_registry.new/1","doc":"Create new empty registry with custom strategy.","ref":"macula_rpc_registry.html#new/1"},{"type":"function","title":"macula_rpc_registry.register/4","doc":"Register a procedure handler. Allows multiple handlers for the same URI (for load balancing).","ref":"macula_rpc_registry.html#register/4"},{"type":"type","title":"macula_rpc_registry.registration/0","doc":"","ref":"macula_rpc_registry.html#t:registration/0"},{"type":"type","title":"macula_rpc_registry.registry/0","doc":"","ref":"macula_rpc_registry.html#t:registry/0"},{"type":"function","title":"macula_rpc_registry.size/1","doc":"Get total number of registrations.","ref":"macula_rpc_registry.html#size/1"},{"type":"function","title":"macula_rpc_registry.unregister/3","doc":"Unregister a specific procedure handler. Only removes the exact handler function.","ref":"macula_rpc_registry.html#unregister/3"},{"type":"module","title":"macula_rpc_router","doc":"RPC call routing strategies. Selects which provider to use for a call (local or remote).","ref":"macula_rpc_router.html"},{"type":"function","title":"macula_rpc_router.new_state/1","doc":"Create new router state.","ref":"macula_rpc_router.html#new_state/1"},{"type":"type","title":"macula_rpc_router.provider_info/0","doc":"","ref":"macula_rpc_router.html#t:provider_info/0"},{"type":"type","title":"macula_rpc_router.registration/0","doc":"","ref":"macula_rpc_router.html#t:registration/0"},{"type":"type","title":"macula_rpc_router.router_state/0","doc":"","ref":"macula_rpc_router.html#t:router_state/0"},{"type":"function","title":"macula_rpc_router.select_local/1","doc":"Select local handler (returns first one).","ref":"macula_rpc_router.html#select_local/1"},{"type":"function","title":"macula_rpc_router.select_provider/3","doc":"Select provider using stateless strategy. For local_first, random, and closest strategies.","ref":"macula_rpc_router.html#select_provider/3"},{"type":"function","title":"macula_rpc_router.select_provider_closest/3","doc":"Select provider using closest strategy (requires local node ID).","ref":"macula_rpc_router.html#select_provider_closest/3"},{"type":"function","title":"macula_rpc_router.select_provider_stateful/3","doc":"Select provider using stateful strategy (for round_robin).","ref":"macula_rpc_router.html#select_provider_stateful/3"},{"type":"function","title":"macula_rpc_router.select_remote_random/1","doc":"Select random remote provider.","ref":"macula_rpc_router.html#select_remote_random/1"},{"type":"type","title":"macula_rpc_router.strategy/0","doc":"","ref":"macula_rpc_router.html#t:strategy/0"},{"type":"module","title":"macula_rpc_routing","doc":"RPC routing for multi-hop DHT-routed RPC. Handles wrapping, unwrapping, and routing of RPC messages through the Kademlia DHT mesh.","ref":"macula_rpc_routing.html"},{"type":"function","title":"macula_rpc_routing.route_or_deliver/3","doc":"Route an rpc_route message: either deliver locally or forward to next hop. Returns one of: {deliver, PayloadType, Payload} - Message is for this node {forward, NextHopNodeInfo, UpdatedRpcRouteMsg} - Forward to next hop {error, Reason} - Cannot route (TTL exceeded, no route, etc.)","ref":"macula_rpc_routing.html#route_or_deliver/3"},{"type":"function","title":"macula_rpc_routing.should_deliver_locally/2","doc":"Determine if this node should deliver the message locally or forward it.","ref":"macula_rpc_routing.html#should_deliver_locally/2"},{"type":"function","title":"macula_rpc_routing.wrap_call/4","doc":"Wrap a CALL message in rpc_route envelope for DHT routing.","ref":"macula_rpc_routing.html#wrap_call/4"},{"type":"function","title":"macula_rpc_routing.wrap_reply/4","doc":"Wrap a REPLY message in rpc_route envelope for DHT routing back to caller.","ref":"macula_rpc_routing.html#wrap_reply/4"},{"type":"module","title":"macula_rpc_server","doc":"RPC server managing registrations and calls. GenServer that integrates registry, cache, discovery, router, and executor.","ref":"macula_rpc_server.html"},{"type":"function","title":"macula_rpc_server.call/4","doc":"Synchronous call to procedure.","ref":"macula_rpc_server.html#call/4"},{"type":"type","title":"macula_rpc_server.config/0","doc":"","ref":"macula_rpc_server.html#t:config/0"},{"type":"function","title":"macula_rpc_server.handle_call/3","doc":"Handle synchronous calls.","ref":"macula_rpc_server.html#handle_call/3"},{"type":"function","title":"macula_rpc_server.handle_cast/2","doc":"Handle asynchronous casts (none implemented).","ref":"macula_rpc_server.html#handle_cast/2"},{"type":"function","title":"macula_rpc_server.handle_info/2","doc":"Handle info messages (none expected).","ref":"macula_rpc_server.html#handle_info/2"},{"type":"function","title":"macula_rpc_server.init/1","doc":"Initialize server state.","ref":"macula_rpc_server.html#init/1"},{"type":"function","title":"macula_rpc_server.list_registrations/1","doc":"List local registrations.","ref":"macula_rpc_server.html#list_registrations/1"},{"type":"function","title":"macula_rpc_server.register/4","doc":"Register procedure.","ref":"macula_rpc_server.html#register/4"},{"type":"function","title":"macula_rpc_server.start_link/2","doc":"Start RPC server.","ref":"macula_rpc_server.html#start_link/2"},{"type":"type","title":"macula_rpc_server.state/0","doc":"","ref":"macula_rpc_server.html#t:state/0"},{"type":"function","title":"macula_rpc_server.stop/1","doc":"Stop RPC server.","ref":"macula_rpc_server.html#stop/1"},{"type":"function","title":"macula_rpc_server.terminate/2","doc":"Cleanup on termination.","ref":"macula_rpc_server.html#terminate/2"},{"type":"function","title":"macula_rpc_server.unregister/3","doc":"Unregister procedure.","ref":"macula_rpc_server.html#unregister/3"},{"type":"module","title":"macula_service_registry","doc":"Decentralized service advertisement registry using DHT. Provides service discovery via Kademlia DHT instead of centralized registration. Services advertise their capabilities to the DHT, and clients discover providers by querying the DHT. Architecture - Services advertise: \"I provide procedure X\" → DHT stores node_id at key=hash(procedure) - Clients discover: \"Who provides procedure X?\" → DHT returns list of node_ids - Local cache: Recent discoveries cached with TTL for low-latency lookups - Re-advertisement: Periodic republish to DHT for TTL renewal (default: every 5 min) Features - Fully decentralized (no central authority) - Multiple providers supported (DHT returns list) - Load balancing (client picks from list) - Fault tolerant (try another provider if one fails) - Low latency after first lookup (local cache)","ref":"macula_service_registry.html"},{"type":"function","title":"macula_service_registry.advertise_local/4","doc":"Advertise a service locally (stores handler for incoming calls). This registers the service handler locally so this node can respond to incoming RPC calls. The actual DHT advertisement must be done separately (see  publish_to_dht/4 ).","ref":"macula_service_registry.html#advertise_local/4"},{"type":"type","title":"macula_service_registry.cache_entry/0","doc":"","ref":"macula_service_registry.html#t:cache_entry/0"},{"type":"function","title":"macula_service_registry.cache_service/4","doc":"Cache discovered service providers. Stores providers in local cache with TTL. Subsequent  discover_service  calls will return cached results until TTL expires.","ref":"macula_service_registry.html#cache_service/4"},{"type":"function","title":"macula_service_registry.cache_subscribers/4","doc":"Cache discovered subscribers for a topic. Stores subscribers in local cache with TTL. Subsequent discover_subscribers/2 calls will return cached results until TTL expires.","ref":"macula_service_registry.html#cache_subscribers/4"},{"type":"function","title":"macula_service_registry.clear_cache/1","doc":"Clear the entire discovery cache.","ref":"macula_service_registry.html#clear_cache/1"},{"type":"function","title":"macula_service_registry.clear_subscriber_cache/1","doc":"Clear the entire subscriber cache.","ref":"macula_service_registry.html#clear_subscriber_cache/1"},{"type":"function","title":"macula_service_registry.discover_service/2","doc":"Discover service providers (checks cache first, returns cached if available).","ref":"macula_service_registry.html#discover_service/2"},{"type":"function","title":"macula_service_registry.discover_service/3","doc":"Discover service providers with options. Checks local cache first. If found and not expired, returns cached providers. If cache miss or expired, returns  {cache_miss, Registry}  so caller can query DHT. Options: -  force_refresh  - Skip cache, force DHT lookup (default: false)","ref":"macula_service_registry.html#discover_service/3"},{"type":"function","title":"macula_service_registry.discover_subscribers/2","doc":"Discover subscribers for a topic (checks cache first). Similar to discover_service/2 but for pub/sub subscribers. Returns cached subscribers if found and not expired, otherwise cache_miss.","ref":"macula_service_registry.html#discover_subscribers/2"},{"type":"function","title":"macula_service_registry.get_local_handler/2","doc":"Get handler function for a locally advertised service.","ref":"macula_service_registry.html#get_local_handler/2"},{"type":"type","title":"macula_service_registry.handler_fn/0","doc":"Handler function for local service implementations.","ref":"macula_service_registry.html#t:handler_fn/0"},{"type":"function","title":"macula_service_registry.list_local_services/1","doc":"List all locally advertised services.","ref":"macula_service_registry.html#list_local_services/1"},{"type":"type","title":"macula_service_registry.local_service/0","doc":"","ref":"macula_service_registry.html#t:local_service/0"},{"type":"function","title":"macula_service_registry.new/0","doc":"Create new empty service registry with default settings.","ref":"macula_service_registry.html#new/0"},{"type":"function","title":"macula_service_registry.new/1","doc":"Create new service registry with custom options. Options: -  default_ttl  - Default TTL for DHT advertisements (default: 300s) -  cache_ttl  - How long to cache discovered services (default: 60s) -  service_ttl  - TTL for local services before cleanup (default: 300s, 5 minutes)","ref":"macula_service_registry.html#new/1"},{"type":"type","title":"macula_service_registry.node_id/0","doc":"32-byte node identifier.","ref":"macula_service_registry.html#t:node_id/0"},{"type":"type","title":"macula_service_registry.provider_info/0","doc":"","ref":"macula_service_registry.html#t:provider_info/0"},{"type":"function","title":"macula_service_registry.prune_expired/1","doc":"Remove expired entries from discovery cache. Should be called periodically to prevent memory leaks. Returns updated registry and count of removed entries.","ref":"macula_service_registry.html#prune_expired/1"},{"type":"function","title":"macula_service_registry.prune_expired_local_services/1","doc":"Remove expired local services. Should be called periodically to prevent memory leaks from stale service registrations. Returns updated registry and count of removed services.","ref":"macula_service_registry.html#prune_expired_local_services/1"},{"type":"function","title":"macula_service_registry.prune_expired_subscribers/1","doc":"Remove expired subscriber cache entries. Should be called periodically to prevent memory leaks. Returns updated registry and count of removed entries.","ref":"macula_service_registry.html#prune_expired_subscribers/1"},{"type":"function","title":"macula_service_registry.publish_to_dht/5","doc":"Publish a service advertisement to the DHT. This function publishes a service's provider information to the DHT so other nodes can discover it. The service_id is hashed to create a DHT key, and the provider information is stored at that key. Parameters: - DhtPid: Process ID or registered name of macula_routing_server - ServiceId: The service identifier (procedure URI) - ProviderInfo: Information about this provider (node_id, endpoint, metadata) - TTL: Time-to-live in seconds for this advertisement - K: Number of nodes to store at (typically 20 for Kademlia) Returns: - ok if successful - {error, Reason} if publication failed Example: <span class=\"w\">  </span><span class=\"n\">ProviderInfo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6998351461-1\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">node_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6998351461-2\">&lt;&lt;</span><span class=\"s\">&quot;my-node-123&quot;</span><span class=\"p\" data-group-id=\"6998351461-2\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">endpoint</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6998351461-3\">&lt;&lt;</span><span class=\"s\">&quot;https://localhost:9443&quot;</span><span class=\"p\" data-group-id=\"6998351461-3\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">metadata</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6998351461-4\">#{</span><span class=\"ss\">version</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6998351461-5\">&lt;&lt;</span><span class=\"s\">&quot;1.0&quot;</span><span class=\"p\" data-group-id=\"6998351461-5\">&gt;&gt;</span><span class=\"p\" data-group-id=\"6998351461-4\">}</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6998351461-1\">}</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">publish_to_dht</span><span class=\"p\" data-group-id=\"6998351461-6\">(</span><span class=\"n\">DhtPid</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;energy.home.get&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ProviderInfo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">300</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"p\" data-group-id=\"6998351461-6\">)</span><span class=\"p\">.</span>","ref":"macula_service_registry.html#publish_to_dht/5"},{"type":"function","title":"macula_service_registry.query_dht_for_service/3","doc":"Query the DHT for service providers. This function queries the DHT to find nodes that provide a given service. It returns a list of provider_info() maps, each containing node_id, endpoint, and metadata for a provider. Parameters: - DhtPid: Process ID or registered name of macula_routing_server - ServiceId: The service identifier to query for - K: Number of closest nodes to query (typically 20 for Kademlia) Returns: - {ok, [ProviderInfo]} if providers found - {ok, []} if no providers found - {error, Reason} if query failed Example: <span class=\"w\">  </span><span class=\"p\" data-group-id=\"6953281901-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Providers</span><span class=\"p\" data-group-id=\"6953281901-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nf\">query_dht_for_service</span><span class=\"p\" data-group-id=\"6953281901-2\">(</span><span class=\"n\">DhtPid</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">lt</span><span class=\"p\">;</span><span class=\"s\">&quot;energy.home.get&quot;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"err\">&amp;</span><span class=\"ss\">gt</span><span class=\"p\">;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"p\" data-group-id=\"6953281901-2\">)</span><span class=\"p\">,</span><span class=\"w\">\n  </span><span class=\"c1\">%% Returns: [{ok, [#{node_id =&gt; ..., endpoint =&gt; ..., metadata =&gt; ...}]}]</span>","ref":"macula_service_registry.html#query_dht_for_service/3"},{"type":"type","title":"macula_service_registry.registry/0","doc":"","ref":"macula_service_registry.html#t:registry/0"},{"type":"function","title":"macula_service_registry.remove_from_dht/3","doc":"Remove a service advertisement from the DHT. This function removes a service advertisement when unadvertising. Note: In practice, DHT entries expire naturally via TTL, so this is optional and mainly useful for immediate cleanup. Parameters: - DhtPid: Process ID or registered name of macula_routing_server - ServiceId: The service identifier to remove - NodeId: This node's identifier (to remove only this provider) Returns: - ok if successful or entry not found - {error, Reason} if removal failed","ref":"macula_service_registry.html#remove_from_dht/3"},{"type":"type","title":"macula_service_registry.service_id/0","doc":"Service identifier (procedure URI). Example: <<\"energy.home.get\">>.","ref":"macula_service_registry.html#t:service_id/0"},{"type":"function","title":"macula_service_registry.unadvertise_local/2","doc":"Remove a local service advertisement.","ref":"macula_service_registry.html#unadvertise_local/2"},{"type":"module","title":"macula_stream_acceptor","doc":"Dedicated process for accepting QUIC streams on a connection. This process runs a blocking loop calling quicer:accept_stream/3, ensuring we're ready to accept streams before the client creates them.","ref":"macula_stream_acceptor.html"},{"type":"function","title":"macula_stream_acceptor.init/2","doc":"Initialize the stream acceptor loop.","ref":"macula_stream_acceptor.html#init/2"},{"type":"function","title":"macula_stream_acceptor.start_link/2","doc":"Start a stream acceptor for a connection. Gateway is the process that should receive stream data events.","ref":"macula_stream_acceptor.html#start_link/2"},{"type":"module","title":"macula_sup","doc":"macula top level supervisor.","ref":"macula_sup.html"},{"type":"function","title":"macula_sup.init/1","doc":"","ref":"macula_sup.html#init/1"},{"type":"function","title":"macula_sup.start_link/0","doc":"","ref":"macula_sup.html#start_link/0"},{"type":"module","title":"macula_time","doc":"Time utilities for Macula. Provides functions for timestamps, durations, and timeouts.","ref":"macula_time.html"},{"type":"function","title":"macula_time.duration_ms/2","doc":"Calculate duration in milliseconds between two timestamps.","ref":"macula_time.html#duration_ms/2"},{"type":"function","title":"macula_time.format_duration_ms/1","doc":"Format duration in milliseconds to human-readable string.","ref":"macula_time.html#format_duration_ms/1"},{"type":"function","title":"macula_time.format_timestamp/1","doc":"Format timestamp to ISO 8601 string.","ref":"macula_time.html#format_timestamp/1"},{"type":"function","title":"macula_time.is_expired/2","doc":"Check if timeout has expired.","ref":"macula_time.html#is_expired/2"},{"type":"function","title":"macula_time.minutes_to_ms/1","doc":"Convert minutes to milliseconds.","ref":"macula_time.html#minutes_to_ms/1"},{"type":"function","title":"macula_time.ms_to_seconds/1","doc":"Convert milliseconds to seconds (truncates).","ref":"macula_time.html#ms_to_seconds/1"},{"type":"function","title":"macula_time.seconds_to_ms/1","doc":"Convert seconds to milliseconds.","ref":"macula_time.html#seconds_to_ms/1"},{"type":"function","title":"macula_time.time_remaining/2","doc":"Calculate remaining time before timeout (in milliseconds). Returns 0 if already expired.","ref":"macula_time.html#time_remaining/2"},{"type":"function","title":"macula_time.timestamp/0","doc":"Get current timestamp in milliseconds since epoch.","ref":"macula_time.html#timestamp/0"},{"type":"function","title":"macula_time.timestamp_microseconds/0","doc":"Get current timestamp in microseconds since epoch.","ref":"macula_time.html#timestamp_microseconds/0"},{"type":"module","title":"macula_uri","doc":"Macula URI parsing and construction. Format: macula://realm/node_id Example: macula://org.example.mesh/0123456789abcdef...","ref":"macula_uri.html"},{"type":"function","title":"macula_uri.equals/2","doc":"Check if two URIs are equal.","ref":"macula_uri.html#equals/2"},{"type":"function","title":"macula_uri.get_node_id/1","doc":"Extract node ID from URI.","ref":"macula_uri.html#get_node_id/1"},{"type":"function","title":"macula_uri.get_realm/1","doc":"Extract realm from URI.","ref":"macula_uri.html#get_realm/1"},{"type":"function","title":"macula_uri.is_valid/1","doc":"Check if URI is valid.","ref":"macula_uri.html#is_valid/1"},{"type":"function","title":"macula_uri.new/2","doc":"Construct Macula URI from realm and node ID.","ref":"macula_uri.html#new/2"},{"type":"type","title":"macula_uri.node_id/0","doc":"","ref":"macula_uri.html#t:node_id/0"},{"type":"function","title":"macula_uri.parse/1","doc":"Parse Macula URI to extract realm and node ID.","ref":"macula_uri.html#parse/1"},{"type":"type","title":"macula_uri.realm/0","doc":"","ref":"macula_uri.html#t:realm/0"},{"type":"type","title":"macula_uri.uri/0","doc":"","ref":"macula_uri.html#t:uri/0"},{"type":"module","title":"macula_utils","doc":"Common utility functions for Macula. This module contains pure utility functions used across the Macula codebase to improve testability and eliminate duplication. All functions in this module are pure (no side effects) and can be tested independently.","ref":"macula_utils.html"},{"type":"function","title":"macula_utils.decode_json/1","doc":"Decode JSON binary to map/list.","ref":"macula_utils.html#decode_json/1"},{"type":"function","title":"macula_utils.encode_json/1","doc":"Encode map/list to JSON binary.","ref":"macula_utils.html#encode_json/1"},{"type":"function","title":"macula_utils.ensure_binary/1","doc":"Ensure value is binary.","ref":"macula_utils.html#ensure_binary/1"},{"type":"function","title":"macula_utils.generate_node_id/0","doc":"Generate a random node ID.","ref":"macula_utils.html#generate_node_id/0"},{"type":"function","title":"macula_utils.next_message_id/1","doc":"Get next message ID from counter. Returns {MessageId, NewCounter}.","ref":"macula_utils.html#next_message_id/1"},{"type":"function","title":"macula_utils.normalize_provider/1","doc":"Normalize provider map from binary keys to atom keys.","ref":"macula_utils.html#normalize_provider/1"},{"type":"function","title":"macula_utils.parse_host_port/2","doc":"Parse host:port string with default port.","ref":"macula_utils.html#parse_host_port/2"},{"type":"function","title":"macula_utils.parse_url/1","doc":"Parse URL to extract host and port.","ref":"macula_utils.html#parse_url/1"},{"type":"function","title":"macula_utils.topic_matches/5","doc":"Check if a published topic matches a subscription topic pattern. Supports configurable wildcards (defaults: dot-separated with * and **): - WildcardSingle (e.g., '*') matches a single segment - WildcardMulti (e.g., '**') matches multiple segments - Separator (e.g., '.') splits topic into segments - exact match otherwise","ref":"macula_utils.html#topic_matches/5"},{"type":"extras","title":"Overview","doc":"Macula HTTP/3 Mesh \n    A distributed platform for decentralized applications  \n \n\n \n     \n     \n \n\n---","ref":"readme-1.html"},{"type":"extras","title":"Table of Contents - Overview","doc":"📖 **[Executive Summary](docs/EXECUTIVE_SUMMARY.md)** - What Macula is and why it matters\n\n🚀 **[Quick Start](architecture/macula_http3_mesh_quick_start.md)** - Get running in 15 minutes\n\n💡 **[Hello World Tutorial](HELLO_WORLD.md)** - Build a distributed chat app in 30 minutes\n\n📚 **[Technical Documentation](architecture/macula_http3_mesh_root.md)** - Complete architecture and implementation guides\n\n🔧 **[Development Guide](docs/DEVELOPMENT.md)** - Setup, testing, and contributing\n\n🏗️ **[Comparisons](docs/COMPARISONS.md)** - How Macula compares to similar systems\n\n📊 **[Use Cases](docs/USE_CASES.md)** - Real-world applications and examples\n\n📝 **[Project Structure](architecture/MACULA_PROJECT_STRUCTURE.md)** - Module organization and dependencies\n\n🗺️ **[Roadmap](architecture/macula_http3_mesh_roadmap.md)** - 20-week implementation plan\n\n📄 **[Changelog](CHANGELOG.md)** - Version history and migration guides\n\n---","ref":"readme-1.html#table-of-contents"},{"type":"extras","title":"What is Macula? - Overview","doc":"Macula is infrastructure for building **decentralized applications and services** that operate autonomously at the edge, without dependency on centralized cloud infrastructure.\n\n**Key Features:**\n\n✅ **BEAM-native** (Erlang/Elixir OTP supervision and fault tolerance)\n✅ **HTTP/3 (QUIC)** transport (modern, encrypted, NAT-friendly)\n✅ **Edge-first design** (works through firewalls and NAT)\n✅ **Built-in pub/sub & RPC** (no external message broker needed)\n✅ **Multi-tenancy** (realm isolation for SaaS and shared infrastructure)\n✅ **Self-organizing mesh** (DHT-based service discovery, O(log N) routing)\n✅ **Production-ready patterns** (OTP behaviors, comprehensive testing, memory management)\n\n---","ref":"readme-1.html#what-is-macula"},{"type":"extras","title":"Installation - Overview","doc":"**Elixir (mix.exs):**\n\n```elixir\ndef deps do\n  [\n    {:macula, \"~> 0.6\"}\n  ]\nend\n```\n\n**Erlang (rebar.config):**\n\n```erlang\n{deps, [\n    {macula, \"0.6.6\"}\n]}.\n```\n\n---","ref":"readme-1.html#installation"},{"type":"extras","title":"Development Setup - Overview","doc":"```bash\n# Clone the repository\ngit clone https://github.com/macula-io/macula.git\ncd macula\n\n# Fetch dependencies\nrebar3 get-deps\n\n# Compile\nrebar3 compile\n\n# Run tests\nrebar3 eunit\n\n# Start a shell with Macula loaded\nrebar3 shell\n```\n\n---","ref":"readme-1.html#development-setup"},{"type":"extras","title":"Contributing - Overview","doc":"We welcome contributions! See [Development Guide](docs/DEVELOPMENT.md) for setup instructions and [Contributing Guide](CONTRIBUTING.md) for guidelines.\n\n---","ref":"readme-1.html#contributing"},{"type":"extras","title":"License - Overview","doc":"Macula is licensed under the Apache License 2.0. See [LICENSE](LICENSE) for details.\n\n---","ref":"readme-1.html#license"},{"type":"extras","title":"Community & Support - Overview","doc":"- **Issues**: [GitHub Issues](https://github.com/macula-io/macula/issues)\n- **Documentation**: [Architecture Docs](architecture/)\n- **Examples**: [Examples Directory](examples/)\n\n---\n\n**Built with ❤️ for the BEAM community**","ref":"readme-1.html#community-support"},{"type":"extras","title":"Hello World Tutorial","doc":"# Macula Hello World Tutorial\n\n**Build a distributed chat application in 30 minutes!**\n\nThis repository contains a complete, step-by-step tutorial for building your first Macula application - a fully distributed multi-user chat system using pub/sub and RPC.","ref":"hello_world.html"},{"type":"extras","title":"What You'll Build - Hello World Tutorial","doc":"- **Distributed chat** where messages route peer-to-peer through the mesh\n- **Presence tracking** to see who's online\n- **Room switching** to join different conversations\n- **Fault-tolerant** - nodes can leave and rejoin seamlessly","ref":"hello_world.html#what-you-ll-build"},{"type":"extras","title":"Full Tutorial - Hello World Tutorial","doc":"👉 **[Complete Hello World Tutorial](architecture/macula_http3_mesh_hello_world.md)** 👈\n\nThe tutorial includes:\n\n- ✅ Complete Elixir and Erlang implementations\n- ✅ Step-by-step instructions (9 steps)\n- ✅ Working code examples you can copy/paste\n- ✅ Architecture explanations with diagrams\n- ✅ Enhancement ideas (DMs, file sharing, typing indicators)\n- ✅ Fault tolerance testing","ref":"hello_world.html#full-tutorial"},{"type":"extras","title":"Quick Preview - Hello World Tutorial","doc":"**Add Macula to your project:**\n\n```elixir\n# mix.exs\ndef deps do\n  [\n    {:macula, \"~> 0.6\"}\n  ]\nend\n```\n\n**Send a message across the mesh:**\n\n```elixir\n# Publish to all subscribers\nMacula.PubSub.subscribe(\"chat.room.general\", self())\nMacula.PubSub.publish(\"chat.room.general\", %{\n  username: \"Alice\",\n  message: \"Hello, Macula!\"\n})\n```\n\n**Register an RPC endpoint:**\n\n```elixir\n# Any node can call this\nMacula.RPC.register(\"chat.users\", fn _args ->\n  {:ok, [\"Alice\", \"Bob\", \"Charlie\"]}\nend)\n\n# Call from any node in the mesh\n{:ok, users} = Macula.RPC.call(\"chat.users\", %{})\n```\n\nNo central server needed - everything routes peer-to-peer!","ref":"hello_world.html#quick-preview"},{"type":"extras","title":"Prerequisites - Hello World Tutorial","doc":"- Erlang/OTP 26+\n- Elixir 1.15+ (if using Mix)\n- Basic BEAM knowledge","ref":"hello_world.html#prerequisites"},{"type":"extras","title":"Time Commitment - Hello World Tutorial","doc":"**30 minutes** from zero to working distributed chat.\n\n---\n\n**Ready to get started?** 👉 **[Open the full tutorial](architecture/macula_http3_mesh_hello_world.md)**","ref":"hello_world.html#time-commitment"},{"type":"extras","title":"Changelog","doc":"# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.8.0] - TBD (Q2 2025)","ref":"changelog.html"},{"type":"extras","title":"Planned - True Mesh Architecture - Changelog","doc":"- **BREAKING**: Opportunistic NAT hole punching for direct peer-to-peer connections\n  - 80% direct P2P connections (cone NAT, no firewall)\n  - 20% gateway relay fallback (symmetric NAT, strict firewalls)\n  - True mesh topology (no single point of failure)\n  - New modules: `macula_nat_discovery`, `macula_hole_punch`, `macula_connection_upgrade`\n  - Backward compatible with v0.7.x gateway relay architecture\n\n**This will transform Macula from hub-and-spoke (star topology) to true decentralized mesh.**\n\nSee `architecture/NAT_TRAVERSAL_ROADMAP.md` for complete design.\n\n---\n\n## [0.7.4] - 2025-11-15","ref":"changelog.html#planned-true-mesh-architecture"},{"type":"extras","title":"Fixed - Changelog","doc":"- **CRITICAL**: Configurable keep-alive mechanism to prevent QUIC connection timeouts\n  - PING/PONG message support in `macula_connection`\n  - Default keep-alive interval: 30 seconds (configurable)\n  - Keep-alive enabled by default (can be disabled via options)\n  - Automatic PONG response to incoming PING messages\n  - Configuration via `macula_connection:default_config/0`\n  - Prevents 2-minute connection timeout that broke distributed matchmaking\n  - Added 6 tests for keep-alive functionality (all passing)\n\n**This is a critical fix for production deployments where QUIC connections timeout after ~2 minutes of inactivity, breaking pub/sub and matchmaking.**","ref":"changelog.html#fixed"},{"type":"extras","title":"Configuration - Changelog","doc":"Enable/disable keep-alive:\n```erlang\n%% Enable with custom interval (milliseconds)\nOpts = #{\n    keepalive_enabled => true,\n    keepalive_interval => 30000  %% 30 seconds\n}.\n\n%% Disable keep-alive\nOpts = #{\n    keepalive_enabled => false\n}.\n\n%% Use defaults (enabled, 30 second interval)\nDefaultConfig = macula_connection:default_config().\n```","ref":"changelog.html#configuration"},{"type":"extras","title":"Architecture Note - Changelog","doc":"**v0.7.4 maintains hub-and-spoke (star) topology**:\n- Edge peers connect to gateway (not each other)\n- Gateway routes all messages (relay architecture)\n- Gateway is single point of failure (by design for now)\n- DHT routing table exists but routing happens at gateway\n- True peer-to-peer mesh deferred to v0.8.0 (NAT traversal required)\n\n## [0.7.3] - 2025-11-15","ref":"changelog.html#architecture-note"},{"type":"extras","title":"Fixed - Changelog","doc":"- **CRITICAL**: Fixed DHT routing table address serialization crash in `macula_gateway_dht`\n  - Bug: Gateway stored parsed address **tuples** `{{127,0,0,1}, 9443}` in DHT instead of binary strings\n  - Impact: When FIND_VALUE replies tried to serialize node addresses, msgpack returned error `{:error, {:badarg, {{127,0,0,1}, 9443}}}`\n  - Root cause: `macula_gateway.erl:522` used `Address` (tuple from `parse_endpoint/1`) instead of `Endpoint` (binary string)\n  - Error chain: DHT stored tuples → encode_node_info extracted tuples → msgpack:pack failed → byte_size crashed\n  - Symptoms: Gateway crashed with \"ArgumentError: 1st argument not a bitstring\" when peers queried DHT\n  - Fix: Store original `Endpoint` binary string in DHT routing table instead of parsed tuple\n  - Added test: `dht_address_serialization_test` documents bug and validates fix\n\n**This is a critical fix for distributed matchmaking and service discovery. Without it, DHT queries crash the gateway.**\n\n## [0.7.2] - 2025-11-15","ref":"changelog.html#fixed-1"},{"type":"extras","title":"Fixed - Changelog","doc":"- **CRITICAL**: Fixed gateway crash in `parse_endpoint/1` when DNS resolution fails\n  - Bug: `inet:getaddr/2` error tuple was not handled, causing ArgumentError when passed to `byte_size/1`\n  - Impact: Gateway crashed repeatedly, closing all client connections and preventing pub/sub communication\n  - Symptoms: \"Failed to publish to topic: :closed\", \"Failed to send STORE for subscription: :closed\"\n  - Fix: Added proper error handling with localhost fallback when DNS resolution fails\n  - Now returns `{{127,0,0,1}, Port}` fallback instead of crashing\n\n**This is a critical fix for production deployments where endpoint DNS resolution may fail.**\n\n## [0.7.1] - 2025-11-15","ref":"changelog.html#fixed-2"},{"type":"extras","title":"Fixed - Changelog","doc":"- **CRITICAL**: Fixed ArithmeticError in `macula_pubsub_handler` message ID handling\n  - Bug: Was assigning binary MsgId to counter instead of integer NewCounter\n  - Impact: Caused pub/sub to crash on second publish attempt with \"bad argument in arithmetic expression\"\n  - Fix: Corrected destructuring in line 300 to use `{_MsgId, NewCounter}` instead of `{MsgIdCounter, _}`\n  - Now properly increments integer counter instead of trying to do arithmetic on binary\n\n**This is a critical fix for anyone using pub/sub functionality in v0.7.0.**\n\n## [0.7.0] - 2025-11-15","ref":"changelog.html#fixed-3"},{"type":"extras","title":"Changed - Changelog","doc":"- **BREAKING**: Major nomenclature refactoring for clarity and industry alignment\n  - Renamed `macula_connection` → `macula_peer` (mesh participant facade - high-level API)\n  - Renamed `macula_connection_manager` → `macula_connection` (QUIC transport layer - low-level)\n  - Follows industry standards used by libp2p, IPFS, and BitTorrent\n  - Clear separation: `macula_peer` = mesh participant, `macula_connection` = transport","ref":"changelog.html#changed"},{"type":"extras","title":"Added - Changelog","doc":"- Comprehensive transport layer test coverage (36 tests total)\n  - 11 new tests for message decoding, buffering, URL parsing, and realm normalization\n  - All tests passing with zero regressions\n- Complete v0.7.0 documentation in CLAUDE.md\n  - Migration guide with specific API examples\n  - Architecture rationale and benefits\n  - Status tracking for implementation phases","ref":"changelog.html#added"},{"type":"extras","title":"Migration Guide (0.6.x → 0.7.0) - Changelog","doc":"**API Changes:**\n\nAll high-level mesh operations now use `macula_peer` instead of `macula_connection`:\n\n```erlang\n%% Before (0.6.x)\n{ok, Client} = macula_connection:start_link(Url, Opts).\nok = macula_connection:publish(Client, Topic, Data).\n{ok, SubRef} = macula_connection:subscribe(Client, Topic, Callback).\n{ok, Result} = macula_connection:call(Client, Procedure, Args).\n\n%% After (0.7.0)\n{ok, Client} = macula_peer:start_link(Url, Opts).\nok = macula_peer:publish(Client, Topic, Data).\n{ok, SubRef} = macula_peer:subscribe(Client, Topic, Callback).\n{ok, Result} = macula_peer:call(Client, Procedure, Args).\n```\n\n**Why This Change?**\n\nThe original naming was confusing:\n- ❌ `macula_connection` served both facade AND transport roles\n- ❌ Mixed high-level mesh operations with low-level QUIC handling\n- ❌ Not aligned with P2P industry standards\n\nAfter v0.7.0:\n- ✅ `macula_peer` = mesh participant (clear high-level API for pub/sub, RPC, DHT)\n- ✅ `macula_connection` = QUIC transport (clear low-level transport layer)\n- ✅ Follows libp2p/IPFS/BitTorrent naming conventions\n\n**Note:** The `macula_client` wrapper module has been updated to use `macula_peer` internally, so if you're using `macula_client`, no changes are required.\n\n## [0.6.7] - 2025-11-15","ref":"changelog.html#migration-guide-0-6-x-0-7-0"},{"type":"extras","title":"Fixed - Changelog","doc":"- **CRITICAL:** Fixed all installation examples to use Hex package references instead of git dependencies\n  - README.md: Changed from git-based to `{:macula, \"~> 0.6\"}` (Elixir) and `{macula, \"0.6.7\"}` (Erlang)\n  - HELLO_WORLD.md: Updated to use proper Hex package format\n  - architecture/macula_http3_mesh_hello_world.md: Fixed tutorial installation examples\n  - architecture/macula_http3_mesh_rpc_guide.md: Fixed migration guide examples\n  - All code examples now show proper Hex.pm installation for published package\n\n## [0.6.6] - 2025-11-15","ref":"changelog.html#fixed-4"},{"type":"extras","title":"Fixed - Changelog","doc":"- Fixed navigation links in documentation guides to use ex_doc HTML filenames\n  - Changed GitHub-style relative paths (`../README.md`) to ex_doc HTML references (`readme.html`)\n  - Fixed all navigation links in EXECUTIVE_SUMMARY.md, COMPARISONS.md, USE_CASES.md, and DEVELOPMENT.md\n  - Links now work correctly in published Hexdocs without \"page not found\" errors\n\n## [0.6.5] - 2025-11-15","ref":"changelog.html#fixed-5"},{"type":"extras","title":"Changed - Changelog","doc":"- Updated to modern alternative logo (macula-alt-logo.svg) in both README.md and ex_doc\n- Changed tutorial greeting to brand-specific \"Hello, Macula!\" instead of generic greeting","ref":"changelog.html#changed-1"},{"type":"extras","title":"Fixed - Changelog","doc":"- Replaced old color logo with cleaner, more modern alternative logo for better visual appeal\n\n## [0.6.4] - 2025-11-15","ref":"changelog.html#fixed-6"},{"type":"extras","title":"Changed - Changelog","doc":"- **Documentation restructuring** - Split README.md into focused landing page with table of contents\n  - Created `docs/EXECUTIVE_SUMMARY.md` - Why Macula and the case for decentralization\n  - Created `docs/COMPARISONS.md` - How Macula compares to libp2p, Distributed Erlang, Akka, etc.\n  - Created `docs/USE_CASES.md` - Real-world applications across business, IoT, and AI domains\n  - Created `docs/DEVELOPMENT.md` - Complete development guide and coding standards\n  - README.md now serves as concise landing page (119 lines vs 372 lines)\n  - All detailed content accessible via clear table of contents\n  - Removed Mermaid diagram from README.md (ex_doc doesn't support Mermaid - works on GitHub)","ref":"changelog.html#changed-2"},{"type":"extras","title":"Fixed - Changelog","doc":"- ex_doc landing page uses HELLO_WORLD.md (tutorial-first approach, no multi-page split)\n- Documentation properly links to all new guide documents\n- Better first impression for Hex.pm users (logo, quick navigation)\n\n## [0.6.3] - 2025-11-15","ref":"changelog.html#fixed-7"},{"type":"extras","title":"Fixed - Changelog","doc":"- Removed README.md from ex_doc extras to prevent multi-page split and broken landing page\n- Documentation now correctly redirects to API reference page\n\n## [0.6.2] - 2025-11-15","ref":"changelog.html#fixed-8"},{"type":"extras","title":"Fixed - Changelog","doc":"- ex_doc landing page configuration (`{main, \"api-reference\"}`) - resolved \"readme.html not found\" error\n\n## [0.6.1] - 2025-11-15","ref":"changelog.html#fixed-9"},{"type":"extras","title":"Added - Changelog","doc":"- Professional documentation structure for Hex publication\n  - Architecture diagram in README.md (Mermaid format) showing mesh topology\n  - Organized documentation: moved 50+ files from root to docs/archive/, docs/development/, docs/planning/\n  - Created docs/README.md navigation index\n  - Logo and assets configuration for ex_doc\n  - Comprehensive Hex package file list (artwork/, docs/, architecture/)","ref":"changelog.html#added-1"},{"type":"extras","title":"Fixed - Changelog","doc":"- README.md badge rendering (moved badges outside ` ` tag for proper GitHub display)\n- ex_doc assets configuration (deprecated warning resolved)\n- ex_doc landing page configuration (changed `{main, \"readme\"}` to `{main, \"api-reference\"}` to fix \"readme.html not found\" error)\n- Hex package configuration to include all necessary assets and documentation\n- Documentation organization for professional first impression\n\n## [0.6.0] - 2025-11-15","ref":"changelog.html#fixed-10"},{"type":"extras","title":"Changed - Changelog","doc":"- **BREAKING**: Renamed environment variable from `GATEWAY_REALM` to `MACULA_REALM` for better API consistency\n  - All `MACULA_*` environment variables now follow consistent naming\n  - Applies to both gateway mode and edge peer mode\n  - Update your deployment configurations to use `MACULA_REALM` instead of `GATEWAY_REALM`","ref":"changelog.html#changed-3"},{"type":"extras","title":"Added - Changelog","doc":"- Comprehensive Kademlia DHT architecture documentation (`docs/KADEMLIA_DHT_ARCHITECTURE.md`)\n  - XOR distance metric explanation\n  - K-bucket routing table details\n  - DHT operations (PING, STORE, FIND_NODE, FIND_VALUE)\n  - Iterative lookup algorithm\n  - Macula-specific adaptations (realm-scoped DHT, HTTP/3 transport)\n  - Performance characteristics and comparisons","ref":"changelog.html#added-2"},{"type":"extras","title":"Fixed - Changelog","doc":"- Updated documentation to reflect `MACULA_REALM` environment variable usage\n- Updated `entrypoint.sh`, `Dockerfile.gateway`, and `config/sys.config` to use `MACULA_REALM`","ref":"changelog.html#fixed-11"},{"type":"extras","title":"Upcoming in v0.7.0 - Changelog","doc":"- Architecture improvement: Separation of `macula_connection` into `macula_peer` (high-level mesh API) and `macula_connection` (low-level QUIC transport)\n- See `docs/NOMENCLATURE_PROPOSAL_CONNECTION_TO_PEER.md` and `docs/PEER_CONNECTION_SEPARATION_PLAN.md` for details\n- Expected timeline: 4-5 weeks after v0.6.0 release","ref":"changelog.html#upcoming-in-v0-7-0"},{"type":"extras","title":"Migration Guide (0.5.0 → 0.6.0) - Changelog","doc":"If you're using Macula in gateway mode or configuring realm multi-tenancy:\n\n**Before (0.5.0):**\n```bash\nexport GATEWAY_REALM=my-app\n```\n\n**After (0.6.0):**\n```bash\nexport MACULA_REALM=my-app\n```\n\n**Elixir/Phoenix runtime.exs:**\n```elixir\n# Before (0.5.0)\nSystem.put_env(\"GATEWAY_REALM\", realm)\n\n# After (0.6.0)\nSystem.put_env(\"MACULA_REALM\", realm)\n```\n\n## [0.5.0] - 2025-11-14","ref":"changelog.html#migration-guide-0-5-0-0-6-0"},{"type":"extras","title":"Added - Changelog","doc":"- Initial public release\n- HTTP/3 (QUIC) mesh networking platform\n- Gateway mode for accepting incoming connections\n- Edge peer mode for mesh participation\n- Multi-tenancy via realm isolation\n- Pub/Sub messaging with wildcard support\n- RPC (request/response) patterns\n- Service discovery and advertisement\n- mDNS local discovery support\n- Process registry via gproc\n- Comprehensive documentation","ref":"changelog.html#added-3"},{"type":"extras","title":"Known Issues - Changelog","doc":"- Gateway mode requires proper TLS certificate configuration\n- Certificates must have Subject Alternative Name (SAN) extension\n- Docker deployments require proper file ownership (`--chown=app:app`)\n\n---\n\n[0.7.0]: https://github.com/macula-io/macula/compare/v0.6.7...v0.7.0\n[0.6.7]: https://github.com/macula-io/macula/compare/v0.6.6...v0.6.7\n[0.6.0]: https://github.com/macula-io/macula/compare/v0.5.0...v0.6.0\n[0.5.0]: https://github.com/macula-io/macula/releases/tag/v0.5.0","ref":"changelog.html#known-issues"},{"type":"extras","title":"License","doc":"MIT License\n\nCopyright (c) 2025 macula.io\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","ref":"license.html"},{"type":"extras","title":"Executive Summary","doc":"# Executive Summary\n\nMacula is infrastructure for building **decentralized applications and services** that operate autonomously at the edge, without dependency on centralized cloud infrastructure. It enables organizations to build systems where business logic, data, and intelligence live close to where they're needed—whether that's in factories, homes, vehicles, or partner networks.","ref":"executive_summary.html"},{"type":"extras","title":"Key Use Cases - Executive Summary","doc":"- **Business Applications**: Partner networks, supply chains, and collaborative platforms where organizations need to share capabilities without centralizing control\n- **IoT & Edge Computing**: Smart homes, industrial automation, and distributed sensor networks that continue operating even when disconnected from the cloud\n- **Adaptive & Collaborative AI**: Systems powered by **TWEANN** (Topology and Weight Evolving Artificial Neural Networks) and other evolutionary algorithms that learn and adapt locally, then share insights across the mesh\n\nUnlike traditional architectures where applications call centralized APIs, Macula enables **peer-to-peer mesh networks** where nodes discover each other, share services, and collaborate directly. Data stays where it's created, intelligence adapts locally, and the network self-organizes without central coordination.\n\nBuilt on **HTTP/3 (QUIC)** transport, Macula works through NAT and firewalls, making it practical for real-world deployments across diverse network environments.\n\n---","ref":"executive_summary.html#key-use-cases"},{"type":"extras","title":"Why Macula? The Case for Decentralization - Executive Summary","doc":"","ref":"executive_summary.html#why-macula-the-case-for-decentralization"},{"type":"extras","title":"The Centralized Cloud Problem - Executive Summary","doc":"Today's applications typically rely on centralized cloud platforms controlled by Big Tech companies (AWS, Azure, Google Cloud). While this model offers convenience, it creates fundamental issues:\n\n- **Vendor Lock-in**: Your business becomes dependent on proprietary APIs, pricing, and policies you don't control\n- **Data Sovereignty**: Sensitive data must leave your premises and live in someone else's infrastructure\n- **Single Points of Failure**: When the cloud goes down, your entire operation stops\n- **Latency & Bandwidth**: Every interaction requires round-trips to distant datacenters, wasting time and bandwidth\n- **Privacy & Compliance**: Regulations like GDPR become harder to satisfy when data flows through third-party infrastructure\n- **Cost**: Bandwidth, storage, and compute costs scale unpredictably as your system grows","ref":"executive_summary.html#the-centralized-cloud-problem"},{"type":"extras","title":"The Macula Alternative - Executive Summary","doc":"Macula offers a **different approach** that complements or replaces centralized cloud:\n\n- **True Ownership**: Run on your own hardware (edge devices, on-premise servers, or hybrid setups) with no dependency on proprietary platforms\n- **Local-First Architecture**: Data and intelligence stay where they're created, shared only when needed\n- **Autonomous Operation**: Systems continue working during network outages or when disconnected from the cloud\n- **Natural Scalability**: Peer-to-peer mesh architecture scales organically as you add nodes, without central bottlenecks\n- **Standards-Based**: Built on HTTP/3, not proprietary protocols, ensuring long-term viability and interoperability\n- **Cost Control**: Predictable infrastructure costs using commodity hardware and open-source software\n\nMacula isn't anti-cloud—it's about **choice**. Use the cloud where it makes sense, but don't let it be your only option. Build applications that work in hybrid environments, can migrate between deployment models, and give you control over your technology destiny.\n\n**For organizations that value autonomy, data sovereignty, and resilience, Macula provides the infrastructure to build truly decentralized systems.**\n\n---\n\n**[← Back to README](hello_world.html)** | **[Quick Start →](macula_http3_mesh_quick_start.html)**","ref":"executive_summary.html#the-macula-alternative"},{"type":"extras","title":"Comparisons","doc":"# How Macula Compares to Similar Systems\n\nDistributed networking is not new, and several excellent projects tackle similar problems. Here's how Macula differs:","ref":"comparisons.html"},{"type":"extras","title":"vs. libp2p (IPFS Networking Stack) - Comparisons","doc":"**[libp2p](https://libp2p.io/)** is the modular networking stack behind IPFS and Filecoin.\n\n- **What it is**: A comprehensive peer-to-peer networking library with many transport options, NAT traversal, and discovery mechanisms\n- **Maintained by**: Protocol Labs\n- **Key difference**: libp2p is a **library** you integrate into your application. Macula is a **platform** providing complete pub/sub and RPC primitives built specifically for the BEAM (Erlang/Elixir) ecosystem\n- **When to use libp2p**: Building file-sharing applications or integrating with the IPFS ecosystem\n- **When to use Macula**: Building business applications, IoT systems, or collaborative AI on Erlang/Elixir with built-in service discovery, multi-tenancy, and OTP supervision","ref":"comparisons.html#vs-libp2p-ipfs-networking-stack"},{"type":"extras","title":"vs. Distributed Erlang - Comparisons","doc":"**[Distributed Erlang](https://www.erlang.org/doc/reference_manual/distributed.html)** is Erlang's built-in clustering.\n\n- **What it is**: Native clustering for Erlang nodes with transparent process messaging\n- **Maintained by**: Ericsson (part of Erlang/OTP)\n- **Key difference**: Distributed Erlang requires **full mesh connectivity** (every node connects to every other node) and doesn't work through NAT/firewalls. Macula uses **HTTP/3 (QUIC)** for NAT-friendly transport and **Kademlia DHT routing** for O(log N) scalability without full mesh connectivity\n- **When to use Distributed Erlang**: Datacenter deployments with full network control and trusted environments\n- **When to use Macula**: Edge deployments, IoT networks, or any scenario involving NAT, firewalls, or untrusted networks","ref":"comparisons.html#vs-distributed-erlang"},{"type":"extras","title":"vs. Akka Cluster (JVM) - Comparisons","doc":"**[Akka Cluster](https://doc.akka.io/docs/akka/current/typed/cluster.html)** provides distributed actor systems for the JVM.\n\n- **What it is**: Clustering and distributed messaging for Scala/Java applications using the Actor model\n- **Maintained by**: Lightbend\n- **Key difference**: Akka runs on the **JVM** and uses TCP with gossip protocols. Macula runs on **BEAM** (Erlang VM) and uses **HTTP/3 (QUIC)** for modern, efficient transport with built-in encryption and NAT traversal\n- **When to use Akka**: JVM-based applications requiring distributed actors\n- **When to use Macula**: Erlang/Elixir applications requiring edge-friendly networking and standards-based transport","ref":"comparisons.html#vs-akka-cluster-jvm"},{"type":"extras","title":"vs. Kubernetes (Orchestration) - Comparisons","doc":"**[Kubernetes](https://kubernetes.io/)** orchestrates containerized applications at scale.\n\n- **What it is**: Container orchestration platform for deploying and managing microservices\n- **Maintained by**: Cloud Native Computing Foundation (CNCF)\n- **Key difference**: Kubernetes **orchestrates centralized infrastructure** (datacenters). Macula **enables peer-to-peer decentralized networks** at the edge. They solve different problems\n- **When to use Kubernetes**: Deploying microservices in datacenters or cloud environments\n- **When to use Macula**: Building peer-to-peer applications where nodes discover and communicate directly, without central orchestration","ref":"comparisons.html#vs-kubernetes-orchestration"},{"type":"extras","title":"vs. WebRTC (Browser P2P) - Comparisons","doc":"**[WebRTC](https://webrtc.org/)** enables peer-to-peer communication in web browsers.\n\n- **What it is**: Browser APIs for real-time video, audio, and data channels between peers\n- **Maintained by**: W3C and browser vendors\n- **Key difference**: WebRTC targets **browser-to-browser** communication for media streaming. Macula targets **server-to-server** and **device-to-device** communication for business applications, IoT, and AI systems\n- **When to use WebRTC**: Real-time video/audio in web browsers\n- **When to use Macula**: Backend services, IoT devices, and edge computing platforms","ref":"comparisons.html#vs-webrtc-browser-p2p"},{"type":"extras","title":"Macula's Unique Position - Comparisons","doc":"Macula combines ideas from these systems but targets a specific niche:\n\n✅ **BEAM-native** (Erlang/Elixir OTP supervision and fault tolerance)\n✅ **HTTP/3 (QUIC)** transport (modern, encrypted, NAT-friendly)\n✅ **Edge-first design** (works through firewalls and NAT)\n✅ **Built-in pub/sub & RPC** (no external message broker needed)\n✅ **Multi-tenancy** (realm isolation for SaaS and shared infrastructure)\n✅ **Self-organizing mesh** (DHT-based service discovery, O(log N) routing)\n✅ **Production-ready patterns** (OTP behaviors, comprehensive testing, memory management)\n\nIf you're building **decentralized Erlang/Elixir applications** that need to work in **real-world network conditions** (edge, IoT, hybrid cloud), Macula provides the infrastructure layer you need.\n\n---\n\n**[← Back to README](hello_world.html)** | **[Use Cases →](use_cases.html)**","ref":"comparisons.html#macula-s-unique-position"},{"type":"extras","title":"Use Cases","doc":"# Use Cases\n\nMacula enables a wide range of decentralized applications across multiple domains. Here are some real-world scenarios where Macula provides the ideal infrastructure.","ref":"use_cases.html"},{"type":"extras","title":"Business Applications - Use Cases","doc":"","ref":"use_cases.html#business-applications"},{"type":"extras","title":"Partner Networks - Use Cases","doc":"Organizations need to share services and capabilities without centralizing control or data.\n\n**Example**: **Supply chain collaboration** where multiple companies track shipments, share inventory status, and coordinate logistics without a single company controlling the platform.\n\n**Why Macula**:\n- Each organization runs nodes on their own infrastructure\n- Services are discovered via DHT without centralized registry\n- Data stays within organizational boundaries\n- Multi-tenancy via realms ensures isolation between partners","ref":"use_cases.html#partner-networks"},{"type":"extras","title":"Supply Chain Tracking - Use Cases","doc":"Track goods and events across multiple companies' infrastructure without a central database.\n\n**Example**: **Farm-to-table food tracking** where farms, processors, distributors, and retailers each publish events about product movements, with consumers able to trace the complete journey.\n\n**Why Macula**:\n- Events published via pub/sub stay with the originating organization\n- Downstream parties subscribe to relevant event streams\n- No single point of failure or data custody\n- Real-time updates without API polling","ref":"use_cases.html#supply-chain-tracking"},{"type":"extras","title":"Collaborative Platforms - Use Cases","doc":"Teams work together without depending on a single SaaS vendor.\n\n**Example**: **Research collaboration platform** where universities and research institutions share datasets, computational resources, and results without centralizing sensitive research data.\n\n**Why Macula**:\n- Institutions maintain sovereignty over their data\n- RPC enables distributed computation requests\n- Pub/sub enables real-time research updates\n- Works across institutional firewalls via HTTP/3\n\n---","ref":"use_cases.html#collaborative-platforms"},{"type":"extras","title":"IoT & Edge Computing - Use Cases","doc":"","ref":"use_cases.html#iot-edge-computing"},{"type":"extras","title":"Smart Homes - Use Cases","doc":"Devices communicate locally without cloud dependency.\n\n**Example**: **Home automation** where lights, thermostats, sensors, and controllers coordinate via the local mesh, continuing to operate even during internet outages.\n\n**Why Macula**:\n- Devices discover each other via mDNS locally\n- Pub/sub for event broadcasting (motion detected, temperature changed)\n- RPC for device control (turn on lights, adjust temperature)\n- No cloud latency or bandwidth costs\n- Privacy: data stays within the home","ref":"use_cases.html#smart-homes"},{"type":"extras","title":"Industrial Automation - Use Cases","doc":"Factories continue operating during network outages.\n\n**Example**: **Manufacturing floor** where robots, sensors, quality control systems, and inventory management coordinate production without relying on centralized cloud services.\n\n**Why Macula**:\n- Local mesh operates independently of WAN connectivity\n- Real-time control via RPC (< 10ms latency)\n- Event streams for monitoring and analytics\n- Fault tolerance via OTP supervision\n- Scales to thousands of sensors and actuators","ref":"use_cases.html#industrial-automation"},{"type":"extras","title":"Distributed Sensor Networks - Use Cases","doc":"Environmental monitoring, agriculture, infrastructure health.\n\n**Example**: **Agricultural IoT network** where soil moisture sensors, weather stations, irrigation controllers, and drones share data and coordinate actions across a large farm.\n\n**Why Macula**:\n- Sensors publish readings via pub/sub\n- Controllers subscribe to relevant sensor streams\n- RPC for remote commands (start irrigation, launch drone survey)\n- Works through rural NAT/firewall constraints\n- Edge processing reduces bandwidth usage\n\n---","ref":"use_cases.html#distributed-sensor-networks"},{"type":"extras","title":"Adaptive & Collaborative AI - Use Cases","doc":"","ref":"use_cases.html#adaptive-collaborative-ai"},{"type":"extras","title":"TWEANN-Based Systems - Use Cases","doc":"Neural networks that evolve topology and weights locally, then share insights.\n\n**Example**: **Adaptive manufacturing optimization** where each production line runs TWEANN agents that learn optimal parameters, then share successful mutations across the mesh.\n\n**Why Macula**:\n- Each edge node runs local evolutionary algorithms\n- Successful genome variations published via pub/sub\n- Other nodes subscribe and integrate improvements\n- No centralized training infrastructure needed\n- Continuous adaptation to local conditions","ref":"use_cases.html#tweann-based-systems"},{"type":"extras","title":"Federated Learning - Use Cases","doc":"Train models across distributed nodes without centralizing data.\n\n**Example**: **Healthcare diagnostics** where hospitals train ML models on local patient data, share model updates (not data) via the mesh, and collaboratively improve diagnostic accuracy.\n\n**Why Macula**:\n- Model updates published as events (not raw data)\n- Privacy-preserving: data never leaves institutions\n- Gradual convergence via distributed gradient sharing\n- Works across institutional network boundaries\n- Multi-tenancy ensures proper isolation","ref":"use_cases.html#federated-learning"},{"type":"extras","title":"Edge Intelligence - Use Cases","doc":"Decision-making at the edge with selective cloud synchronization.\n\n**Example**: **Autonomous vehicle fleet coordination** where vehicles make local decisions using onboard AI, share observations and planned maneuvers via the mesh, and only sync aggregated data to the cloud.\n\n**Why Macula**:\n- Low-latency local decision making (< 5ms)\n- Real-time coordination via pub/sub\n- RPC for requesting assistance from nearby vehicles\n- Operates during cellular network dropouts\n- Selective cloud sync reduces bandwidth costs\n\n---","ref":"use_cases.html#edge-intelligence"},{"type":"extras","title":"Gaming & Real-Time Applications - Use Cases","doc":"","ref":"use_cases.html#gaming-real-time-applications"},{"type":"extras","title":"Multiplayer Game Meshes - Use Cases","doc":"Players connect peer-to-peer without dedicated servers.\n\n**Example**: **LAN party games** where players discover each other locally, form game sessions, and play without internet connectivity or centralized game servers.\n\n**Why Macula**:\n- mDNS for local player discovery\n- Pub/sub for game state synchronization\n- RPC for player actions\n- Works offline, no server hosting costs\n- Realm isolation per game session","ref":"use_cases.html#multiplayer-game-meshes"},{"type":"extras","title":"Collaborative Editing - Use Cases","doc":"Real-time document collaboration without centralized services.\n\n**Example**: **Privacy-focused collaborative editor** where teams edit documents in real-time, with all data staying within the organization's infrastructure.\n\n**Why Macula**:\n- Operational transforms via pub/sub\n- Cursor positions and selections as events\n- RPC for conflict resolution\n- Works through corporate firewalls\n- No data leaves organizational control\n\n---","ref":"use_cases.html#collaborative-editing"},{"type":"extras","title":"Infrastructure & Networking - Use Cases","doc":"","ref":"use_cases.html#infrastructure-networking"},{"type":"extras","title":"Content Delivery Networks - Use Cases","doc":"Decentralized content distribution at the edge.\n\n**Example**: **Community CDN** where participants cache and serve content to local peers, reducing bandwidth costs and improving latency without centralized CDN providers.\n\n**Why Macula**:\n- DHT-based content discovery\n- Pub/sub for cache invalidation\n- RPC for content requests\n- Scales organically as nodes join\n- No CDN provider fees","ref":"use_cases.html#content-delivery-networks"},{"type":"extras","title":"Service Mesh for Edge Computing - Use Cases","doc":"Microservices at the edge with automatic discovery.\n\n**Example**: **Edge computing platform** where microservices discover dependencies, route requests, and balance load across edge nodes without centralized orchestration.\n\n**Why Macula**:\n- Service registry via DHT\n- Pub/sub for service health events\n- RPC with automatic failover\n- Multi-tenancy for SaaS deployments\n- Works through NAT and firewalls\n\n---","ref":"use_cases.html#service-mesh-for-edge-computing"},{"type":"extras","title":"Getting Started - Use Cases","doc":"Ready to build? See our **[Hello World Tutorial](hello_world.html)** to build your first decentralized application in 30 minutes.\n\nFor technical architecture details, see the **[Technical Documentation](macula_http3_mesh_root.html)**.\n\n---\n\n**[← Back to README](hello_world.html)** | **[Comparisons →](comparisons.html)**","ref":"use_cases.html#getting-started"},{"type":"extras","title":"Development Guide","doc":"# Development Guide\n\nThis guide covers setting up a development environment for contributing to Macula.","ref":"development.html"},{"type":"extras","title":"Prerequisites - Development Guide","doc":"- **Erlang/OTP 26+** - [Installation Guide](https://www.erlang.org/downloads)\n- **Rebar3** - Erlang build tool ([Installation](https://rebar3.org/docs/getting-started/))\n- **Git** - Version control\n- **Docker** (optional) - For multi-node testing","ref":"development.html#prerequisites"},{"type":"extras","title":"Quick Setup - Development Guide","doc":"```bash\n# Clone the repository\ngit clone https://github.com/macula-io/macula.git\ncd macula\n\n# Fetch dependencies\nrebar3 get-deps\n\n# Compile\nrebar3 compile\n\n# Run tests\nrebar3 eunit\n\n# Start a shell with Macula loaded\nrebar3 shell\n```","ref":"development.html#quick-setup"},{"type":"extras","title":"Project Structure - Development Guide","doc":"Macula is organized as a single Erlang/OTP library with ~68 modules:\n\n```\nmacula/\n├── src/                    # Source code (~68 .erl files)\n│   ├── macula_quic*.erl   # QUIC transport layer\n│   ├── macula_protocol*.erl # Wire protocol encoding/decoding\n│   ├── macula_connection*.erl # Connection management\n│   ├── macula_gateway*.erl # Gateway components\n│   ├── macula_routing*.erl # Kademlia DHT routing\n│   ├── macula_pubsub*.erl # Pub/Sub messaging\n│   ├── macula_rpc*.erl    # RPC operations\n│   └── macula_*.erl       # Core utilities\n├── test/                  # EUnit tests\n├── include/               # Header files (.hrl)\n├── architecture/          # Architecture documentation\n├── docs/                  # User-facing documentation\n├── examples/              # Example applications\n└── rebar.config          # Build configuration\n```\n\nSee [Project Structure](../architecture/MACULA_PROJECT_STRUCTURE.md) for complete module documentation.","ref":"development.html#project-structure"},{"type":"extras","title":"Running Tests - Development Guide","doc":"","ref":"development.html#running-tests"},{"type":"extras","title":"All Tests - Development Guide","doc":"```bash\nrebar3 eunit\n```","ref":"development.html#all-tests"},{"type":"extras","title":"Specific Module Tests - Development Guide","doc":"```bash\nrebar3 eunit --module=macula_id_tests\nrebar3 eunit --module=macula_gateway_client_manager_tests\n```","ref":"development.html#specific-module-tests"},{"type":"extras","title":"Test Coverage - Development Guide","doc":"```bash\nrebar3 do eunit, cover\n```","ref":"development.html#test-coverage"},{"type":"extras","title":"Multi-Node Integration Tests - Development Guide","doc":"```bash\ncd docker\ndocker compose -f docker-compose.multi-node-test.yml build --no-cache\ndocker compose -f docker-compose.multi-node-test.yml up\n```","ref":"development.html#multi-node-integration-tests"},{"type":"extras","title":"Code Quality Standards - Development Guide","doc":"Macula follows **Idiomatic Erlang** principles:","ref":"development.html#code-quality-standards"},{"type":"extras","title":"Core Principles - Development Guide","doc":"- ✅ **Pattern matching on function heads** - Avoid `if` and `cond`\n- ✅ **Guards instead of case** - Use guards for simple conditions\n- ✅ **Shallow nesting** - Keep nesting to 1-2 levels maximum\n- ✅ **Let it crash** - Don't catch errors unless you can handle them meaningfully\n- ✅ **OTP behaviors** - Use gen_server, gen_statem, supervisor where appropriate","ref":"development.html#core-principles"},{"type":"extras","title":"Example: Good vs. Bad - Development Guide","doc":"❌ **Bad:**\n```erlang\nprocess_message(Msg, State) ->\n    if\n        is_binary(Msg) ->\n            case decode_message(Msg) of\n                {ok, Data} ->\n                    if\n                        Data#data.type == request ->\n                            handle_request(Data, State);\n                        Data#data.type == response ->\n                            handle_response(Data, State)\n                    end\n            end\n    end.\n```\n\n✅ **Good:**\n```erlang\n%% Guard ensures binary input\nprocess_message(Msg, State) when is_binary(Msg) ->\n    case decode_message(Msg) of\n        {ok, Data} -> handle_decoded_message(Data, State);\n        {error, Reason} -> {error, Reason}\n    end;\nprocess_message(_Msg, _State) ->\n    {error, invalid_message}.\n\n%% Pattern match on data type\nhandle_decoded_message(#data{type = request} = Data, State) ->\n    handle_request(Data, State);\nhandle_decoded_message(#data{type = response} = Data, State) ->\n    handle_response(Data, State).\n```\n\nSee [CLAUDE.md](../CLAUDE.md) for complete coding guidelines.","ref":"development.html#example-good-vs-bad"},{"type":"extras","title":"Building Documentation - Development Guide","doc":"Macula uses ex_doc for documentation generation:\n\n```bash\nrebar3 ex_doc\n```\n\nGenerated docs appear in `doc/` directory. Open `doc/index.html` in a browser.","ref":"development.html#building-documentation"},{"type":"extras","title":"Docker Development - Development Guide","doc":"","ref":"development.html#docker-development"},{"type":"extras","title":"Clean Build (Always After Code Changes) - Development Guide","doc":"```bash\n# Prune cache and rebuild from scratch\ndocker builder prune -af\ndocker compose -f   build --no-cache\n```\n\n**Why?** Docker build cache can use stale layers even after code changes. Always prune and rebuild when testing code changes.","ref":"development.html#clean-build-always-after-code-changes"},{"type":"extras","title":"Multi-Node Test Environment - Development Guide","doc":"```bash\ncd docker\ndocker-compose -f docker-compose.multi-node-test.yml up\n```\n\nThis starts:\n- 1 registry node (gateway)\n- 3 provider nodes (advertise services)\n- 1 client node (discovers and calls services)","ref":"development.html#multi-node-test-environment"},{"type":"extras","title":"Memory Management - Development Guide","doc":"Macula implements comprehensive memory leak prevention. See [Memory Management](../architecture/memory_management/README.md) for details.\n\n**Key Mechanisms:**\n- Bounded connection pools (max 1,000 connections, LRU eviction)\n- Client connection limits (max 10,000 clients, configurable)\n- Service TTL/cleanup (5-minute TTL, 60-second cleanup interval)\n- Stream cleanup on disconnect\n- Caller process monitoring for RPC handlers\n\n**Monitoring:**\n```erlang\n%% Check connection pool size\nmacula_gateway_mesh:pool_size(GatewayPid).\n\n%% Check client count\nmacula_gateway_client_manager:client_count(ManagerPid).\n\n%% Check service registry size\nmacula_service_registry:service_count().\n```","ref":"development.html#memory-management"},{"type":"extras","title":"Refactoring Status - Development Guide","doc":"","ref":"development.html#refactoring-status"},{"type":"extras","title":"Gateway Refactoring (COMPLETED - Jan 2025) - Development Guide","doc":"The gateway module has been refactored into 6 focused modules with comprehensive tests:\n\n- ✅ `macula_gateway_client_manager.erl` - Client lifecycle (24 tests)\n- ✅ `macula_gateway_pubsub.erl` - Pub/Sub routing (31 tests)\n- ✅ `macula_gateway_rpc.erl` - RPC handler management (20 tests)\n- ✅ `macula_gateway_mesh.erl` - Mesh connection pooling (16 tests)\n- ✅ `macula_gateway_dht.erl` - DHT query forwarding (stateless)\n- ✅ `macula_gateway_rpc_router.erl` - Multi-hop RPC routing (17 tests)\n- ✅ `macula_gateway_sup.erl` - Supervision tree (24 tests)\n\nTotal: 132 tests, all passing.","ref":"development.html#gateway-refactoring-completed-jan-2025"},{"type":"extras","title":"Connection Refactoring (IN PROGRESS - Jan 2025) - Development Guide","doc":"`macula_connection.erl` (2,030 LOC god module) is being refactored using TDD.\n\nSee:\n- [God Module Refactoring Plan](../architecture/god_module_refactoring_plan.md) - 9-week TDD plan\n- [Connection Behaviors](../architecture/macula_connection_behaviors.md) - 275+ test scenarios\n- [Refactoring Status](../architecture/god_module_refactoring_status.md) - Current progress\n\n**DO NOT** modify `macula_connection.erl` without reading the refactoring plan first!","ref":"development.html#connection-refactoring-in-progress-jan-2025"},{"type":"extras","title":"Contributing Workflow - Development Guide","doc":"1. **Read the documentation**\n   - [README.md](../README.md)\n   - [CONTRIBUTING.md](../CONTRIBUTING.md)\n   - [CLAUDE.md](../CLAUDE.md) - Coding guidelines\n\n2. **Create a feature branch**\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n3. **Write tests first** (TDD approach preferred)\n   ```bash\n   # Create test file\n   touch test/macula_your_module_tests.erl\n\n   # Write failing tests\n   # Implement functionality\n   # Verify tests pass\n   rebar3 eunit --module=macula_your_module_tests\n   ```\n\n4. **Follow code quality standards**\n   - Pattern matching over conditionals\n   - Guards instead of case where possible\n   - Maximum 1-2 levels of nesting\n   - Comprehensive tests for new functionality\n\n5. **Commit and push**\n   ```bash\n   git add .\n   git commit -m \"Add feature: your feature description\"\n   git push origin feature/your-feature-name\n   ```\n\n6. **Create pull request**\n   - Describe what the PR does\n   - Reference any related issues\n   - Ensure all tests pass\n   - Follow PR template guidelines","ref":"development.html#contributing-workflow"},{"type":"extras","title":"Getting Help - Development Guide","doc":"- **Issues**: [GitHub Issues](https://github.com/macula-io/macula/issues)\n- **Documentation**: [Architecture Docs](../architecture/)\n- **Code Quality**: [CODE_REVIEW_REPORT.md](../CODE_REVIEW_REPORT.md)\n\n---\n\n**[← Back to README](hello_world.html)** | **[Technical Documentation →](macula_http3_mesh_root.html)**","ref":"development.html#getting-help"},{"type":"extras","title":"Documentation Index","doc":"# Macula Documentation\n\n**Welcome to the Macula HTTP/3 Mesh documentation!**\n\nMacula is a distributed platform for building decentralized applications using HTTP/3 (QUIC) transport with P2P mesh networking.\n\n---","ref":"readme-2.html"},{"type":"extras","title":"🚀 Getting Started - Documentation Index","doc":"- **[Quick Start](../HELLO_WORLD.md)** - Build a distributed chat app in 30 minutes\n- **[Architecture Overview](../architecture/macula_http3_mesh_root.md)** - Complete documentation hub\n- **[Project Structure](../architecture/MACULA_PROJECT_STRUCTURE.md)** - Module organization\n\n---","ref":"readme-2.html#getting-started"},{"type":"extras","title":"📚 Core Documentation - Documentation Index","doc":"","ref":"readme-2.html#core-documentation"},{"type":"extras","title":"Architecture & Design - Documentation Index","doc":"- **[Kademlia DHT Architecture](KADEMLIA_DHT_ARCHITECTURE.md)** - Distributed hash table implementation\n- **[QUIC/TLS Setup Guide](QUIC_TLS_GATEWAY_SETUP.md)** - Gateway TLS configuration\n- **[Memory Management](../architecture/memory_management/README.md)** - Production-ready leak prevention\n- **[C4 Diagrams](../architecture/macula_http3_mesh_c4_diagrams.md)** - Visual architecture overview","ref":"readme-2.html#architecture-design"},{"type":"extras","title":"Planned Improvements - Documentation Index","doc":"- **[Peer-Connection Separation Plan](PEER_CONNECTION_SEPARATION_PLAN.md)** - v0.7.0 TDD refactoring (4.5 weeks)\n- **[Nomenclature Proposal](NOMENCLATURE_PROPOSAL_CONNECTION_TO_PEER.md)** - connection → peer rename\n- **[Peer vs Connection Analysis](PEER_VS_CONNECTION_ANALYSIS.md)** - Responsibility breakdown\n\n---","ref":"readme-2.html#planned-improvements"},{"type":"extras","title":"🛠️ Development - Documentation Index","doc":"","ref":"readme-2.html#development"},{"type":"extras","title":"Development Guides - Documentation Index","doc":"- **[Testing Guide](development/TESTING.md)** - Unit, integration, and E2E testing\n- **[Docker Build Reference](development/DOCKER_BUILD_REFERENCE.md)** - Build best practices\n- **[Hex Publication Guide](development/HEX_PUBLICATION_GUIDE.md)** - Publishing to Hex.pm\n- **[mDNS Setup](development/MDNS_SETUP.md)** - Local service discovery configuration","ref":"readme-2.html#development-guides"},{"type":"extras","title":"Planning Documents - Documentation Index","doc":"- **[Implementation Plan](planning/IMPLEMENTATION_PLAN.md)** - Original 20-week roadmap\n- **[Multi-Node Testing Plan](planning/MULTI_NODE_TESTING_PLAN.md)** - Testing strategy\n\n---","ref":"readme-2.html#planning-documents"},{"type":"extras","title":"📖 User Guides - Documentation Index","doc":"- **[Quick Start](../architecture/macula_http3_mesh_quick_start.md)** - 15-minute mesh setup\n- **[Hello World Tutorial](../architecture/macula_http3_mesh_hello_world.md)** - Build your first app\n- **[RPC Guide](../architecture/macula_http3_mesh_rpc_guide.md)** - Remote procedure calls\n- **[API Reference](../architecture/macula_http3_mesh_api_reference.md)** - Complete API docs\n\n---","ref":"readme-2.html#user-guides"},{"type":"extras","title":"🔍 Reference - Documentation Index","doc":"","ref":"readme-2.html#reference"},{"type":"extras","title":"Technical Deep Dives - Documentation Index","doc":"- **[DHT Routed RPC](../architecture/dht_routed_rpc.md)** - Multi-hop Kademlia routing\n- **[Pub/Sub Optimization](../architecture/pubsub_optimization_recommendations.md)** - 10,000+ msg/sec\n- **[Isolation Mechanisms](../architecture/macula_http3_mesh_isolation_mechanisms.md)** - Multi-tenancy\n- **[NAT Traversal](../architecture/macula_http3_mesh_nat_traversal.md)** - Firewall-friendly transport","ref":"readme-2.html#technical-deep-dives"},{"type":"extras","title":"Comparisons - Documentation Index","doc":"- **[vs libp2p](../architecture/macula_http3_mesh_vs_libp2p.md)** - Why Macula?\n- **[vs WAMP](../architecture/macula_http3_mesh_vs_wamp.md)** - HTTP/3 mesh advantages\n- **[vs Distributed Erlang](../architecture/macula_http3_mesh_vs_distributed_erlang.md)** - QUIC benefits\n\n---","ref":"readme-2.html#comparisons"},{"type":"extras","title":"📦 Release Information - Documentation Index","doc":"- **[Changelog](../CHANGELOG.md)** - Version history and breaking changes\n- **[v0.6.0 Release Summary](V0.6.0_RELEASE_SUMMARY.md)** - Latest release details\n\n---","ref":"readme-2.html#release-information"},{"type":"extras","title":"📂 Archive & History - Documentation Index","doc":"- **[Archive](archive/)** - Historical analysis and completed work (~40 documents)\n- **[Sessions](sessions/)** - Development session summaries\n\n---","ref":"readme-2.html#archive-history"},{"type":"extras","title":"🤝 Contributing - Documentation Index","doc":"- **[Contributing Guide](../architecture/macula_http3_mesh_contributing.md)** - How to contribute\n- **[Documentation Status](../architecture/DOCUMENTATION_STATUS.md)** - What's complete\n\n---","ref":"readme-2.html#contributing"},{"type":"extras","title":"📞 Community & Support - Documentation Index","doc":"- **Issues**: [GitHub Issues](https://github.com/macula-io/macula/issues)\n- **Examples**: [Examples Directory](../examples/)\n- **License**: [Apache 2.0](../LICENSE)\n\n---\n\n**Built with ❤️ for the BEAM community**","ref":"readme-2.html#community-support"},{"type":"extras","title":"Kademlia DHT Architecture","doc":"# Kademlia DHT Architecture in Macula","ref":"kademlia_dht_architecture.html"},{"type":"extras","title":"Overview - Kademlia DHT Architecture","doc":"Macula uses a **Kademlia Distributed Hash Table (DHT)** for decentralized service discovery and peer-to-peer routing. This document describes how Kademlia principles are implemented in the HTTP/3 mesh network.\n\n**Key Reference:** [Kademlia: A Peer-to-peer Information System Based on the XOR Metric](http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf) (Maymounkov & Mazières, 2002)","ref":"kademlia_dht_architecture.html#overview"},{"type":"extras","title":"Why Kademlia? - Kademlia DHT Architecture","doc":"Traditional DHTs (like Chord) use numeric distance metrics that don't align well with network topology. Kademlia's XOR-based metric provides:\n\n1. **Symmetric distance** - `distance(A, B) = distance(B, A)`\n2. **Network-aware routing** - Nodes sharing common prefixes tend to be routed through similar paths\n3. **O(log N) lookup complexity** - Efficient even with millions of nodes\n4. **Self-organizing** - No central coordination required\n5. **NAT-friendly** - Works well with HTTP/3's connection-oriented transport","ref":"kademlia_dht_architecture.html#why-kademlia"},{"type":"extras","title":"Core Concepts - Kademlia DHT Architecture","doc":"","ref":"kademlia_dht_architecture.html#core-concepts"},{"type":"extras","title":"1. Node IDs and XOR Metric - Kademlia DHT Architecture","doc":"Every node in the Macula mesh has a 160-bit **Node ID** derived from:\n- Gateway mode: Hash of (realm + IP + port)\n- Edge peer mode: Randomly generated on startup\n\n**XOR Distance Formula:**\n```\ndistance(A, B) = A ⊕ B (bitwise XOR)\n```\n\n**Example:**\n```\nNode A: 0b10110101\nNode B: 0b11010011\n-------\nXOR:    0b01100110  (distance = 102 decimal)\n```\n\nNodes are considered \"closer\" when their XOR distance is smaller. This creates a geometric address space where routing naturally follows network topology.","ref":"kademlia_dht_architecture.html#1-node-ids-and-xor-metric"},{"type":"extras","title":"2. K-Buckets (Routing Table) - Kademlia DHT Architecture","doc":"Each node maintains a **routing table** of `160 k-buckets`, where `k = 20` (typical value).\n\n**Structure:**\n- **Bucket 0**: Nodes at distance `2^0` to `2^1 - 1` (immediate neighbors)\n- **Bucket 1**: Nodes at distance `2^1` to `2^2 - 1`\n- **Bucket i**: Nodes at distance `2^i` to `2^(i+1) - 1`\n- **Bucket 159**: Nodes at distance `2^159` to `2^160 - 1` (furthest)\n\n**K-Bucket Properties:**\n- Maximum of `k` entries per bucket\n- Least-recently-seen nodes are evicted first (LRU)\n- Bucket 0 (closest nodes) is most important for routing\n\n**Macula Implementation:**\n```erlang\n%% In macula_routing.erl (conceptual)\n-define(KADEMLIA_K, 20).          %% Bucket size\n-define(KADEMLIA_ALPHA, 3).       %% Parallel lookup factor\n-define(ID_BITS, 160).            %% SHA-1 hash size\n\n-record(k_bucket, {\n    distance_range :: {integer(), integer()},\n    nodes :: [node_entry()],       %% Max 20 entries\n    last_updated :: erlang:timestamp()\n}).\n```","ref":"kademlia_dht_architecture.html#2-k-buckets-routing-table"},{"type":"extras","title":"3. DHT Operations - Kademlia DHT Architecture","doc":"Kademlia defines four core RPC operations:\n\n#### PING\n**Purpose:** Check if a node is alive\n\n**Request:**\n```erlang\n{ping, FromNodeID, Timestamp}\n```\n\n**Response:**\n```erlang\n{pong, ToNodeID, Timestamp}\n```\n\n**Use Case:** Health checking, routing table maintenance\n\n---\n\n#### STORE\n**Purpose:** Store a key-value pair on a node\n\n**Request:**\n```erlang\n{store, Key, Value, TTL}\n```\n\n**Response:**\n```erlang\n{stored, Key, ExpiresAt}\n```\n\n**Macula Mapping:**\n- **Key**: Service name hash (e.g., `sha1(\"game.matchmaking\")`)\n- **Value**: Service endpoint info (realm, node_id, capabilities)\n- **TTL**: Advertisement lifetime (default: 5 minutes)\n\n---\n\n#### FIND_NODE\n**Purpose:** Locate k closest nodes to a target ID\n\n**Request:**\n```erlang\n{find_node, TargetID, K}\n```\n\n**Response:**\n```erlang\n{nodes, [\n    {NodeID1, IP1, Port1, Realm1},\n    {NodeID2, IP2, Port2, Realm2},\n    ...\n]} %% Sorted by XOR distance to TargetID\n```\n\n**Use Case:** Populating routing table, iterative lookups\n\n---\n\n#### FIND_VALUE\n**Purpose:** Retrieve value for a key (service discovery)\n\n**Request:**\n```erlang\n{find_value, Key}\n```\n\n**Response (if found):**\n```erlang\n{value, Key, ServiceInfo}\n```\n\n**Response (if not found):**\n```erlang\n{nodes, [...]}  %% Fallback to FIND_NODE\n```\n\n**Macula Mapping:**\n- **Key**: Service name (e.g., `\"game.matchmaking\"`)\n- **ServiceInfo**: List of providers advertising that service\n\n---","ref":"kademlia_dht_architecture.html#3-dht-operations"},{"type":"extras","title":"4. Iterative Lookup Algorithm - Kademlia DHT Architecture","doc":"To find a service or node, Macula performs an **iterative FIND_VALUE** lookup:\n\n**Algorithm:**\n1. Start with the `α = 3` closest nodes from local routing table\n2. Send parallel `FIND_VALUE` requests to these nodes\n3. If value found → return immediately\n4. Otherwise, add returned nodes to candidate set\n5. Select next `α` closest unqueried nodes\n6. Repeat until:\n   - Value is found, OR\n   - No closer nodes remain, OR\n   - Maximum hops reached (log₂N)\n\n**Convergence:** Guaranteed to find value in O(log N) hops\n\n**Macula Implementation (conceptual):**\n```erlang\nfind_service(ServiceName, Realm) ->\n    Key = crypto:hash(sha, ServiceName),\n    ClosestNodes = get_closest_nodes(Key, ?KADEMLIA_ALPHA),\n    iterative_lookup(Key, ClosestNodes, #{}, 0).\n\niterative_lookup(Key, [], _Queried, _Hops) ->\n    {error, not_found};\niterative_lookup(Key, Candidates, Queried, Hops) when Hops > 20 ->\n    {error, max_hops_exceeded};\niterative_lookup(Key, Candidates, Queried, Hops) ->\n    %% Query α closest unqueried nodes in parallel\n    Results = query_nodes(Candidates, {find_value, Key}),\n\n    case find_value_in_results(Results) of\n        {ok, Value} ->\n            {ok, Value};\n        not_found ->\n            NewNodes = extract_nodes(Results),\n            NextCandidates = select_closest_unqueried(Key, NewNodes, Queried),\n            iterative_lookup(Key, NextCandidates,\n                           maps:merge(Queried, mark_queried(Candidates)),\n                           Hops + 1)\n    end.\n```\n\n---","ref":"kademlia_dht_architecture.html#4-iterative-lookup-algorithm"},{"type":"extras","title":"Macula-Specific Adaptations - Kademlia DHT Architecture","doc":"","ref":"kademlia_dht_architecture.html#macula-specific-adaptations"},{"type":"extras","title":"1. Realm-Scoped DHT - Kademlia DHT Architecture","doc":"Unlike traditional Kademlia, Macula implements **multi-tenancy via realms**:\n\n- Each realm has its own isolated DHT keyspace\n- Node IDs include realm hash: `sha1(Realm || IP || Port)`\n- Service keys are realm-scoped: `sha1(Realm || ServiceName)`\n- Cross-realm queries are blocked at protocol level\n\n**Example:**\n```erlang\n%% Realm \"macula.arcade\"\nNodeID_A = sha1(\"macula.arcade\" ++ \"192.168.1.10\" ++ \"4433\")\n\n%% Realm \"macula.energy\"\nNodeID_B = sha1(\"macula.energy\" ++ \"192.168.1.10\" ++ \"4433\")\n\n%% Same IP/port, different realms → different DHT partitions\n```","ref":"kademlia_dht_architecture.html#1-realm-scoped-dht"},{"type":"extras","title":"2. Gateway Bootstrap Nodes - Kademlia DHT Architecture","doc":"Traditional Kademlia requires **bootstrap nodes** to join the network. Macula handles this differently:\n\n**Gateway Mode:**\n- Gateways act as well-known bootstrap nodes\n- Published at predictable URLs (e.g., `https://gateway.example.com:4433`)\n- Maintain authoritative registry for their realm\n\n**Edge Peer Mode:**\n- Peers connect to gateway via `MACULA_BOOTSTRAP_REGISTRY` env var\n- Gateway returns `α` closest nodes to peer's ID\n- Peer populates routing table via `FIND_NODE` requests\n\n**No Hardcoded Bootstrap IPs:** Unlike BitTorrent DHT, Macula uses DNS/HTTPS URLs for gateway discovery, making it firewall-friendly.","ref":"kademlia_dht_architecture.html#2-gateway-bootstrap-nodes"},{"type":"extras","title":"3. Service Advertisement TTL - Kademlia DHT Architecture","doc":"Services are stored in the DHT with a **Time-To-Live (TTL)**:\n\n- Default TTL: **5 minutes**\n- Providers re-advertise every **60 seconds** (heartbeat)\n- Expired entries are removed by `macula_advertisement_manager`\n\n**Rationale:** Short TTL ensures stale services don't linger after node crashes, while frequent heartbeats maintain availability.","ref":"kademlia_dht_architecture.html#3-service-advertisement-ttl"},{"type":"extras","title":"4. HTTP/3 Transport Integration - Kademlia DHT Architecture","doc":"Traditional Kademlia uses UDP for RPCs. Macula uses **QUIC (HTTP/3)**:\n\n**Advantages:**\n- Reliable transport (no packet loss issues)\n- Connection multiplexing (multiple RPCs over one connection)\n- TLS 1.3 encryption (secure by default)\n- NAT traversal (QUIC connection migration)\n\n**Message Encoding:**\n```erlang\n%% DHT query wrapped in Macula protocol\n#{\n  type => dht_query,\n  operation => find_value,\n  key => < >,\n  realm => <<\"macula.arcade\">>,\n  from_node_id => < >,\n  timestamp => erlang:system_time(millisecond)\n}\n```\n\n---","ref":"kademlia_dht_architecture.html#4-http-3-transport-integration"},{"type":"extras","title":"Routing Table Maintenance - Kademlia DHT Architecture","doc":"Macula keeps routing tables fresh through **active probing**:","ref":"kademlia_dht_architecture.html#routing-table-maintenance"},{"type":"extras","title":"1. Passive Updates - Kademlia DHT Architecture","doc":"- When receiving any message from node N, refresh N's entry in k-bucket\n- Update last-seen timestamp\n- Move N to tail of LRU list (most recently seen)","ref":"kademlia_dht_architecture.html#1-passive-updates"},{"type":"extras","title":"2. Active Probing - Kademlia DHT Architecture","doc":"- Every **60 seconds**, ping least-recently-seen node in each non-empty bucket\n- If ping fails 3 times consecutively, evict node\n- Backfill bucket via `FIND_NODE` request","ref":"kademlia_dht_architecture.html#2-active-probing"},{"type":"extras","title":"3. Bucket Splitting - Kademlia DHT Architecture","doc":"- When bucket 0 (closest nodes) exceeds `k` entries, split into two buckets\n- Move nodes to new buckets based on refined distance ranges\n- Only split buckets containing own node ID (hot zone)\n\n**Implementation:**\n```erlang\n%% In macula_routing.erl\n-define(REFRESH_INTERVAL, 60000).  %% 60 seconds\n-define(PING_TIMEOUT, 5000).       %% 5 seconds\n-define(MAX_FAILURES, 3).\n\nrefresh_buckets(State) ->\n    lists:foldl(fun refresh_bucket/2, State, State#state.k_buckets).\n\nrefresh_bucket(Bucket, State) ->\n    case get_least_recent_node(Bucket) of\n        undefined -> State;  %% Empty bucket\n        Node ->\n            case ping_node(Node) of\n                pong -> update_node_timestamp(Node, State);\n                timeout -> handle_ping_failure(Node, State)\n            end\n    end.\n```\n\n---","ref":"kademlia_dht_architecture.html#3-bucket-splitting"},{"type":"extras","title":"Performance Characteristics - Kademlia DHT Architecture","doc":"| Metric | Value | Notes |\n|--------|-------|-------|\n| **Lookup Time** | O(log N) hops | N = total nodes in mesh |\n| **Routing Table Size** | O(log N) entries | ~160 buckets × 20 nodes = 3,200 max |\n| **Network Traffic** | O(log N) messages/lookup | α parallel requests per hop |\n| **Storage** | O(k × log N) | Per node, for advertised services |\n| **Convergence** | < 1 second | Typical for 10,000-node network |\n\n**Example (10,000-node network):**\n- Expected hops: `log₂(10,000) ≈ 13.3` → 14 hops max\n- Parallel factor α = 3 → ~5 rounds of queries\n- Average lookup time: `5 rounds × 100ms RTT = 500ms`\n\n---","ref":"kademlia_dht_architecture.html#performance-characteristics"},{"type":"extras","title":"Comparison to Other DHTs - Kademlia DHT Architecture","doc":"| Feature | Kademlia (Macula) | Chord | Pastry |\n|---------|-------------------|-------|--------|\n| **Distance Metric** | XOR (symmetric) | Modular arithmetic | Numeric proximity |\n| **Routing Complexity** | O(log N) | O(log N) | O(log N) |\n| **Lookup Parallelism** | Yes (α = 3) | No (sequential) | Limited |\n| **NAT-Friendly** | ✅ (with HTTP/3) | ❌ | ❌ |\n| **Bootstrap Required** | Optional (gateway) | Yes | Yes |\n| **Self-Organizing** | ✅ | ✅ | ✅ |\n\n---","ref":"kademlia_dht_architecture.html#comparison-to-other-dhts"},{"type":"extras","title":"Future Enhancements - Kademlia DHT Architecture","doc":"","ref":"kademlia_dht_architecture.html#future-enhancements"},{"type":"extras","title":"1. S/Kademlia (Secure Kademlia) - Kademlia DHT Architecture","doc":"- Cryptographic node ID generation (prevent Sybil attacks)\n- Require nodes to solve proof-of-work for ID assignment\n- Disjoint routing paths for redundancy","ref":"kademlia_dht_architecture.html#1-s-kademlia-secure-kademlia"},{"type":"extras","title":"2. DHT Persistence - Kademlia DHT Architecture","doc":"- Store service advertisements in distributed database (e.g., CRDT)\n- Survive network partitions with eventual consistency\n- Reduce re-advertisement overhead","ref":"kademlia_dht_architecture.html#2-dht-persistence"},{"type":"extras","title":"3. Adaptive K-Bucket Sizing - Kademlia DHT Architecture","doc":"- Dynamically adjust `k` based on network churn rate\n- Larger `k` for stable networks (less probing overhead)\n- Smaller `k` for high-churn networks (faster convergence)\n\n---","ref":"kademlia_dht_architecture.html#3-adaptive-k-bucket-sizing"},{"type":"extras","title":"References - Kademlia DHT Architecture","doc":"1. **Kademlia Paper:** [Maymounkov & Mazières (2002)](http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf)\n2. **S/Kademlia:** [Baumgart & Mies (2007)](https://ieeexplore.ieee.org/document/4447808)\n3. **BitTorrent DHT (BEP-0005):** [bittorrent.org/beps/bep_0005.html](http://www.bittorrent.org/beps/bep_0005.html)\n4. **QUIC Protocol:** [RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html)\n5. **Macula Architecture:** `docs/QUIC_TLS_GATEWAY_SETUP.md`\n\n---\n\n**Last Updated:** 2025-11-15\n**Macula Version:** 0.6.0\n**Status:** ✅ Production-ready DHT implementation","ref":"kademlia_dht_architecture.html#references"},{"type":"extras","title":"Peer-Connection Refactoring","doc":"# Peer-Connection Separation: TDD Implementation Plan\n\n**Date:** 2025-11-15\n**Target Version:** 0.6.0\n**Approach:** Option B - Full separation with comprehensive test coverage\n\n---","ref":"peer_connection_separation_plan.html"},{"type":"extras","title":"Executive Summary - Peer-Connection Refactoring","doc":"Split `macula_connection` into two distinct responsibilities:\n1. **`macula_peer`** - High-level mesh participant (pub/sub, RPC, DHT)\n2. **`macula_connection`** - Low-level QUIC transport\n\n**Strategy:** Test-Driven Development with no regression\n\n---","ref":"peer_connection_separation_plan.html#executive-summary"},{"type":"extras","title":"Current Test Coverage - Peer-Connection Refactoring","doc":"","ref":"peer_connection_separation_plan.html#current-test-coverage"},{"type":"extras","title":"Existing Test Files (144 tests total) - Peer-Connection Refactoring","doc":"| Test File | Tests | Coverage |\n|-----------|-------|----------|\n| `macula_connection_error_tests.erl` | 25 | Error handling |\n| `macula_connection_manager_tests.erl` | 25 | QUIC lifecycle |\n| `macula_connection_rpc_tests.erl` | 25 | RPC operations |\n| `macula_connection_pool_tests.erl` | 19 | Connection pooling |\n| `macula_connection_sup_tests.erl` | 15 | Supervision |\n| `macula_connection_protocol_tests.erl` | 14 | Protocol encoding |\n| `macula_connection_tests.erl` | 11 | Facade API |\n| `macula_connection_pubsub_tests.erl` | 10 | Pub/sub operations |\n| `macula_connection_integration_tests.erl` | 0 | Integration (empty) |\n| `macula_connection_pattern_qos_tests.erl` | 0 | QoS patterns (empty) |\n\n**Total:** 144 test functions across 10 files\n\n---","ref":"peer_connection_separation_plan.html#existing-test-files-144-tests-total"},{"type":"extras","title":"Target Architecture - Peer-Connection Refactoring","doc":"","ref":"peer_connection_separation_plan.html#target-architecture"},{"type":"extras","title":"macula_peer.erl - Mesh Participant API - Peer-Connection Refactoring","doc":"**Responsibilities:**\n- Mesh-level operations (pub/sub, RPC, service discovery)\n- DHT participation and peer discovery\n- Peer identity management (node ID, realm)\n- Application-facing high-level API\n\n**API:**\n```erlang\n%% Lifecycle\n-spec start_link(PeerOpts :: map()) -> {ok, pid()} | {error, term()}.\n-spec stop(Peer :: pid()) -> ok.\n-spec get_info(Peer :: pid()) -> #{node_id => binary(), realm => binary(), status => atom()}.\n\n%% Pub/Sub (mesh-level)\n-spec publish(Peer :: pid(), Topic :: binary(), Data :: term()) -> ok | {error, term()}.\n-spec publish(Peer :: pid(), Topic :: binary(), Data :: term(), Opts :: map()) -> ok | {error, term()}.\n-spec subscribe(Peer :: pid(), Topic :: binary(), Callback :: fun()) -> {ok, reference()} | {error, term()}.\n-spec unsubscribe(Peer :: pid(), SubRef :: reference()) -> ok | {error, term()}.\n\n%% RPC (mesh-level)\n-spec call(Peer :: pid(), Procedure :: binary(), Args :: term()) -> {ok, term()} | {error, term()}.\n-spec call(Peer :: pid(), Procedure :: binary(), Args :: term(), Opts :: map()) -> {ok, term()} | {error, term()}.\n-spec advertise(Peer :: pid(), Procedure :: binary(), Handler :: fun(), Opts :: map()) -> ok | {error, term()}.\n-spec unadvertise(Peer :: pid(), Procedure :: binary()) -> ok | {error, term()}.\n\n%% DHT/Mesh Operations\n-spec discover_peers(Peer :: pid(), Realm :: binary()) -> {ok, [peer_info()]} | {error, term()}.\n-spec find_service(Peer :: pid(), Service :: binary()) -> {ok, [endpoint()]} | {error, term()}.\n```\n\n**State:**\n```erlang\n-record(peer_state, {\n    node_id :: binary(),\n    realm :: binary(),\n    status :: connecting | connected | disconnected,\n\n    %% Child process PIDs\n    connection_pid :: pid() | undefined,      %% macula_connection\n    pubsub_handler_pid :: pid() | undefined,  %% macula_pubsub_handler\n    rpc_handler_pid :: pid() | undefined,     %% macula_rpc_handler\n    advertisement_manager_pid :: pid() | undefined,  %% macula_advertisement_manager\n\n    %% Mesh-level state\n    subscriptions :: #{reference() => subscription()},\n    advertised_services :: #{binary() => handler()}\n}).\n```\n\n---","ref":"peer_connection_separation_plan.html#macula_peer-erl-mesh-participant-api"},{"type":"extras","title":"macula_connection.erl - QUIC Transport Layer - Peer-Connection Refactoring","doc":"**Responsibilities:**\n- QUIC connection establishment and lifecycle\n- Stream management (send/receive)\n- Message encoding/decoding\n- Reconnection and error handling\n- Transport-level concerns ONLY\n\n**API:**\n```erlang\n%% Lifecycle\n-spec start_link(ConnectionOpts :: map()) -> {ok, pid()} | {error, term()}.\n-spec stop(Connection :: pid()) -> ok.\n-spec get_status(Connection :: pid()) -> connecting | connected | disconnected | error.\n\n%% Transport operations\n-spec send(Connection :: pid(), Message :: binary()) -> ok | {error, term()}.\n-spec send_message(Connection :: pid(), Type :: atom(), Data :: map()) -> ok | {error, term()}.\n\n%% Stream management\n-spec get_stream_info(Connection :: pid()) -> #{stream_id => integer(), bytes_sent => integer()}.\n\n%% Callbacks (for receiving data)\n-spec set_message_handler(Connection :: pid(), Handler :: pid()) -> ok.\n```\n\n**State:**\n```erlang\n-record(connection_state, {\n    url :: binary(),\n    host :: binary(),\n    port :: integer(),\n\n    %% QUIC state\n    connection :: pid() | undefined,  %% quicer connection\n    stream :: pid() | undefined,      %% quicer stream\n    status :: connecting | connected | disconnected | error,\n\n    %% Transport state\n    recv_buffer :: binary(),\n    message_handler :: pid() | undefined,  %% Who to send decoded messages to\n\n    %% Reconnection\n    reconnect_timer :: reference() | undefined,\n    reconnect_attempts :: integer()\n}).\n```\n\n---","ref":"peer_connection_separation_plan.html#macula_connection-erl-quic-transport-layer"},{"type":"extras","title":"Implementation Phases - Peer-Connection Refactoring","doc":"","ref":"peer_connection_separation_plan.html#implementation-phases"},{"type":"extras","title":"Phase 1: Test Coverage Analysis ✅ (COMPLETED) - Peer-Connection Refactoring","doc":"**Tasks:**\n- [x] Identify all existing test files\n- [x] Count test functions per file\n- [x] Map tests to responsibilities (peer vs connection)\n\n**Results:**\n- 144 tests across 10 files\n- Need to split into peer tests (pub/sub, RPC, DHT) vs connection tests (QUIC, transport)\n\n---","ref":"peer_connection_separation_plan.html#phase-1-test-coverage-analysis-completed"},{"type":"extras","title":"Phase 2: Design New Architecture (2 days) - Peer-Connection Refactoring","doc":"**Tasks:**\n1. Define `macula_peer` API and behavior specification\n2. Define `macula_connection` API and behavior specification\n3. Design interaction protocol between peer and connection\n4. Design supervision tree structure\n5. Document state management and ownership\n\n**Deliverables:**\n- `docs/macula_peer_specification.md`\n- `docs/macula_connection_specification.md`\n- `docs/peer_connection_interaction_protocol.md`\n\n---","ref":"peer_connection_separation_plan.html#phase-2-design-new-architecture-2-days"},{"type":"extras","title":"Phase 3: Write Peer Tests (3 days) - Peer-Connection Refactoring","doc":"**Test Files to Create:**\n\n#### `test/macula_peer_tests.erl` - Core peer functionality\n```erlang\n%% Lifecycle tests\npeer_start_link_test() -> ...\npeer_stop_test() -> ...\npeer_get_info_test() -> ...\n\n%% State management\npeer_tracks_node_id_test() -> ...\npeer_tracks_realm_test() -> ...\npeer_tracks_status_test() -> ...\n\n%% Connection integration\npeer_starts_connection_test() -> ...\npeer_handles_connection_failure_test() -> ...\npeer_reconnects_after_disconnect_test() -> ...\n```\n\n#### `test/macula_peer_pubsub_tests.erl` - Pub/sub operations\n```erlang\n%% Publishing\npeer_publish_simple_test() -> ...\npeer_publish_with_opts_test() -> ...\npeer_publish_while_disconnected_test() -> ...\npeer_publish_queues_when_connecting_test() -> ...\n\n%% Subscribing\npeer_subscribe_test() -> ...\npeer_unsubscribe_test() -> ...\npeer_receives_published_events_test() -> ...\npeer_wildcard_subscribe_test() -> ...\n\n%% Error handling\npeer_publish_invalid_topic_test() -> ...\npeer_subscribe_callback_error_test() -> ...\n```\n\n#### `test/macula_peer_rpc_tests.erl` - RPC operations\n```erlang\n%% Calling services\npeer_call_simple_test() -> ...\npeer_call_with_timeout_test() -> ...\npeer_call_nonexistent_service_test() -> ...\npeer_call_multiple_providers_test() -> ...\n\n%% Advertising services\npeer_advertise_test() -> ...\npeer_unadvertise_test() -> ...\npeer_handler_receives_call_test() -> ...\npeer_handler_returns_result_test() -> ...\n\n%% Failover\npeer_call_failover_on_timeout_test() -> ...\npeer_call_failover_on_error_test() -> ...\n```\n\n#### `test/macula_peer_dht_tests.erl` - DHT and discovery\n```erlang\n%% Peer discovery\npeer_discover_peers_test() -> ...\npeer_discover_peers_in_realm_test() -> ...\npeer_discover_peers_empty_test() -> ...\n\n%% Service discovery\npeer_find_service_test() -> ...\npeer_find_service_multiple_providers_test() -> ...\npeer_find_service_not_found_test() -> ...\n\n%% DHT operations\npeer_dht_query_test() -> ...\npeer_dht_store_test() -> ...\n```\n\n**Estimated Tests:** ~60-70 new tests\n\n---","ref":"peer_connection_separation_plan.html#phase-3-write-peer-tests-3-days"},{"type":"extras","title":"Phase 4: Write Connection Tests (2 days) - Peer-Connection Refactoring","doc":"**Test Files to Create:**\n\n#### `test/macula_connection_tests.erl` - Core transport\n```erlang\n%% Lifecycle\nconnection_start_link_test() -> ...\nconnection_stop_test() -> ...\nconnection_get_status_test() -> ...\n\n%% QUIC connection\nconnection_establishes_quic_test() -> ...\nconnection_creates_stream_test() -> ...\nconnection_handles_connection_failure_test() -> ...\n\n%% Reconnection\nconnection_reconnects_on_disconnect_test() -> ...\nconnection_backs_off_on_repeated_failures_test() -> ...\nconnection_max_reconnect_attempts_test() -> ...\n```\n\n#### `test/macula_connection_send_tests.erl` - Sending messages\n```erlang\n%% Send operations\nconnection_send_binary_test() -> ...\nconnection_send_message_test() -> ...\nconnection_send_while_connecting_test() -> ...\nconnection_send_while_disconnected_test() -> ...\n\n%% Encoding\nconnection_encodes_message_type_test() -> ...\nconnection_encodes_message_data_test() -> ...\nconnection_handles_encoding_error_test() -> ...\n```\n\n#### `test/macula_connection_receive_tests.erl` - Receiving messages\n```erlang\n%% Receive operations\nconnection_receives_data_test() -> ...\nconnection_decodes_messages_test() -> ...\nconnection_handles_partial_messages_test() -> ...\nconnection_forwards_to_handler_test() -> ...\n\n%% Buffering\nconnection_buffers_incomplete_messages_test() -> ...\nconnection_clears_buffer_on_reconnect_test() -> ...\n```\n\n**Estimated Tests:** ~40-50 new tests\n\n---","ref":"peer_connection_separation_plan.html#phase-4-write-connection-tests-2-days"},{"type":"extras","title":"Phase 5: Implement macula_connection (TDD) (4 days) - Peer-Connection Refactoring","doc":"**Approach:**\n1. Write tests first (Red)\n2. Implement minimal code to pass (Green)\n3. Refactor for idiomatic Erlang (Refactor)\n4. Repeat\n\n**Sub-tasks:**\n- Day 1: Lifecycle and QUIC connection setup\n- Day 2: Send operations and encoding\n- Day 3: Receive operations and decoding\n- Day 4: Reconnection logic and error handling\n\n**Success Criteria:**\n- All connection tests passing\n- No direct mesh logic in connection module\n- Clean transport abstraction\n\n---","ref":"peer_connection_separation_plan.html#phase-5-implement-macula_connection-tdd-4-days"},{"type":"extras","title":"Phase 6: Implement macula_peer (TDD) (5 days) - Peer-Connection Refactoring","doc":"**Approach:** Same TDD cycle\n\n**Sub-tasks:**\n- Day 1: Lifecycle and peer identity\n- Day 2: Pub/sub operations (uses macula_pubsub_handler)\n- Day 3: RPC operations (uses macula_rpc_handler)\n- Day 4: DHT and service discovery\n- Day 5: Error handling and edge cases\n\n**Success Criteria:**\n- All peer tests passing\n- Clean delegation to connection layer\n- No transport logic in peer module\n\n---","ref":"peer_connection_separation_plan.html#phase-6-implement-macula_peer-tdd-5-days"},{"type":"extras","title":"Phase 7: Integration and Migration (3 days) - Peer-Connection Refactoring","doc":"**Tasks:**\n1. Update all references from old `macula_connection` to new modules\n2. Create backward-compatible wrapper (optional)\n3. Update supervision trees\n4. Update documentation\n5. Update examples and demos\n\n**Migration Script:**\n```bash\n#!/bin/bash\n# scripts/migrate-to-peer-connection.sh\n\n# Rename test files\nmv test/macula_connection_tests.erl test/macula_peer_facade_tests.erl\nmv test/macula_connection_manager_tests.erl test/macula_connection_tests.erl\n\n# Update references in source files\nfind src -name \"*.erl\" -exec sed -i 's/macula_connection:start_link/macula_peer:start_link/g' {} \\;\nfind src -name \"*.erl\" -exec sed -i 's/macula_connection:publish/macula_peer:publish/g' {} \\;\n# ... (complete list of API replacements)\n\n# Update test references\nfind test -name \"*.erl\" -exec sed -i 's/macula_connection:start_link/macula_peer:start_link/g' {} \\;\n```\n\n---","ref":"peer_connection_separation_plan.html#phase-7-integration-and-migration-3-days"},{"type":"extras","title":"Phase 8: Testing and Validation (2 days) - Peer-Connection Refactoring","doc":"**Test Levels:**\n\n1. **Unit Tests:**\n   - All macula_peer tests passing (60-70 tests)\n   - All macula_connection tests passing (40-50 tests)\n   - All existing tests still passing (144 tests)\n\n2. **Integration Tests:**\n   - Multi-node pub/sub test\n   - Multi-node RPC test\n   - Service discovery test\n   - Reconnection scenario test\n\n3. **Regression Tests:**\n   - Run full eunit suite\n   - Run integration tests\n   - Test macula-arcade compatibility\n\n**Success Criteria:**\n- 100% of existing tests passing\n- 100% of new tests passing\n- No performance degradation\n- Clean separation of concerns\n\n---","ref":"peer_connection_separation_plan.html#phase-8-testing-and-validation-2-days"},{"type":"extras","title":"Timeline - Peer-Connection Refactoring","doc":"| Phase | Duration | Status |\n|-------|----------|--------|\n| 1. Test Coverage Analysis | 0.5 days | ✅ COMPLETED |\n| 2. Design New Architecture | 2 days | 📋 PENDING |\n| 3. Write Peer Tests | 3 days | 📋 PENDING |\n| 4. Write Connection Tests | 2 days | 📋 PENDING |\n| 5. Implement macula_connection (TDD) | 4 days | 📋 PENDING |\n| 6. Implement macula_peer (TDD) | 5 days | 📋 PENDING |\n| 7. Integration and Migration | 3 days | 📋 PENDING |\n| 8. Testing and Validation | 2 days | 📋 PENDING |\n| **TOTAL** | **21.5 days** (~4.5 weeks) | |\n\n---","ref":"peer_connection_separation_plan.html#timeline"},{"type":"extras","title":"Risk Mitigation - Peer-Connection Refactoring","doc":"","ref":"peer_connection_separation_plan.html#risk-mitigation"},{"type":"extras","title":"Risk 1: Breaking Existing Functionality - Peer-Connection Refactoring","doc":"**Mitigation:**\n- Keep all existing tests\n- Run tests after each phase\n- Create backward-compatible wrapper if needed","ref":"peer_connection_separation_plan.html#risk-1-breaking-existing-functionality"},{"type":"extras","title":"Risk 2: State Management Complexity - Peer-Connection Refactoring","doc":"**Mitigation:**\n- Design state ownership upfront\n- Document interaction protocol\n- Use well-defined message passing","ref":"peer_connection_separation_plan.html#risk-2-state-management-complexity"},{"type":"extras","title":"Risk 3: Performance Degradation - Peer-Connection Refactoring","doc":"**Mitigation:**\n- Benchmark before and after\n- Profile message passing overhead\n- Optimize hot paths","ref":"peer_connection_separation_plan.html#risk-3-performance-degradation"},{"type":"extras","title":"Risk 4: Timeline Overrun - Peer-Connection Refactoring","doc":"**Mitigation:**\n- Daily progress tracking\n- Adjust scope if needed\n- Pair programming for complex areas\n\n---","ref":"peer_connection_separation_plan.html#risk-4-timeline-overrun"},{"type":"extras","title":"Success Metrics - Peer-Connection Refactoring","doc":"","ref":"peer_connection_separation_plan.html#success-metrics"},{"type":"extras","title":"Code Quality - Peer-Connection Refactoring","doc":"- [x] Single Responsibility Principle: Each module has ONE clear purpose\n- [ ] Test Coverage: >90% for new modules\n- [ ] Idiomatic Erlang: Pattern matching, guards, no deep nesting\n- [ ] Documentation: Comprehensive specs and examples","ref":"peer_connection_separation_plan.html#code-quality"},{"type":"extras","title":"Functionality - Peer-Connection Refactoring","doc":"- [ ] All existing features working\n- [ ] Clean API separation\n- [ ] No performance regression\n- [ ] Backward compatibility (via wrapper)","ref":"peer_connection_separation_plan.html#functionality"},{"type":"extras","title":"Architecture - Peer-Connection Refactoring","doc":"- [ ] macula_peer = mesh logic only\n- [ ] macula_connection = transport only\n- [ ] Clear interface contract\n- [ ] Easy to extend/modify\n\n---","ref":"peer_connection_separation_plan.html#architecture"},{"type":"extras","title":"Next Steps - Peer-Connection Refactoring","doc":"1. **Get approval** for 4.5-week timeline\n2. **Start Phase 2**: Design specifications\n3. **Daily standup**: Track progress and blockers\n4. **Weekly review**: Adjust timeline if needed\n\n---\n\n**Decision Point:** Proceed with Option B full separation?\n\n**Estimated Completion:** 4.5 weeks from start (around early December 2025)","ref":"peer_connection_separation_plan.html#next-steps"},{"type":"extras","title":"v0.6.0 Release Summary","doc":"# Macula v0.6.0 Release Summary\n\n**Release Date:** 2025-11-15\n**Status:** ✅ Ready for Hex publication\n\n---","ref":"v0-6-0_release_summary.html"},{"type":"extras","title":"What's in v0.6.0 - v0.6.0 Release Summary","doc":"","ref":"v0-6-0_release_summary.html#what-s-in-v0-6-0"},{"type":"extras","title":"Breaking Changes - v0.6.0 Release Summary","doc":"- **Environment Variable Rename:** `GATEWAY_REALM` → `MACULA_REALM`\n  - Consistent naming across all `MACULA_*` environment variables\n  - Applies to both gateway mode and edge peer mode","ref":"v0-6-0_release_summary.html#breaking-changes"},{"type":"extras","title":"Documentation Improvements - v0.6.0 Release Summary","doc":"- **New:** Comprehensive Kademlia DHT Architecture documentation\n  - Location: `docs/KADEMLIA_DHT_ARCHITECTURE.md`\n  - 380 lines covering XOR metrics, k-buckets, DHT operations, and Macula-specific adaptations","ref":"v0-6-0_release_summary.html#documentation-improvements"},{"type":"extras","title":"Migration Path - v0.6.0 Release Summary","doc":"Simple find-and-replace for environment variables:\n\n**Before (v0.5.0):**\n```bash\nexport GATEWAY_REALM=my-app\n```\n\n**After (v0.6.0):**\n```bash\nexport MACULA_REALM=my-app\n```\n\n**Elixir/Phoenix runtime.exs:**\n```elixir\n# Before\nSystem.put_env(\"GATEWAY_REALM\", realm)\n\n# After\nSystem.put_env(\"MACULA_REALM\", realm)\n```\n\n---","ref":"v0-6-0_release_summary.html#migration-path"},{"type":"extras","title":"Pre-Release Checklist - v0.6.0 Release Summary","doc":"","ref":"v0-6-0_release_summary.html#pre-release-checklist"},{"type":"extras","title":"✅ Completed - v0.6.0 Release Summary","doc":"- [x] Version bumped to 0.6.0 in `src/macula.app.src`\n- [x] Version bumped to 0.6.0 in `rebar.config`\n- [x] CHANGELOG.md updated with breaking changes and migration guide\n- [x] All MACULA_REALM references consistent throughout codebase\n- [x] Documentation generated (ex_doc)\n- [x] All tests passing (81 tests, 0 failures)\n- [x] Compilation clean (no warnings)\n- [x] Kademlia DHT documentation added","ref":"v0-6-0_release_summary.html#completed"},{"type":"extras","title":"📋 Next Steps (For User) - v0.6.0 Release Summary","doc":"1. Run publication script: `./scripts/publish-to-hex.sh`\n2. Verify on hex.pm\n3. Update macula-arcade to use v0.6.0\n4. Test Snake game with new version\n\n---","ref":"v0-6-0_release_summary.html#next-steps-for-user"},{"type":"extras","title":"Files Changed in v0.6.0 - v0.6.0 Release Summary","doc":"","ref":"v0-6-0_release_summary.html#files-changed-in-v0-6-0"},{"type":"extras","title":"Version Files - v0.6.0 Release Summary","doc":"- `src/macula.app.src` (line 3: version bump)\n- `rebar.config` (line 68: version bump)","ref":"v0-6-0_release_summary.html#version-files"},{"type":"extras","title":"Environment Variable Updates - v0.6.0 Release Summary","doc":"- `src/macula_sup.erl` (line 125: GATEWAY_REALM → MACULA_REALM)\n- `entrypoint.sh` (lines 11, 17, 27: GATEWAY_REALM → MACULA_REALM)\n- `Dockerfile.gateway` (line 60: ENV variable)\n- `config/sys.config` (line 10: comment update)","ref":"v0-6-0_release_summary.html#environment-variable-updates"},{"type":"extras","title":"Documentation - v0.6.0 Release Summary","doc":"- `docs/QUIC_TLS_GATEWAY_SETUP.md` (added MACULA_REALM examples)\n- `docs/KADEMLIA_DHT_ARCHITECTURE.md` (NEW - 380 lines)\n- `docs/NOMENCLATURE_PROPOSAL_CONNECTION_TO_PEER.md` (NEW - for v0.7.0)\n- `docs/PEER_VS_CONNECTION_ANALYSIS.md` (NEW - for v0.7.0)\n- `docs/PEER_CONNECTION_SEPARATION_PLAN.md` (NEW - for v0.7.0)\n- `CHANGELOG.md` (v0.6.0 entry added)\n\n**Total:** 11 files modified, 4 files created\n\n---","ref":"v0-6-0_release_summary.html#documentation"},{"type":"extras","title":"Test Results - v0.6.0 Release Summary","doc":"```\nCompilation: ✅ Clean (no warnings)\nTests: ✅ 81 tests, 0 failures, 6 cancelled\nDocumentation: ✅ Generated successfully\n```\n\nThe 6 cancelled tests are integration tests requiring external infrastructure (expected behavior).\n\n---","ref":"v0-6-0_release_summary.html#test-results"},{"type":"extras","title":"What's Coming in v0.7.0 - v0.6.0 Release Summary","doc":"","ref":"v0-6-0_release_summary.html#what-s-coming-in-v0-7-0"},{"type":"extras","title":"Planned: Peer-Connection Separation (4.5 weeks) - v0.6.0 Release Summary","doc":"Major architectural improvement to separate concerns:\n\n**`macula_peer` (High-Level Mesh API):**\n- Pub/sub operations\n- RPC calls\n- Service discovery\n- DHT participation\n- Peer identity management\n\n**`macula_connection` (Low-Level QUIC Transport):**\n- QUIC connection lifecycle\n- Stream management\n- Message encoding/decoding\n- Reconnection logic\n\n**Benefits:**\n- Single Responsibility Principle\n- Better testability\n- Future-proof for alternative transports\n- Clearer API separation\n\n**Timeline:** 4-5 weeks TDD implementation\n**Documentation:** See `docs/PEER_CONNECTION_SEPARATION_PLAN.md`\n\n---","ref":"v0-6-0_release_summary.html#planned-peer-connection-separation-4-5-weeks"},{"type":"extras","title":"Package Metadata - v0.6.0 Release Summary","doc":"**Name:** macula\n**Version:** 0.6.0\n**License:** Apache-2.0\n**Description:** Macula HTTP/3 Mesh Platform - Complete distributed application framework\n\n**Dependencies:**\n- quicer: 0.2.15\n- msgpack: 0.8.1\n- gproc: 0.9.1\n\n**Links:**\n- GitHub: https://github.com/macula-io/macula\n- Hex: https://hex.pm/packages/macula (after publication)\n\n---","ref":"v0-6-0_release_summary.html#package-metadata"},{"type":"extras","title":"Publication Commands - v0.6.0 Release Summary","doc":"```bash\n# Run the publish script (handles everything)\n./scripts/publish-to-hex.sh\n\n# Or manual steps:\nrebar3 hex build\nrebar3 hex publish\n```\n\n---","ref":"v0-6-0_release_summary.html#publication-commands"},{"type":"extras","title":"Post-Publication Verification - v0.6.0 Release Summary","doc":"After publishing, verify:\n\n1. **Hex.pm:** Check version appears at https://hex.pm/packages/macula\n2. **Documentation:** Verify docs rendered correctly on hex.pm\n3. **Download Test:** Try installing in a test project\n4. **macula-arcade:** Update dependency to v0.6.0 and test\n\n---\n\n**Status:** ✅ READY FOR PUBLICATION\n\nRun `./scripts/publish-to-hex.sh` when ready!","ref":"v0-6-0_release_summary.html#post-publication-verification"},{"type":"extras","title":"Project Structure","doc":"# Macula HTTP/3 Mesh - Project Structure and Libraries\n\n**Actual Erlang/Elixir projects and libraries to build**\n\n**Created**: 2025-01-08\n**Status**: Planning Document\n\n---","ref":"macula_project_structure.html"},{"type":"extras","title":"Overview - Project Structure","doc":"This document outlines the actual Erlang/Elixir libraries, applications, and projects that need to be created to implement the Macula HTTP/3 Mesh platform.\n\n---","ref":"macula_project_structure.html#overview"},{"type":"extras","title":"Repository Organization Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#repository-organization-strategy"},{"type":"extras","title":"Option A: Monorepo (Recommended for Initial Development) - Project Structure","doc":"```\nmacula/\n├── apps/\n│   ├── macula_core/           # Core protocols and types\n│   ├── macula_quic/           # QUIC transport layer\n│   ├── macula_protocol/       # Wire protocol (framing, encoding)\n│   ├── macula_membership/     # SWIM membership\n│   ├── macula_routing/        # Kademlia DHT routing\n│   ├── macula_topology/       # Mesh topology management\n│   ├── macula_pubsub/         # Pub/sub implementation\n│   ├── macula_rpc/            # RPC implementation\n│   ├── macula_gateway/        # Cross-realm gateway\n│   ├── macula_discovery/      # Node discovery\n│   ├── macula_security/       # Auth, ACLs, certificates\n│   └── macula/                # Main application (umbrella)\n├── rebar.config               # Rebar3 umbrella config\n├── mix.exs                    # Mix umbrella config (if supporting Elixir)\n└── README.md\n```\n\n**Benefits**:\n- Easy cross-library development\n- Shared dependencies\n- Single release\n- Atomic commits across components\n- Simplified CI/CD","ref":"macula_project_structure.html#option-a-monorepo-recommended-for-initial-development"},{"type":"extras","title":"Option B: Multi-repo (For Maturity/Modularity) - Project Structure","doc":"Separate repositories for each library (similar to Erlang/OTP structure).\n\n**Benefits**:\n- Independent versioning\n- Smaller, focused repos\n- Can use different libraries independently\n- Clear boundaries\n\n**Recommendation**: Start with **Option A (monorepo)**, split later if needed.\n\n---","ref":"macula_project_structure.html#option-b-multi-repo-for-maturity-modularity"},{"type":"extras","title":"Core Libraries (Required for MVP) - Project Structure","doc":"","ref":"macula_project_structure.html#core-libraries-required-for-mvp"},{"type":"extras","title":"1. macula_core - Project Structure","doc":"**Purpose**: Core types, protocols, and shared utilities.\n\n**Modules**:\n```erlang\n%% Core types\nmacula_types.erl           - Common type definitions\nmacula_node.erl            - Node identity and metadata\nmacula_realm.erl           - Realm management\nmacula_topic.erl           - Topic parsing and validation\n\n%% Utilities\nmacula_time.erl            - Time utilities\nmacula_id.erl              - ID generation (SHA-256 node IDs)\nmacula_uri.erl             - Macula URI parsing (macula://realm/node)\n```\n\n**Dependencies**: None (pure Erlang)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_core, [\n    {description, \"Macula core types and protocols\"},\n    {vsn, \"0.1.0\"},\n    {modules, []},\n    {registered, []},\n    {applications, [kernel, stdlib]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#1-macula_core"},{"type":"extras","title":"2. macula_quic - Project Structure","doc":"**Purpose**: QUIC transport layer (wrapper around quicer).\n\n**Modules**:\n```erlang\nmacula_quic_listener.erl   - QUIC listener (accept connections)\nmacula_quic_client.erl     - QUIC client (initiate connections)\nmacula_quic_connection.erl - GenServer per QUIC connection\nmacula_quic_stream.erl     - Stream management\nmacula_quic_config.erl     - QUIC configuration (TLS, ALPN, etc.)\n```\n\n**Dependencies**:\n- `quicer` (NIF for MsQuic)\n\n**Key Features**:\n- Connection pooling\n- Stream multiplexing\n- 0-RTT support\n- Connection migration\n- Backpressure handling\n\n**Rebar3 Config**:\n```erlang\n{application, macula_quic, [\n    {description, \"Macula QUIC transport layer\"},\n    {vsn, \"0.1.0\"},\n    {modules, []},\n    {registered, []},\n    {applications, [kernel, stdlib, macula_core, quicer]},\n    {mod, {macula_quic_app, []}}\n]}.\n\n{deps, [\n    {quicer, {git, \"https://github.com/emqx/quic.git\", {branch, \"main\"}}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#2-macula_quic"},{"type":"extras","title":"3. macula_protocol - Project Structure","doc":"**Purpose**: Wire protocol (message framing, encoding/decoding).\n\n**Modules**:\n```erlang\nmacula_protocol.erl        - Main protocol API\nmacula_frame.erl           - Frame encoding/decoding\nmacula_message.erl         - Message types and validation\nmacula_codec.erl           - Binary serialization (Erlang term format or MessagePack)\n```\n\n**Message Types**:\n```erlang\n-define(MSG_HANDSHAKE, 16#01).\n-define(MSG_HANDSHAKE_ACK, 16#02).\n-define(MSG_HEARTBEAT, 16#03).\n-define(MSG_PING, 16#04).\n-define(MSG_PONG, 16#05).\n-define(MSG_PUBLISH, 16#10).\n-define(MSG_SUBSCRIBE, 16#11).\n-define(MSG_UNSUBSCRIBE, 16#12).\n-define(MSG_EVENT, 16#13).\n-define(MSG_RPC_CALL, 16#20).\n-define(MSG_RPC_RESULT, 16#21).\n-define(MSG_RPC_ERROR, 16#22).\n-define(MSG_ERROR, 16#F0).\n-define(MSG_CLOSE, 16#FF).\n```\n\n**Dependencies**:\n- `macula_core`\n\n**Optional Dependencies**:\n- `msgpack` (if using MessagePack instead of Erlang term format)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_protocol, [\n    {description, \"Macula wire protocol\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#3-macula_protocol"},{"type":"extras","title":"4. macula_membership - Project Structure","doc":"**Purpose**: SWIM-based membership and failure detection.\n\n**Modules**:\n```erlang\nmacula_membership.erl      - Main membership API\nmacula_swim.erl            - SWIM protocol GenServer\nmacula_swim_detector.erl   - Failure detector\nmacula_swim_gossip.erl     - Gossip dissemination\nmacula_member.erl          - Member record and state\n```\n\n**Features**:\n- Membership list management\n- Direct ping / indirect ping\n- Suspicion mechanism\n- Incarnation numbers\n- Realm-scoped membership\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_quic`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_membership, [\n    {description, \"Macula SWIM membership\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol, macula_quic]},\n    {mod, {macula_membership_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#4-macula_membership"},{"type":"extras","title":"5. macula_routing - Project Structure","doc":"**Purpose**: Kademlia DHT for routing.\n\n**Modules**:\n```erlang\nmacula_routing.erl         - Routing API\nmacula_kademlia.erl        - Kademlia DHT GenServer\nmacula_k_bucket.erl        - K-bucket management\nmacula_node_lookup.erl     - Node lookup (iterative)\nmacula_topic_registry.erl  - Topic → Nodes mapping (for pub/sub)\nmacula_rpc_registry.erl    - RPC name → Node mapping\n```\n\n**Features**:\n- 256 k-buckets (for 256-bit node IDs)\n- XOR distance metric\n- Iterative lookups\n- Bucket refresh\n- Realm partitioning\n\n**Dependencies**:\n- `macula_core`\n- `macula_membership`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_routing, [\n    {description, \"Macula Kademlia DHT routing\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_membership]},\n    {mod, {macula_routing_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#5-macula_routing"},{"type":"extras","title":"6. macula_topology - Project Structure","doc":"**Purpose**: Mesh topology management (k-regular graph).\n\n**Modules**:\n```erlang\nmacula_topology.erl        - Topology management\nmacula_k_regular.erl       - k-regular graph algorithm\nmacula_connection_pool.erl - Connection pool supervisor\nmacula_connection.erl      - GenServer per peer connection\n```\n\n**Features**:\n- k-regular graph topology\n- Connection lifecycle (connect, disconnect, reconnect)\n- Exponential backoff for reconnections\n- Topology visualization\n\n**Dependencies**:\n- `macula_core`\n- `macula_quic`\n- `macula_membership`\n- `macula_routing`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_topology, [\n    {description, \"Macula mesh topology management\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_quic,\n                    macula_membership, macula_routing]},\n    {mod, {macula_topology_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#6-macula_topology"},{"type":"extras","title":"7. macula_pubsub - Project Structure","doc":"**Purpose**: Publish/subscribe messaging.\n\n**Modules**:\n```erlang\nmacula_pubsub.erl          - Pub/sub API\nmacula_topic_tree.erl      - Topic subscription tree (pattern matching)\nmacula_subscription.erl    - Subscription management\nmacula_publisher.erl       - Publishing logic\nmacula_event_router.erl    - Event routing to subscribers\n```\n\n**Features**:\n- Topic pattern matching (exact, prefix, wildcard)\n- Local and remote subscriptions\n- Subscription announcements (via DHT)\n- Event delivery guarantees (at-most-once, at-least-once)\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_routing`\n- `macula_topology`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_pubsub, [\n    {description, \"Macula pub/sub messaging\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_routing, macula_topology]},\n    {mod, {macula_pubsub_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#7-macula_pubsub"},{"type":"extras","title":"8. macula_rpc - Project Structure","doc":"**Purpose**: Remote procedure call (RPC) implementation.\n\n**Modules**:\n```erlang\nmacula_rpc.erl             - RPC API (call, register, unregister)\nmacula_rpc_server.erl      - RPC request handler\nmacula_rpc_client.erl      - RPC call client\nmacula_rpc_registry.erl    - Local RPC endpoint registry\n```\n\n**Features**:\n- Synchronous RPC (with timeout)\n- Asynchronous RPC (cast)\n- RPC endpoint registration (name → handler function)\n- Endpoint discovery via DHT\n- Load balancing (if multiple nodes register same RPC)\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_routing`\n- `macula_topology`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_rpc, [\n    {description, \"Macula RPC\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_routing, macula_topology]},\n    {mod, {macula_rpc_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#8-macula_rpc"},{"type":"extras","title":"9. macula_discovery - Project Structure","doc":"**Purpose**: Node discovery (DNS-SD, mDNS, static, cloud).\n\n**Modules**:\n```erlang\nmacula_discovery.erl       - Discovery coordinator\nmacula_discovery_static.erl - Static bootstrap nodes\nmacula_discovery_mdns.erl  - mDNS (Multicast DNS)\nmacula_discovery_dns.erl   - DNS SRV records\nmacula_discovery_consul.erl - Consul service discovery\nmacula_discovery_k8s.erl   - Kubernetes endpoints\n```\n\n**Features**:\n- Multiple discovery methods (configurable)\n- Continuous discovery (periodic re-discovery)\n- Bootstrap node list\n- Realm-aware discovery\n\n**Dependencies**:\n- `macula_core`\n- `mdns` (for mDNS support)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_discovery, [\n    {description, \"Macula node discovery\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core]},\n    {mod, {macula_discovery_app, []}}\n]}.\n\n{deps, [\n    {mdns, {git, \"https://github.com/benoitc/erlang-mdns.git\", {branch, \"master\"}}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#9-macula_discovery"},{"type":"extras","title":"10. macula_security - Project Structure","doc":"**Purpose**: Security (TLS certificates, ACLs, audit logging).\n\n**Modules**:\n```erlang\nmacula_security.erl        - Security API\nmacula_cert.erl            - Certificate generation and validation\nmacula_acl.erl             - Access control lists\nmacula_audit.erl           - Audit logging\nmacula_crypto.erl          - Message signing/verification\n```\n\n**Features**:\n- Certificate generation (self-signed, CA-signed)\n- Certificate validation (realm extraction from SAN)\n- ACL enforcement (topic/RPC access control)\n- Audit log (security events)\n- Optional message signing\n\n**Dependencies**:\n- `macula_core`\n- `public_key` (Erlang stdlib)\n- `ssl` (Erlang stdlib)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_security, [\n    {description, \"Macula security\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, public_key, ssl, macula_core]},\n    {mod, {macula_security_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#10-macula_security"},{"type":"extras","title":"11. macula_gateway - Project Structure","doc":"**Purpose**: Cross-realm gateway functionality.\n\n**Modules**:\n```erlang\nmacula_gateway.erl         - Gateway API\nmacula_gateway_server.erl  - Gateway GenServer\nmacula_policy.erl          - Policy engine (topic filtering, rate limiting)\nmacula_translation.erl     - Topic translation\nmacula_rate_limiter.erl    - Rate limiting per realm pair\n```\n\n**Features**:\n- Multi-realm support\n- Policy-based message filtering\n- Topic translation\n- Rate limiting\n- Audit logging of cross-realm traffic\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_pubsub`\n- `macula_rpc`\n- `macula_security`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_gateway, [\n    {description, \"Macula cross-realm gateway\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_pubsub, macula_rpc, macula_security]},\n    {mod, {macula_gateway_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#11-macula_gateway"},{"type":"extras","title":"12. macula (Main Application) - Project Structure","doc":"**Purpose**: Umbrella application that ties everything together.\n\n**Modules**:\n```erlang\nmacula.erl                 - Main API\nmacula_app.erl             - Application callback\nmacula_sup.erl             - Top-level supervisor\nmacula_config.erl          - Configuration management\n```\n\n**Supervision Tree**:\n```erlang\nmacula_sup (one_for_one)\n├── macula_discovery_sup\n├── macula_quic_sup\n├── macula_membership_sup\n├── macula_routing_sup\n├── macula_topology_sup\n├── macula_pubsub_sup\n├── macula_rpc_sup\n├── macula_security_sup\n└── macula_gateway_sup (optional, if gateway mode)\n```\n\n**Dependencies**: All macula_* libraries\n\n**Rebar3 Config**:\n```erlang\n{application, macula, [\n    {description, \"Macula HTTP/3 Mesh Platform\"},\n    {vsn, \"0.1.0\"},\n    {applications, [\n        kernel, stdlib,\n        macula_core,\n        macula_quic,\n        macula_protocol,\n        macula_membership,\n        macula_routing,\n        macula_topology,\n        macula_pubsub,\n        macula_rpc,\n        macula_discovery,\n        macula_security,\n        macula_gateway\n    ]},\n    {mod, {macula_app, []}},\n    {env, [\n        {realm, <<\"org.example.mesh\">>},\n        {listen_port, 4433},\n        {discovery, [{methods, [static, mdns]}]},\n        {topology, [{type, k_regular}, {k, 2}]}\n    ]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#12-macula-main-application"},{"type":"extras","title":"Supporting Tools and Utilities - Project Structure","doc":"","ref":"macula_project_structure.html#supporting-tools-and-utilities"},{"type":"extras","title":"13. macula_cli - Project Structure","doc":"**Purpose**: Command-line tool for Macula operations.\n\n**Features**:\n- Start/stop nodes\n- Join mesh\n- View topology\n- Send test messages\n- Query membership\n- Inspect routing table\n\n**Implementation**: Escript\n\n**Rebar3 Config**:\n```erlang\n{escript_name, macula}.\n{escript_emu_args, \"%%! -escript main macula_cli\\n\"}.\n```\n\n**Usage**:\n```bash\nmacula start --realm org.example.mesh --port 4433\nmacula join 192.168.1.100:4433\nmacula topology\nmacula publish topic.name '{\"data\": \"hello\"}'\nmacula stats\n```\n\n---","ref":"macula_project_structure.html#13-macula_cli"},{"type":"extras","title":"14. macula_observer - Project Structure","doc":"**Purpose**: Real-time mesh visualization and monitoring.\n\n**Features**:\n- Visual mesh topology (graphviz-style)\n- Live message flow\n- Membership state\n- Connection status\n- Metrics dashboard\n\n**Implementation**: Phoenix LiveView application (if using Elixir)\n\n**Alternative**: Standalone Erlang application with web UI (Cowboy + WebSocket)\n\n---","ref":"macula_project_structure.html#14-macula_observer"},{"type":"extras","title":"15. macula_loadtest - Project Structure","doc":"**Purpose**: Load testing and benchmarking tool.\n\n**Features**:\n- Spawn N virtual nodes\n- Pub/sub throughput testing\n- RPC latency testing\n- Failure injection\n- Report generation\n\n**Implementation**: Standalone Erlang application using Tsung or custom framework\n\n---","ref":"macula_project_structure.html#15-macula_loadtest"},{"type":"extras","title":"Optional/Future Libraries - Project Structure","doc":"","ref":"macula_project_structure.html#optional-future-libraries"},{"type":"extras","title":"16. macula_wamp_compat - Project Structure","doc":"**Purpose**: WAMP compatibility layer (bridge WAMP clients to Macula).\n\n**Modules**:\n- WAMP protocol adapter\n- WebSocket server\n- Message translation (WAMP ↔ Macula)\n\n**Use Case**: Migrate from Bondy/WAMP to Macula gradually\n\n---","ref":"macula_project_structure.html#16-macula_wamp_compat"},{"type":"extras","title":"17. macula_http_bridge - Project Structure","doc":"**Purpose**: HTTP/REST gateway for Macula (publish via HTTP POST).\n\n**Modules**:\n- Cowboy HTTP handler\n- REST API (publish, call, subscribe via SSE)\n\n**Use Case**: Non-BEAM clients accessing Macula\n\n---","ref":"macula_project_structure.html#17-macula_http_bridge"},{"type":"extras","title":"18. macula_kafka_connector - Project Structure","doc":"**Purpose**: Kafka bridge (publish Macula events to Kafka, consume Kafka events).\n\n**Dependencies**: `brod` (Kafka client)\n\n---","ref":"macula_project_structure.html#18-macula_kafka_connector"},{"type":"extras","title":"19. macula_postgres_connector - Project Structure","doc":"**Purpose**: PostgreSQL integration (CDC, event sourcing).\n\n**Dependencies**: `epgsql` or `postgrex`\n\n---","ref":"macula_project_structure.html#19-macula_postgres_connector"},{"type":"extras","title":"20. macula_metrics - Project Structure","doc":"**Purpose**: Metrics and observability (Prometheus, OpenTelemetry).\n\n**Modules**:\n- Prometheus exporter\n- OpenTelemetry integration\n- StatsD reporter\n\n**Dependencies**:\n- `prometheus` or `prometheus_ex`\n- `opentelemetry` and `opentelemetry_exporter`\n\n---","ref":"macula_project_structure.html#20-macula_metrics"},{"type":"extras","title":"Development Roadmap - Project Structure","doc":"","ref":"macula_project_structure.html#development-roadmap"},{"type":"extras","title":"Phase 1: Foundation (Weeks 1-4) - Project Structure","doc":"**Goal**: Get basic QUIC transport and protocol working.\n\n**Libraries to build**:\n1. `macula_core` - Types and utilities\n2. `macula_quic` - QUIC wrapper\n3. `macula_protocol` - Wire protocol\n\n**Deliverable**: Two nodes can connect and exchange handshake messages.\n\n---","ref":"macula_project_structure.html#phase-1-foundation-weeks-1-4"},{"type":"extras","title":"Phase 2: Mesh Topology (Weeks 5-8) - Project Structure","doc":"**Goal**: Self-organizing mesh network.\n\n**Libraries to build**:\n4. `macula_membership` - SWIM\n5. `macula_routing` - Kademlia DHT\n6. `macula_topology` - k-regular graph\n7. `macula_discovery` - Node discovery\n\n**Deliverable**: N nodes form a mesh and detect failures.\n\n---","ref":"macula_project_structure.html#phase-2-mesh-topology-weeks-5-8"},{"type":"extras","title":"Phase 3: Messaging (Weeks 9-12) - Project Structure","doc":"**Goal**: Pub/sub and RPC working across mesh.\n\n**Libraries to build**:\n8. `macula_pubsub` - Pub/sub\n9. `macula_rpc` - RPC\n\n**Deliverable**: Applications can publish/subscribe and make RPC calls.\n\n---","ref":"macula_project_structure.html#phase-3-messaging-weeks-9-12"},{"type":"extras","title":"Phase 4: Security and Gateways (Weeks 13-16) - Project Structure","doc":"**Goal**: Production-ready security and multi-tenancy.\n\n**Libraries to build**:\n10. `macula_security` - Certificates, ACLs, audit\n11. `macula_gateway` - Cross-realm gateway\n\n**Deliverable**: Secure mesh with realm isolation.\n\n---","ref":"macula_project_structure.html#phase-4-security-and-gateways-weeks-13-16"},{"type":"extras","title":"Phase 5: Tooling and Monitoring (Weeks 17-20) - Project Structure","doc":"**Goal**: Developer experience and operations tooling.\n\n**Tools to build**:\n13. `macula_cli` - Command-line tool\n14. `macula_observer` - Visualization\n15. `macula_loadtest` - Benchmarking\n20. `macula_metrics` - Observability\n\n**Deliverable**: Production-ready platform with tooling.\n\n---","ref":"macula_project_structure.html#phase-5-tooling-and-monitoring-weeks-17-20"},{"type":"extras","title":"Testing Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#testing-strategy"},{"type":"extras","title":"Unit Tests - Project Structure","doc":"Each library has its own test suite:\n```\napps/macula_core/test/\napps/macula_quic/test/\napps/macula_protocol/test/\n...\n```\n\n**Framework**: EUnit (Erlang) or ExUnit (Elixir)\n\n**Run**:\n```bash\nrebar3 eunit\n# or\nmix test\n```\n\n---","ref":"macula_project_structure.html#unit-tests"},{"type":"extras","title":"Integration Tests - Project Structure","doc":"Multi-node integration tests:\n```\ntest/integration/\n├── mesh_formation_test.erl\n├── pubsub_test.erl\n├── rpc_test.erl\n├── failure_recovery_test.erl\n└── gateway_test.erl\n```\n\n**Framework**: Common Test (Erlang)\n\n**Run**:\n```bash\nrebar3 ct\n```\n\n---","ref":"macula_project_structure.html#integration-tests"},{"type":"extras","title":"Property-Based Tests - Project Structure","doc":"Use PropEr (Erlang) or StreamData (Elixir):\n```\napps/macula_routing/test/prop_kademlia.erl\napps/macula_membership/test/prop_swim.erl\n```\n\n**Run**:\n```bash\nrebar3 proper\n```\n\n---","ref":"macula_project_structure.html#property-based-tests"},{"type":"extras","title":"Load Tests - Project Structure","doc":"Separate load testing suite:\n```\nloadtest/\n├── pubsub_throughput.erl\n├── rpc_latency.erl\n├── mesh_scale.erl (1000+ nodes)\n└── failure_injection.erl\n```\n\n**Framework**: Tsung or custom\n\n---","ref":"macula_project_structure.html#load-tests"},{"type":"extras","title":"Continuous Integration - Project Structure","doc":"","ref":"macula_project_structure.html#continuous-integration"},{"type":"extras","title":"GitHub Actions Workflow - Project Structure","doc":"```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: erlef/setup-beam@v1\n        with:\n          otp-version: '26.2'\n          rebar3-version: '3.22'\n      - run: rebar3 compile\n      - run: rebar3 eunit\n      - run: rebar3 ct\n      - run: rebar3 dialyzer\n\n  integration:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: erlef/setup-beam@v1\n      - run: rebar3 as test release\n      - run: ./test/integration/run_all.sh\n```\n\n---","ref":"macula_project_structure.html#github-actions-workflow"},{"type":"extras","title":"Release Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#release-strategy"},{"type":"extras","title":"Rebar3 Release - Project Structure","doc":"```erlang\n%% rebar.config\n{relx, [\n    {release, {macula, \"0.1.0\"}, [\n        macula,\n        sasl\n    ]},\n\n    {mode, prod},\n    {include_erts, true},\n    {extended_start_script, true},\n\n    {overlay, [\n        {copy, \"config/sys.config.example\", \"etc/sys.config\"},\n        {copy, \"config/vm.args.example\", \"etc/vm.args\"}\n    ]}\n]}.\n```\n\n**Build**:\n```bash\nrebar3 release\n```\n\n**Result**: `_build/default/rel/macula/`\n\n---","ref":"macula_project_structure.html#rebar3-release"},{"type":"extras","title":"Docker Image - Project Structure","doc":"```dockerfile\nFROM erlang:26-alpine AS builder\n\nWORKDIR /build\nCOPY . .\nRUN rebar3 as prod release\n\nFROM alpine:latest\n\nRUN apk add --no-cache openssl ncurses-libs libstdc++\n\nCOPY --from=builder /build/_build/prod/rel/macula /opt/macula\n\nEXPOSE 4433/udp\n\nCMD [\"/opt/macula/bin/macula\", \"foreground\"]\n```\n\n**Build**:\n```bash\ndocker build -t macula:latest .\n```\n\n---","ref":"macula_project_structure.html#docker-image"},{"type":"extras","title":"Repository Initialization - Project Structure","doc":"","ref":"macula_project_structure.html#repository-initialization"},{"type":"extras","title":"Create Umbrella Application - Project Structure","doc":"```bash\n# Erlang (Rebar3)\nrebar3 new umbrella macula\ncd macula\n\n# Create apps\nrebar3 new lib apps/macula_core\nrebar3 new lib apps/macula_quic\nrebar3 new lib apps/macula_protocol\n# ... etc\n\n# Compile\nrebar3 compile\n\n# Test\nrebar3 eunit\n\n# Release\nrebar3 release\n```","ref":"macula_project_structure.html#create-umbrella-application"},{"type":"extras","title":"OR Elixir (Mix) - Project Structure","doc":"```bash\n# Elixir (Mix)\nmix new macula --umbrella\ncd macula\n\n# Create apps\ncd apps\nmix new macula_core\nmix new macula_quic\nmix new macula_protocol\n# ... etc\n\ncd ..\n\n# Compile\nmix compile\n\n# Test\nmix test\n\n# Release\nmix release\n```\n\n---","ref":"macula_project_structure.html#or-elixir-mix"},{"type":"extras","title":"Summary - Project Structure","doc":"**Core Libraries** (12):\n1. ✅ `macula_core` - Core types and utilities\n2. ✅ `macula_quic` - QUIC transport\n3. ✅ `macula_protocol` - Wire protocol\n4. ✅ `macula_membership` - SWIM membership\n5. ✅ `macula_routing` - Kademlia DHT\n6. ✅ `macula_topology` - Mesh topology\n7. ✅ `macula_pubsub` - Pub/sub\n8. ✅ `macula_rpc` - RPC\n9. ✅ `macula_discovery` - Node discovery\n10. ✅ `macula_security` - Security\n11. ✅ `macula_gateway` - Cross-realm gateway\n12. ✅ `macula` - Main application\n\n**Tools** (3):\n13. ✅ `macula_cli` - CLI tool\n14. ✅ `macula_observer` - Visualization\n15. ✅ `macula_loadtest` - Load testing\n\n**Optional** (5):\n16. ⚠️ `macula_wamp_compat` - WAMP bridge\n17. ⚠️ `macula_http_bridge` - HTTP gateway\n18. ⚠️ `macula_kafka_connector` - Kafka integration\n19. ⚠️ `macula_postgres_connector` - PostgreSQL integration\n20. ⚠️ `macula_metrics` - Metrics/observability\n\n**Total**: 20 libraries/applications\n\n---\n\n**Next Step**: Initialize the repository structure and start with Phase 1 (Foundation).\n\n---\n\n**Last Updated**: 2025-01-08\n**Maintainers**: [To be assigned]","ref":"macula_project_structure.html#summary"},{"type":"extras","title":"Architecture","doc":"# Macula HTTP/3 Mesh - Documentation Root\n\n**A distributed mesh networking platform for BEAM, built on HTTP/3/QUIC**\n\n---","ref":"macula_http3_mesh_root.html"},{"type":"extras","title":"Vision - Architecture","doc":"Build a unique, standards-based distributed networking layer for Erlang/Elixir applications that:\n- Uses HTTP/3 (QUIC) for NAT-friendly, firewall-friendly transport\n- Forms self-organizing mesh topologies at the edge\n- Provides pub/sub and RPC primitives\n- Scales to thousands of nodes\n- Supports multi-tenancy and realm isolation\n- Delivers \"Wow! How do they do it?\" factor\n\n**Target Use Cases**:\n- Edge-first IoT networks\n- Decentralized energy trading platforms\n- Multi-tenant SaaS applications\n- Partner data exchange networks\n- Hybrid cloud-edge systems\n\n---","ref":"macula_http3_mesh_root.html#vision"},{"type":"extras","title":"Documentation Index - Architecture","doc":"","ref":"macula_http3_mesh_root.html#documentation-index"},{"type":"extras","title":"Core Architecture Documents - Architecture","doc":"#### 1. [Technical Roadmap](macula_http3_mesh_roadmap.md) ⭐ **START HERE**\n**20-week implementation plan with detailed technical specifications**\n\n**Contents**:\n- Understanding QUIC and HTTP/3 (protocol deep dive)\n- QUIC/HTTP/3 libraries for BEAM (comparison matrix)\n- Complete 5-layer architecture\n- Phase-by-phase implementation (Weeks 1-20)\n- Code examples for each phase\n- Success criteria and benchmarks\n- Technical deep dives (QUIC vs TCP, SWIM gossip, Kademlia DHT)\n\n**Who should read this**: Engineers implementing the platform, technical leads evaluating feasibility\n\n**Key decisions documented**:\n- QUIC library choice: **quicer** (Erlang NIF wrapper for MsQuic)\n- Topology: **k-regular graph** with SWIM gossip\n- Routing: **Kademlia DHT** (O(log N) lookups)\n- NAT traversal: **STUN/ICE + UDP hole punching**\n\n---\n\n#### 2. [C4 Architecture Diagrams](macula_http3_mesh_c4_diagrams.md)\n**Multi-level architecture visualization using C4 model**\n\n**Contents**:\n- **Level 1 - System Context**: Ecosystem view (developers, nodes, infrastructure)\n- **Level 2 - Container**: Technology stack, BEAM VM internals\n- **Level 3 - Component**: Mesh Services and Protocol Layer components\n- **Level 4 - Code**: Detailed `macula_connection` GenServer implementation\n- **Supplementary - Deployment**: Physical deployment scenarios\n\n**Who should read this**: Architects, new team members, stakeholders wanting visual overview\n\n**Diagram formats**: ASCII (easy to view in terminal, version control friendly)\n\n---\n\n#### 3. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md)\n**Multi-tenancy, realms, and cross-realm communication**\n\n**Contents**:\n- Realm concept and namespacing\n- Identity layer (node-level realm membership)\n- Topic namespacing and validation\n- Routing table partitioning by realm\n- Three cross-realm communication models:\n  - **Model A: Gateway Nodes** (recommended)\n  - **Model B: Federation Protocol**\n  - **Model C: Strict Isolation**\n- Protocol-level realm support\n- SWIM membership per realm\n- Pub/sub with realm scoping\n- Certificate-based security\n- Use cases (SaaS, energy markets, IoT, partners)\n- Implementation roadmap (Weeks 21-27)\n\n**Who should read this**: SaaS platform engineers, security architects, multi-tenant deployment teams\n\n**Key features**:\n- Isolation by default\n- Policy-based gateways for controlled data sharing\n- Certificate validation with realm in SAN\n- ACL enforcement\n- Audit logging\n\n---\n\n#### 4. [Module Dependencies and Architecture](macula_http3_mesh_module_dependencies.md) ⭐\n**How the pieces fit together: From QUIC to your application**\n\n**Contents**:\n- **Layered architecture diagram** - Visual representation of all components\n- **Module responsibilities** - What each component does and why\n- **Message flow examples** - Follow an RPC call and pub/sub message through the stack\n- **The philosophy** - Gateway as \"dumb transport\" vs RPC/PubSub as \"smart orchestration\"\n- **Current implementation status** - What works, what's in progress, what's planned\n\n**Who should read this**: All developers working on Macula, architects understanding the system\n\n**Key insight**: Macula separates transport concerns (gateway) from business logic (RPC/PubSub servers), similar to how nginx handles HTTP routing while your application handles business logic. This separation enables independent evolution, testing, and scaling of each layer.\n\n**Why this matters**: Understanding the layered architecture prevents confusion about where functionality belongs. For example, topic pattern matching belongs in `macula_pubsub_server` (business logic), not `macula_gateway` (transport).\n\n---","ref":"macula_http3_mesh_root.html#core-architecture-documents"},{"type":"extras","title":"Quick Start Guides - Architecture","doc":"#### 5. [Quick Start Guide](macula_http3_mesh_quick_start.md) 🚀 ⚠️ **TODO**\n**Get a 3-node mesh running in 15 minutes**\n\n**Planned contents**:\n- Prerequisites (Erlang/OTP 26+, quicer installation)\n- Download and build Macula\n- Start first node\n- Start and join second node\n- Start and join third node\n- Send first pub/sub message\n- Make first RPC call\n- Verify mesh topology\n- Common troubleshooting\n\n**Target audience**: Developers wanting hands-on experience\n\n---\n\n#### 6. [Hello World Tutorial](macula_http3_mesh_hello_world.md) 📚 ⚠️ **TODO**\n**Build your first Macula application**\n\n**Planned contents**:\n- Create new Elixir/Mix project\n- Add Macula dependency\n- Configure node identity and realm\n- Implement simple pub/sub chat application\n- Deploy across multiple nodes\n- Add RPC endpoint (echo service)\n- Monitor with Observer\n\n**Target audience**: Application developers new to Macula\n\n---","ref":"macula_http3_mesh_root.html#quick-start-guides"},{"type":"extras","title":"API and Protocol Specifications - Architecture","doc":"#### 7. [Wire Protocol Specification](macula_http3_mesh_protocol_spec.md) 📋 ⚠️ **TODO**\n**Complete wire protocol documentation**\n\n**Planned contents**:\n- Packet format and framing\n- Message types (handshake, heartbeat, send, pub, sub, rpc, etc.)\n- Encoding/decoding rules (Erlang term format)\n- Handshake protocol flow\n- Stream multiplexing\n- Error handling\n- Protocol versioning\n- Compatibility matrix\n\n**Target audience**: Protocol implementers, interoperability teams\n\n---\n\n#### 8. [API Reference](macula_http3_mesh_api_reference.md) 📖 ⚠️ **TODO**\n**Complete Erlang/Elixir API documentation**\n\n**Planned contents**:\n- `macula:start/1` - Start node\n- `macula:connect/2` - Connect to peer\n- `macula:publish/2,3` - Publish message\n- `macula:subscribe/1,2` - Subscribe to topic\n- `macula:call/3,4` - RPC call\n- `macula:register/2` - Register RPC endpoint\n- Gateway APIs\n- Policy configuration APIs\n- Metrics and monitoring APIs\n\n**Target audience**: Application developers\n\n---","ref":"macula_http3_mesh_root.html#api-and-protocol-specifications"},{"type":"extras","title":"Advanced Topics - Architecture","doc":"#### 9. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md) 🌐 ⚠️ **TODO**\n**How Macula works behind NATs and firewalls**\n\n**Planned contents**:\n- NAT types and challenges (full cone, symmetric, etc.)\n- STUN protocol for public IP discovery\n- ICE protocol for connectivity establishment\n- UDP hole punching techniques\n- TURN relay fallback\n- Connection migration on IP change\n- Mobile/cellular network considerations\n- Enterprise firewall traversal\n\n**Target audience**: Network engineers, DevOps, deployment teams\n\n---\n\n#### 10. [Security Model](macula_http3_mesh_security.md) 🔒 ⚠️ **TODO**\n**Comprehensive security architecture**\n\n**Planned contents**:\n- Threat model\n- TLS 1.3 integration with QUIC\n- Certificate-based node authentication\n- Realm isolation via certificates\n- ACL enforcement\n- Message signing and verification\n- Audit logging\n- Denial-of-service protection\n- Rate limiting\n- Security best practices\n- Penetration testing results\n\n**Target audience**: Security teams, compliance officers, architects\n\n---\n\n#### 11. [Performance Tuning Guide](macula_http3_mesh_performance.md) ⚡ ⚠️ **TODO**\n**Optimize for throughput and latency**\n\n**Planned contents**:\n- Benchmarking methodology\n- OS-level tuning (UDP buffers, file descriptors)\n- BEAM VM tuning (schedulers, memory)\n- QUIC connection parameters\n- Stream multiplexing configuration\n- Routing table optimization\n- SWIM protocol tuning\n- Gateway throughput optimization\n- Monitoring and profiling tools\n- Load testing scenarios\n\n**Target audience**: Performance engineers, SREs\n\n---\n\n#### 12. [Observability Guide](macula_http3_mesh_observability.md) 📊 ⚠️ **TODO**\n**Monitor, trace, and debug Macula networks**\n\n**Planned contents**:\n- Prometheus metrics (all available metrics)\n- Grafana dashboards (pre-built templates)\n- OpenTelemetry tracing integration\n- Log aggregation (structured logging)\n- Mesh topology visualization\n- Real-time message flow visualization\n- Health checks and alerts\n- Debugging tools (observer, recon, etc.)\n- Common issues and diagnostics\n\n**Target audience**: SREs, DevOps, operations teams\n\n---\n\n#### 13. [Deployment Patterns](macula_http3_mesh_deployment_patterns.md) 🚀 ⚠️ **TODO**\n**Production deployment architectures**\n\n**Planned contents**:\n- Single-region mesh\n- Multi-region with gateways\n- Hybrid cloud-edge\n- Kubernetes deployment (Helm charts)\n- Docker Compose examples\n- Bare metal / VM deployment\n- DNS/discovery configuration\n- Load balancing strategies\n- High availability patterns\n- Disaster recovery\n- Migration strategies (zero-downtime updates)\n\n**Target audience**: DevOps, platform engineers, architects\n\n---\n\n#### 14. [Gateway Operations Manual](macula_http3_mesh_gateway_ops.md) 🌉 ⚠️ **TODO**\n**Deploy and operate gateway nodes**\n\n**Planned contents**:\n- Gateway node requirements\n- Policy configuration (YAML/JSON schemas)\n- Topic translation setup\n- Rate limiting configuration\n- Audit log management\n- Certificate management for gateways\n- High availability setup (active-active)\n- Monitoring gateway health\n- Troubleshooting cross-realm issues\n- Performance optimization\n- Security hardening\n\n**Target audience**: Gateway operators, platform admins\n\n---","ref":"macula_http3_mesh_root.html#advanced-topics"},{"type":"extras","title":"Comparisons and Design Decisions - Architecture","doc":"#### 15. [Macula vs Distributed Erlang](macula_http3_mesh_vs_distributed_erlang.md) ⭐\n**Does Macula augment or replace Distributed Erlang?**\n\n**Answer**: Macula **replaces** Distributed Erlang for internet-scale, multi-tenant scenarios.\n\n**Contents**:\n- **The key differences** - Security, network assumptions, multi-tenancy, scalability\n- **Architectural comparison** - Cookie-based mesh vs TLS-based selective connectivity\n- **When to use each** - Tightly-coupled clusters (disterl) vs loosely-coupled services (Macula)\n- **Code comparison** - Side-by-side examples showing explicit vs implicit communication\n- **Hybrid approach** - Can you use both? (Yes, with gateways between data centers)\n- **Migration path** - Moving from disterl to Macula incrementally\n\n**Who should read this**: Teams familiar with Distributed Erlang, architects deciding between approaches\n\n**Key takeaway**: Distributed Erlang excels at <50 node, single-datacenter, fully-trusted clusters. Macula excels at 100s-1000s of nodes across the internet with realm isolation and NAT traversal. They solve different problems.\n\n---\n\n#### 16. [Comparison with WAMP/Bondy](macula_http3_mesh_vs_wamp.md) 🔄 ⚠️ **TODO**\n**Why build Macula when WAMP exists?**\n\n**Planned contents**:\n- WAMP strengths and weaknesses\n- Why WAMP over WebSocket doesn't work well for edge\n- NAT traversal comparison\n- Bondy clustering (Partisan) vs Macula mesh\n- Protocol overhead comparison\n- Latency and throughput benchmarks\n- When to use WAMP/Bondy vs Macula\n- Migration path from WAMP to Macula\n- Interoperability (WAMP compatibility layer)\n\n**Target audience**: Teams familiar with WAMP, decision makers\n\n---\n\n#### 17. [Comparison with libp2p](macula_http3_mesh_vs_libp2p.md) 🔄 ⚠️ **TODO**\n**Macula vs libp2p (IPFS networking stack)**\n\n**Planned contents**:\n- libp2p architecture overview\n- BEAM libp2p implementations (ex_libp2p)\n- Why not use libp2p?\n  - Complexity\n  - Maturity in BEAM ecosystem\n  - Distributed Erlang incompatibility\n- Protocol comparison (QUIC, GossipSub, Kademlia)\n- Use case fit analysis\n- Performance comparison\n\n**Target audience**: P2P networking engineers, architects\n\n---\n\n#### 18. [Design Decision Log](macula_http3_mesh_decisions.md) 📝 ⚠️ **TODO**\n**Why we made the choices we did**\n\n**Planned contents**:\n- ADR 001: Why QUIC instead of TCP?\n- ADR 002: Why quicer (MsQuic) instead of pure Erlang?\n- ADR 003: Why Kademlia instead of Chord/Pastry?\n- ADR 004: Why SWIM instead of Raft for membership?\n- ADR 005: Why k-regular graph instead of full mesh?\n- ADR 006: Why gateway pattern for cross-realm?\n- ADR 007: Why certificate-based auth instead of API keys?\n- ADR 008: Why UDP hole punching instead of TURN-only?\n\n**Format**: Architecture Decision Records (ADRs)\n\n**Target audience**: Architects, long-term maintainers\n\n---","ref":"macula_http3_mesh_root.html#comparisons-and-design-decisions"},{"type":"extras","title":"Reference Materials - Architecture","doc":"#### 19. [Glossary](macula_http3_mesh_glossary.md) 📖 ⚠️ **TODO**\n**Terms and definitions**\n\n**Planned contents**:\n- QUIC, HTTP/3, UDP, DTLS, TLS 1.3\n- Mesh, topology, k-regular graph\n- SWIM, gossip, failure detection\n- Kademlia, DHT, XOR distance\n- Realm, tenant, gateway\n- Pub/sub, RPC, stream\n- NAT, STUN, ICE, TURN, hole punching\n- Connection migration, 0-RTT\n- ACL, policy, audit\n\n**Target audience**: Everyone (reference)\n\n---\n\n#### 20. [FAQ](macula_http3_mesh_faq.md) ❓ ⚠️ **TODO**\n**Frequently asked questions**\n\n**Planned contents**:\n- What is Macula?\n- Why HTTP/3 instead of traditional distributed Erlang?\n- Can it work behind NAT?\n- How many nodes can it scale to?\n- What's the latency overhead?\n- Is it production-ready?\n- How does it compare to X? (where X = WAMP, libp2p, Partisan, gRPC, etc.)\n- Can I use it with Phoenix/LiveView?\n- Does it work in Kubernetes?\n- What license is it?\n\n**Target audience**: Everyone (first questions)\n\n---\n\n#### 21. [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md) 🔧 ⚠️ **TODO**\n**Common issues and solutions**\n\n**Planned contents**:\n- Nodes can't discover each other\n- Connection timeout / handshake failure\n- NAT traversal failures\n- Certificate validation errors\n- SWIM membership flapping\n- Routing table inconsistencies\n- Gateway policy denials\n- Performance issues (high latency, low throughput)\n- Memory leaks\n- Crash dumps analysis\n\n**Format**: Problem → Diagnosis → Solution\n\n**Target audience**: Operations, support teams\n\n---","ref":"macula_http3_mesh_root.html#reference-materials"},{"type":"extras","title":"Contributing and Community - Architecture","doc":"#### 22. [Contributing Guide](macula_http3_mesh_contributing.md) 🤝 ⚠️ **TODO**\n**How to contribute to Macula**\n\n**Planned contents**:\n- Code of conduct\n- Development setup\n- Testing requirements (unit, integration, property-based)\n- Code style guide (Erlang/Elixir conventions)\n- Documentation requirements\n- Pull request process\n- Release process\n- Community channels (Discord, mailing list, etc.)\n- Roadmap and feature requests\n\n**Target audience**: Contributors, open source community\n\n---","ref":"macula_http3_mesh_root.html#contributing-and-community"},{"type":"extras","title":"Document Status - Architecture","doc":"| Document | Status | Priority | Target Week |\n|----------|--------|----------|-------------|\n| Technical Roadmap | ✅ Complete | P0 | Week 0 |\n| C4 Diagrams | ✅ Complete | P0 | Week 0 |\n| Isolation Mechanisms | ✅ Complete | P0 | Week 0 |\n| Module Dependencies | ✅ Complete | P0 | Week 0 |\n| Macula vs Distributed Erlang | ✅ Complete | P1 | Week 0 |\n| Quick Start Guide | ⚠️ TODO | P1 | Week 4 |\n| Hello World Tutorial | ⚠️ TODO | P1 | Week 4 |\n| Wire Protocol Spec | ⚠️ TODO | P1 | Week 8 |\n| API Reference | ⚠️ TODO | P1 | Week 12 |\n| NAT Traversal Deep Dive | ⚠️ TODO | P2 | Week 12 |\n| Security Model | ⚠️ TODO | P1 | Week 16 |\n| Performance Tuning | ⚠️ TODO | P2 | Week 20 |\n| Observability Guide | ⚠️ TODO | P2 | Week 20 |\n| Deployment Patterns | ⚠️ TODO | P1 | Week 20 |\n| Gateway Operations | ⚠️ TODO | P2 | Week 24 |\n| Comparison with WAMP | ⚠️ TODO | P2 | Week 8 |\n| Comparison with libp2p | ⚠️ TODO | P3 | Week 12 |\n| Design Decision Log | ⚠️ TODO | P2 | Ongoing |\n| Glossary | ⚠️ TODO | P2 | Week 4 |\n| FAQ | ⚠️ TODO | P1 | Week 4 |\n| Troubleshooting Guide | ⚠️ TODO | P2 | Week 20 |\n| Contributing Guide | ⚠️ TODO | P2 | Week 4 |\n\n**Priority Levels**:\n- **P0**: Must have before any code (architecture)\n- **P1**: Required for MVP release\n- **P2**: Important for production use\n- **P3**: Nice to have\n\n---","ref":"macula_http3_mesh_root.html#document-status"},{"type":"extras","title":"Reading Paths - Architecture","doc":"","ref":"macula_http3_mesh_root.html#reading-paths"},{"type":"extras","title":"For Evaluators (Decision Makers) - Architecture","doc":"1. This document (overview)\n2. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Sections: Vision, Architecture Overview, Timeline\n3. [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) - Level 1 and Level 2\n4. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Use Cases section\n\n**Time**: ~1 hour\n\n---","ref":"macula_http3_mesh_root.html#for-evaluators-decision-makers"},{"type":"extras","title":"For Architects (System Design) - Architecture","doc":"1. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Complete read\n2. [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) - All levels\n3. [Module Dependencies](macula_http3_mesh_module_dependencies.md) - Understand the layers\n4. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Complete read\n5. [Macula vs Distributed Erlang](macula_http3_mesh_vs_distributed_erlang.md) - Architectural trade-offs\n6. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md) ⚠️ TODO\n7. [Security Model](macula_http3_mesh_security.md) ⚠️ TODO\n8. [Design Decision Log](macula_http3_mesh_decisions.md) ⚠️ TODO\n\n**Time**: ~5 hours\n\n---","ref":"macula_http3_mesh_root.html#for-architects-system-design"},{"type":"extras","title":"For Implementers (Engineers) - Architecture","doc":"1. [Module Dependencies](macula_http3_mesh_module_dependencies.md) - Understand where code belongs\n2. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Focus on code examples\n3. [Wire Protocol Spec](macula_http3_mesh_protocol_spec.md) ⚠️ TODO\n4. [API Reference](macula_http3_mesh_api_reference.md) ⚠️ TODO\n5. [Quick Start Guide](macula_http3_mesh_quick_start.md) ⚠️ TODO\n6. [Hello World Tutorial](macula_http3_mesh_hello_world.md) ⚠️ TODO\n\n**Time**: ~3 hours + hands-on\n\n---","ref":"macula_http3_mesh_root.html#for-implementers-engineers"},{"type":"extras","title":"For Operators (DevOps/SRE) - Architecture","doc":"1. [Quick Start Guide](macula_http3_mesh_quick_start.md) ⚠️ TODO\n2. [Deployment Patterns](macula_http3_mesh_deployment_patterns.md) ⚠️ TODO\n3. [Observability Guide](macula_http3_mesh_observability.md) ⚠️ TODO\n4. [Performance Tuning](macula_http3_mesh_performance.md) ⚠️ TODO\n5. [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md) ⚠️ TODO\n6. [Gateway Operations](macula_http3_mesh_gateway_ops.md) ⚠️ TODO\n\n**Time**: ~2 hours + practice\n\n---","ref":"macula_http3_mesh_root.html#for-operators-devops-sre"},{"type":"extras","title":"For Security Teams - Architecture","doc":"1. [Security Model](macula_http3_mesh_security.md) ⚠️ TODO\n2. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Security sections\n3. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md) ⚠️ TODO\n4. [Gateway Operations](macula_http3_mesh_gateway_ops.md) ⚠️ TODO - Security hardening\n\n**Time**: ~3 hours\n\n---","ref":"macula_http3_mesh_root.html#for-security-teams"},{"type":"extras","title":"Additional Topics to Document - Architecture","doc":"Based on the comprehensive nature of this project, here are **additional topics** that should be documented:","ref":"macula_http3_mesh_root.html#additional-topics-to-document"},{"type":"extras","title":"21. Testing Strategy 🧪 - Architecture","doc":"**Comprehensive testing approach**\n\n**Contents**:\n- Unit testing (EUnit, ExUnit)\n- Property-based testing (PropEr, StreamData)\n- Integration testing (multi-node scenarios)\n- Chaos engineering (partition testing, node crashes)\n- Load testing (Tsung, k6)\n- Security testing (penetration testing)\n- Fuzz testing (protocol fuzzing)\n- Continuous integration setup\n\n---","ref":"macula_http3_mesh_root.html#21-testing-strategy"},{"type":"extras","title":"22. Migration Guide 🔄 - Architecture","doc":"**Moving from other systems to Macula**\n\n**Contents**:\n- Migrating from WAMP/Bondy\n- Migrating from distributed Erlang\n- Migrating from RabbitMQ/Kafka\n- Migrating from gRPC\n- Co-existence strategies (gradual migration)\n- Data migration patterns\n- Rollback procedures\n\n---","ref":"macula_http3_mesh_root.html#22-migration-guide"},{"type":"extras","title":"23. Scaling Patterns 📈 - Architecture","doc":"**How to scale from 10 to 10,000 nodes**\n\n**Contents**:\n- Topology evolution (full mesh → k-regular → hierarchical)\n- Region sharding\n- DHT bucket optimization\n- SWIM tuning for large networks\n- Gateway scaling (horizontal)\n- Database scaling (if persistence layer added)\n- Cost analysis at scale\n\n---","ref":"macula_http3_mesh_root.html#23-scaling-patterns"},{"type":"extras","title":"24. Protocol Evolution 🔬 - Architecture","doc":"**Versioning and backward compatibility**\n\n**Contents**:\n- Protocol version negotiation\n- Backward compatibility guarantees\n- Deprecation policy\n- Feature flags\n- Upgrade paths (rolling upgrades)\n- Breaking changes process\n\n---","ref":"macula_http3_mesh_root.html#24-protocol-evolution"},{"type":"extras","title":"25. Mobile and Browser Support 📱 - Architecture","doc":"**Extending Macula to constrained environments**\n\n**Contents**:\n- WebAssembly BEAM (lumen, AtomVM)\n- Browser WebTransport (QUIC in browsers)\n- React Native integration\n- Mobile battery optimization\n- Offline-first patterns\n- Connection resumption on network change\n\n---","ref":"macula_http3_mesh_root.html#25-mobile-and-browser-support"},{"type":"extras","title":"26. Plugin Architecture 🔌 - Architecture","doc":"**Extend Macula with custom behaviors**\n\n**Contents**:\n- Hook system for message interception\n- Custom discovery plugins (Consul, etcd)\n- Custom transport plugins (WebRTC, Bluetooth)\n- Custom routing strategies\n- Custom serialization formats\n- Plugin development guide\n\n---","ref":"macula_http3_mesh_root.html#26-plugin-architecture"},{"type":"extras","title":"27. Cost Analysis 💰 - Architecture","doc":"**TCO comparison vs alternatives**\n\n**Contents**:\n- Infrastructure costs (vs cloud load balancers)\n- Bandwidth costs (UDP vs TCP, compression)\n- Operational costs (automation, monitoring)\n- Development costs (time to market)\n- Licensing costs (vs commercial solutions)\n- ROI calculator\n\n---","ref":"macula_http3_mesh_root.html#27-cost-analysis"},{"type":"extras","title":"28. Regulatory Compliance 📜 - Architecture","doc":"**GDPR, HIPAA, SOC2 considerations**\n\n**Contents**:\n- Data residency (realm isolation for regions)\n- Right to be forgotten (message expiry)\n- Audit logging requirements\n- Encryption at rest/in transit\n- Access controls\n- Compliance checklists\n\n---","ref":"macula_http3_mesh_root.html#28-regulatory-compliance"},{"type":"extras","title":"29. Interoperability 🔗 - Architecture","doc":"**Connect Macula to other systems**\n\n**Contents**:\n- WAMP compatibility layer (adapter)\n- gRPC bridge\n- REST/GraphQL gateway\n- MQTT bridge (for IoT)\n- Kafka/RabbitMQ connectors\n- Database change data capture (CDC)\n\n---","ref":"macula_http3_mesh_root.html#29-interoperability"},{"type":"extras","title":"30. Case Studies 📚 - Architecture","doc":"**Real-world deployments (when available)**\n\n**Contents**:\n- Example Platform energy trading platform\n- Industrial IoT deployment\n- Multi-tenant SaaS platform\n- Gaming backend\n- Financial data mesh\n- Lessons learned, metrics, testimonials\n\n---","ref":"macula_http3_mesh_root.html#30-case-studies"},{"type":"extras","title":"Contributing to Documentation - Architecture","doc":"Documentation is as important as code! To contribute:\n\n1. **Choose a TODO document** from the status table above\n2. **Follow the template** provided in the document outline\n3. **Include code examples** (working, tested code)\n4. **Add diagrams** (ASCII art for version control friendliness)\n5. **Get review** from at least one core team member\n6. **Update this index** when document is complete\n\n**Documentation Standards**:\n- Use Markdown (.md)\n- ASCII diagrams (box drawing characters: ┌─┐│└┘)\n- Code examples must be syntactically correct\n- Include both Erlang and Elixir examples where applicable\n- Cross-reference related documents\n- Keep language clear and concise (avoid jargon, or define it)\n\n---","ref":"macula_http3_mesh_root.html#contributing-to-documentation"},{"type":"extras","title":"License - Architecture","doc":"[To be determined - likely Apache 2.0 or MIT]\n\n---","ref":"macula_http3_mesh_root.html#license"},{"type":"extras","title":"Contact and Community - Architecture","doc":"- **GitHub**: [macula-io/macula](https://github.com/macula-io/macula) ⚠️ TODO\n- **Discord**: [Join our Discord](https://discord.gg/macula) ⚠️ TODO\n- **Mailing List**: macula-dev@googlegroups.com ⚠️ TODO\n- **Twitter**: [@MaculaMesh](https://twitter.com/MaculaMesh) ⚠️ TODO\n\n---\n\n**Last Updated**: 2025-01-08\n**Maintainers**: Macula Core Team\n**Status**: Living Document (updated as project evolves)","ref":"macula_http3_mesh_root.html#contact-and-community"},{"type":"extras","title":"Quick Start","doc":"# Macula HTTP/3 Mesh - Quick Start Guide\n\n**Get a 3-node mesh running in 15 minutes**\n\n---","ref":"macula_http3_mesh_quick_start.html"},{"type":"extras","title":"Prerequisites - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#prerequisites"},{"type":"extras","title":"Required Software - Quick Start","doc":"1. **Erlang/OTP 26.0 or later**\n   ```bash\n   # Check version\n   erl -eval 'erlang:display(erlang:system_info(otp_release)), halt().' -noshell\n   ```\n\n   Install from:\n   - Ubuntu/Debian: `sudo apt-get install erlang`\n   - macOS: `brew install erlang`\n   - From source: https://www.erlang.org/downloads\n\n2. **Elixir 1.15 or later** (optional, for Elixir examples)\n   ```bash\n   # Check version\n   elixir --version\n   ```\n\n   Install from:\n   - Ubuntu/Debian: `sudo apt-get install elixir`\n   - macOS: `brew install elixir`\n   - From source: https://elixir-lang.org/install.html\n\n3. **Git**\n   ```bash\n   git --version\n   ```\n\n4. **C Compiler** (for building quicer NIF)\n   - Ubuntu/Debian: `sudo apt-get install build-essential cmake`\n   - macOS: `xcode-select --install`","ref":"macula_http3_mesh_quick_start.html#required-software"},{"type":"extras","title":"System Requirements - Quick Start","doc":"- **OS**: Linux (Ubuntu 20.04+), macOS 11+, or Windows WSL2\n- **RAM**: 512 MB minimum per node (2 GB recommended for development)\n- **Network**: UDP port access (default: 4433)\n- **Disk**: 100 MB for Macula + dependencies\n\n---","ref":"macula_http3_mesh_quick_start.html#system-requirements"},{"type":"extras","title":"Step 1: Download and Build Macula - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-1-download-and-build-macula"},{"type":"extras","title":"Clone the Repository - Quick Start","doc":"```bash\ncd ~/projects\ngit clone https://github.com/macula-io/macula.git\ncd macula\n```","ref":"macula_http3_mesh_quick_start.html#clone-the-repository"},{"type":"extras","title":"Install Dependencies - Quick Start","doc":"```bash\n# For Erlang (Rebar3)\nrebar3 get-deps\n\n# For Elixir (Mix)\nmix deps.get\n```","ref":"macula_http3_mesh_quick_start.html#install-dependencies"},{"type":"extras","title":"Build quicer (QUIC Library) - Quick Start","doc":"The `quicer` library includes native code and may take a few minutes to compile:\n\n```bash\n# Rebar3\nrebar3 compile\n\n# Mix\nmix compile\n```\n\n**Expected output**:\n```\n===> Fetching quicer (from {git,\"https://github.com/emqx/quic.git\",...})\n===> Compiling quicer\n     ...\n     [100%] Built target msquic\n===> Compiled quicer\n```","ref":"macula_http3_mesh_quick_start.html#build-quicer-quic-library"},{"type":"extras","title":"Verify Installation - Quick Start","doc":"```bash\n# Erlang\nrebar3 shell\n> macula:version().\n{ok, \"0.1.0\"}\n\n# Elixir\niex -S mix\niex> Macula.version()\n{:ok, \"0.1.0\"}\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#verify-installation"},{"type":"extras","title":"Step 2: Start Node 1 (Bootstrap Node) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-2-start-node-1-bootstrap-node"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node1.config`:\n\n```erlang\n%% config/node1.config\n[\n {macula, [\n   {node_id, <<\"node1\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4433},\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery\n   {discovery, [\n     {methods, [static]},  % Use static bootstrap for this example\n     {static_nodes, []}    % First node has no bootstrap peers\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}  % Each node connects to 2 peers\n   ]},\n\n   %% TLS/Certificates (auto-generate for demo)\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file"},{"type":"extras","title":"Start Node 1 - Quick Start","doc":"```bash\n# Erlang\nerl -config config/node1 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node1@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node1.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node1\n[info] Listening on 0.0.0.0:4433 (UDP)\n[info] Node ID: a3f5b2e1c4d8a7f9...\n[info] Realm: org.example.mesh\n[info] Topology: k_regular (k=2)\n[info] Discovery: static\n[info] Ready to accept connections\n```\n\n**Keep this terminal open** - Node 1 is now running.\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-1"},{"type":"extras","title":"Step 3: Start Node 2 (Join the Mesh) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-3-start-node-2-join-the-mesh"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node2.config`:\n\n```erlang\n%% config/node2.config\n[\n {macula, [\n   {node_id, <<\"node2\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4434},  % Different port\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery - bootstrap from Node 1\n   {discovery, [\n     {methods, [static]},\n     {static_nodes, [\n       {\"127.0.0.1\", 4433}  % Node 1's address\n     ]}\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n\n   %% TLS/Certificates\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file-1"},{"type":"extras","title":"Start Node 2 (in new terminal) - Quick Start","doc":"```bash\n# Open new terminal\ncd ~/projects/macula\n\n# Erlang\nerl -config config/node2 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node2@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node2.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node2\n[info] Listening on 0.0.0.0:4434 (UDP)\n[info] Node ID: b7c3d8e2f5a9b4c1...\n[info] Realm: org.example.mesh\n[info] Connecting to bootstrap node 127.0.0.1:4433...\n[info] Connected to node1 (a3f5b2e1c4d8a7f9...)\n[info] SWIM membership: 2 nodes alive\n[info] Mesh topology established\n```\n\n**In Node 1's terminal**, you should see:\n```\n[info] New connection from 127.0.0.1:xxxxx\n[info] Handshake complete: node2 (b7c3d8e2f5a9b4c1...)\n[info] SWIM membership: 2 nodes alive\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-2-in-new-terminal"},{"type":"extras","title":"Step 4: Start Node 3 (Expand the Mesh) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-4-start-node-3-expand-the-mesh"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node3.config`:\n\n```erlang\n%% config/node3.config\n[\n {macula, [\n   {node_id, <<\"node3\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4435},\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery - can bootstrap from either node\n   {discovery, [\n     {methods, [static]},\n     {static_nodes, [\n       {\"127.0.0.1\", 4433},  % Node 1\n       {\"127.0.0.1\", 4434}   % Node 2\n     ]}\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n\n   %% TLS/Certificates\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file-2"},{"type":"extras","title":"Start Node 3 (in new terminal) - Quick Start","doc":"```bash\n# Open new terminal\ncd ~/projects/macula\n\n# Erlang\nerl -config config/node3 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node3@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node3.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node3\n[info] Listening on 0.0.0.0:4435 (UDP)\n[info] Node ID: c8d4e9f3a6b2c7d1...\n[info] Realm: org.example.mesh\n[info] Connecting to bootstrap nodes...\n[info] Connected to node1 (a3f5b2e1c4d8a7f9...)\n[info] Connected to node2 (b7c3d8e2f5a9b4c1...)\n[info] SWIM membership: 3 nodes alive\n[info] Mesh topology: k_regular (k=2)\n[info] Routing table: 3 nodes\n```\n\n**Congratulations!** You now have a 3-node mesh network running.\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-3-in-new-terminal"},{"type":"extras","title":"Step 5: Verify Mesh Topology - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-5-verify-mesh-topology"},{"type":"extras","title":"Check Membership (on any node) - Quick Start","doc":"In any node's console:\n\n```erlang\n% Erlang\nmacula_membership:get_members().\n\n% Expected output:\n[\n  #{node_id => <<\"a3f5b2e1...\">>, state => alive, ...},\n  #{node_id => <<\"b7c3d8e2...\">>, state => alive, ...},\n  #{node_id => <<\"c8d4e9f3...\">>, state => alive, ...}\n]\n```\n\n```elixir\n# Elixir\nMacula.Membership.get_members()\n\n# Expected output:\n[\n  %{node_id: \"a3f5b2e1...\", state: :alive, ...},\n  %{node_id: \"b7c3d8e2...\", state: :alive, ...},\n  %{node_id: \"c8d4e9f3...\", state: :alive, ...}\n]\n```","ref":"macula_http3_mesh_quick_start.html#check-membership-on-any-node"},{"type":"extras","title":"Check Connections - Quick Start","doc":"```erlang\n% Erlang\nmacula_topology:get_connections().\n\n% Expected output:\n[\n  #{peer_id => <<\"b7c3d8e2...\">>, state => active, rtt_ms => 1.2},\n  #{peer_id => <<\"c8d4e9f3...\">>, state => active, rtt_ms => 1.5}\n]\n```","ref":"macula_http3_mesh_quick_start.html#check-connections"},{"type":"extras","title":"Visualize Topology (ASCII Art) - Quick Start","doc":"```erlang\n% Erlang\nmacula_topology:print_topology().\n```\n\n**Expected output**:\n```\nMesh Topology (k-regular, k=2)\n==============================\n\nnode1 (a3f5...) ←─→ node2 (b7c3...)\n  ↑                     ↑\n  └────────────→ node3 (c8d4...)\n                       ↑\n                       └────────→ node1\n\n3 nodes, 3 connections\nAverage RTT: 1.3ms\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#visualize-topology-ascii-art"},{"type":"extras","title":"Step 6: Send Your First Message (Pub/Sub) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-6-send-your-first-message-pub-sub"},{"type":"extras","title":"Subscribe to a Topic (on Node 3) - Quick Start","doc":"In Node 3's console:\n\n```erlang\n% Erlang\nSubscriber = spawn(fun() ->\n  receive\n    {event, Topic, Msg} ->\n      io:format(\"Received on ~s: ~p~n\", [Topic, Msg])\n  end\nend).\n\nmacula_pubsub:subscribe(<<\"hello.world\">>, Subscriber).\n```\n\n```elixir\n# Elixir\npid = spawn(fn ->\n  receive do\n    {:event, topic, msg} ->\n      IO.puts(\"Received on #{topic}: #{inspect(msg)}\")\n  end\nend)\n\nMacula.PubSub.subscribe(\"hello.world\", pid)\n```\n\n**Expected output**:\n```\n[info] Subscribed to org.example.mesh.hello.world\nok\n```","ref":"macula_http3_mesh_quick_start.html#subscribe-to-a-topic-on-node-3"},{"type":"extras","title":"Publish a Message (on Node 1) - Quick Start","doc":"In Node 1's console:\n\n```erlang\n% Erlang\nmacula_pubsub:publish(<<\"hello.world\">>, #{\n  message => <<\"Hello from Node 1!\">>,\n  timestamp => erlang:system_time(millisecond)\n}).\n```\n\n```elixir\n# Elixir\nMacula.PubSub.publish(\"hello.world\", %{\n  message: \"Hello from Node 1!\",\n  timestamp: System.system_time(:millisecond)\n})\n```\n\n**Expected output on Node 1**:\n```\n[info] Published to org.example.mesh.hello.world\nok\n```\n\n**Expected output on Node 3** (subscriber):\n```\nReceived on org.example.mesh.hello.world: #{\n  message => <<\"Hello from Node 1!\">>,\n  timestamp => 1704723456789,\n  publisher => <<\"a3f5b2e1...\">>\n}\n```\n\n**Message flow**: Node 1 → QUIC/HTTP3 → Node 3 (may route via Node 2 depending on topology)\n\n---","ref":"macula_http3_mesh_quick_start.html#publish-a-message-on-node-1"},{"type":"extras","title":"Step 7: Make Your First RPC Call - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-7-make-your-first-rpc-call"},{"type":"extras","title":"Register RPC Endpoint (on Node 2) - Quick Start","doc":"In Node 2's console:\n\n```erlang\n% Erlang\nEchoHandler = fun(Args) ->\n  {ok, #{echo => Args, node => node()}}\nend.\n\nmacula_rpc:register(<<\"echo_service\">>, EchoHandler).\n```\n\n```elixir\n# Elixir\necho_handler = fn args ->\n  {:ok, %{echo: args, node: Node.self()}}\nend\n\nMacula.RPC.register(\"echo_service\", echo_handler)\n```\n\n**Expected output**:\n```\n[info] Registered RPC endpoint: org.example.mesh.echo_service\nok\n```","ref":"macula_http3_mesh_quick_start.html#register-rpc-endpoint-on-node-2"},{"type":"extras","title":"Call RPC (from Node 1) - Quick Start","doc":"In Node 1's console:\n\n```erlang\n% Erlang\nmacula_rpc:call(<<\"echo_service\">>, #{\n  test => <<\"Hello RPC!\">>,\n  value => 42\n}, 5000).  % 5 second timeout\n```\n\n```elixir\n# Elixir\nMacula.RPC.call(\"echo_service\", %{\n  test: \"Hello RPC!\",\n  value: 42\n}, 5000)\n```\n\n**Expected output on Node 1**:\n```\n{ok, #{\n  echo => #{test => <<\"Hello RPC!\">>, value => 42},\n  node => 'node2@127.0.0.1'\n}}\n```\n\n**Expected output on Node 2** (handler):\n```\n[info] RPC call received: echo_service\n[info] Args: #{test => <<\"Hello RPC!\">>, value => 42}\n```\n\n**RPC flow**: Node 1 → finds registration via DHT → routes to Node 2 → executes handler → returns result\n\n---","ref":"macula_http3_mesh_quick_start.html#call-rpc-from-node-1"},{"type":"extras","title":"Step 8: Test Fault Tolerance - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-8-test-fault-tolerance"},{"type":"extras","title":"Stop Node 2 - Quick Start","doc":"In Node 2's terminal, press `Ctrl+C` twice to stop the node.\n\n**Expected output on Node 1 and Node 3**:\n```\n[warning] Connection lost to node2 (b7c3d8e2...)\n[info] SWIM detected failure: node2\n[info] SWIM membership: 2 nodes alive, 1 suspect\n[info] Topology reconfiguring...\n[info] New connection established: node1 ←→ node3\n[info] SWIM membership: 2 nodes alive\n```","ref":"macula_http3_mesh_quick_start.html#stop-node-2"},{"type":"extras","title":"Verify Mesh Adapted - Quick Start","doc":"On Node 1 or Node 3:\n\n```erlang\n% Erlang\nmacula_topology:get_connections().\n\n% Expected output (now only 1 connection):\n[\n  #{peer_id => <<\"c8d4e9f3...\">>, state => active, rtt_ms => 1.1}\n]\n```\n\nThe mesh **automatically adapts** - Node 1 and Node 3 now connect directly.","ref":"macula_http3_mesh_quick_start.html#verify-mesh-adapted"},{"type":"extras","title":"Restart Node 2 - Quick Start","doc":"Restart Node 2 (using the same command from Step 3).\n\n**Expected output**:\n```\n[info] Macula node started: node2\n[info] Reconnecting to mesh...\n[info] SWIM membership: 3 nodes alive\n[info] Topology restored\n```\n\nThe mesh **self-heals** automatically.\n\n---","ref":"macula_http3_mesh_quick_start.html#restart-node-2"},{"type":"extras","title":"Common Operations - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#common-operations"},{"type":"extras","title":"List All Nodes in Mesh - Quick Start","doc":"```erlang\n% Erlang\nmacula_membership:list_nodes().\n```\n\n```elixir\n# Elixir\nMacula.Membership.list_nodes()\n```","ref":"macula_http3_mesh_quick_start.html#list-all-nodes-in-mesh"},{"type":"extras","title":"Get Node Statistics - Quick Start","doc":"```erlang\n% Erlang\nmacula:stats().\n\n% Output:\n#{\n  messages_sent => 1543,\n  messages_received => 1687,\n  bytes_sent => 245678,\n  bytes_received => 267890,\n  active_connections => 2,\n  routing_table_size => 3,\n  uptime_seconds => 3600\n}\n```","ref":"macula_http3_mesh_quick_start.html#get-node-statistics"},{"type":"extras","title":"Subscribe with Pattern Matching - Quick Start","doc":"```erlang\n% Erlang - Subscribe to all topics starting with \"sensor.\"\nmacula_pubsub:subscribe(<<\"sensor.*\">>, Pid, #{match => prefix}).\n\n% Matches: sensor.temperature, sensor.humidity, etc.\n```","ref":"macula_http3_mesh_quick_start.html#subscribe-with-pattern-matching"},{"type":"extras","title":"Publish with Options - Quick Start","doc":"```erlang\n% Erlang - Publish with acknowledgment\nmacula_pubsub:publish(<<\"important.event\">>, Data, #{\n  acknowledge => true,  % Wait for delivery confirmation\n  retain => true        % Store for late subscribers\n}).\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#publish-with-options"},{"type":"extras","title":"Troubleshooting - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#troubleshooting"},{"type":"extras","title":"Problem: \"Port already in use\" - Quick Start","doc":"**Error**:\n```\n{error, eaddrinuse}\n```\n\n**Solution**: Change the `listen_port` in your config file to an unused port (e.g., 4436, 4437).\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-port-already-in-use"},{"type":"extras","title":"Problem: Nodes can't discover each other - Quick Start","doc":"**Symptoms**: Node 2 or 3 logs show \"Connection timeout\" or \"No route to bootstrap node\"\n\n**Checks**:\n1. **Firewall**: Ensure UDP port 4433-4435 are not blocked\n   ```bash\n   # Ubuntu/Debian\n   sudo ufw allow 4433:4435/udp\n\n   # macOS\n   # Check System Preferences → Security & Privacy → Firewall\n   ```\n\n2. **Correct IP address**: If running on different machines, replace `127.0.0.1` with actual IP\n   ```bash\n   # Find your IP\n   ip addr show  # Linux\n   ifconfig      # macOS\n   ```\n\n3. **Same realm**: All nodes must have the same `realm` in config\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-nodes-can-t-discover-each-other"},{"type":"extras","title":"Problem: \"Certificate validation failed\" - Quick Start","doc":"**Error**:\n```\n{error, {tls_alert, \"certificate unknown\"}}\n```\n\n**Cause**: Certificate mismatch (usually in manual cert mode)\n\n**Solution**: Use `{cert_mode, auto_generate}` for development, or ensure all nodes trust the same CA.\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-certificate-validation-failed"},{"type":"extras","title":"Problem: High latency or packet loss - Quick Start","doc":"**Check network conditions**:\n```erlang\n% Erlang\nmacula_connection:ping(<<\"node2_id\">>).\n\n% Output:\n{ok, 1.2}  % RTT in milliseconds\n```\n\nIf RTT > 100ms on localhost, check:\n- System load (CPU usage)\n- Other applications using network\n- Docker/VM networking overhead\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-high-latency-or-packet-loss"},{"type":"extras","title":"Next Steps - Quick Start","doc":"Congratulations! You've successfully:\n- ✅ Built Macula from source\n- ✅ Started a 3-node mesh network\n- ✅ Verified mesh topology\n- ✅ Sent pub/sub messages across the mesh\n- ✅ Made RPC calls between nodes\n- ✅ Tested fault tolerance and self-healing","ref":"macula_http3_mesh_quick_start.html#next-steps"},{"type":"extras","title":"Learn More - Quick Start","doc":"- **[Hello World Tutorial](macula_http3_mesh_hello_world.md)** - Build a complete application\n- **[API Reference](macula_http3_mesh_api_reference.md)** - Complete API documentation\n- **[Deployment Patterns](macula_http3_mesh_deployment_patterns.md)** - Production deployments\n- **[Performance Tuning](macula_http3_mesh_performance.md)** - Optimize for your use case","ref":"macula_http3_mesh_quick_start.html#learn-more"},{"type":"extras","title":"Try More Advanced Features - Quick Start","doc":"1. **Realm isolation**: Start nodes in different realms and use gateways\n2. **NAT traversal**: Run nodes on different networks (home, cloud, mobile)\n3. **Large mesh**: Scale to 10+ nodes and observe routing behavior\n4. **Persistence**: Add event sourcing with persistent subscriptions\n5. **Monitoring**: Set up Prometheus metrics and Grafana dashboards","ref":"macula_http3_mesh_quick_start.html#try-more-advanced-features"},{"type":"extras","title":"Join the Community - Quick Start","doc":"- **GitHub**: https://github.com/macula-io/macula\n- **Discord**: https://discord.gg/macula\n- **Docs**: https://docs.macula.io\n\n---\n\n**Happy meshing!** 🎉","ref":"macula_http3_mesh_quick_start.html#join-the-community"},{"type":"extras","title":"Hello World","doc":"# Macula HTTP/3 Mesh - Hello World Tutorial\n\n**Build your first distributed application on Macula**\n\n---","ref":"macula_http3_mesh_hello_world.html"},{"type":"extras","title":"What We'll Build - Hello World","doc":"A **distributed chat application** where:\n- Multiple nodes can join a chat room\n- Users can send messages that appear on all nodes\n- Messages are routed via the Macula mesh (pub/sub)\n- Users can query \"who's online\" (RPC call)\n- Graceful handling of nodes joining/leaving\n\n**Time to complete**: 30 minutes\n\n**Prerequisites**:\n- Completed [Quick Start Guide](macula_http3_mesh_quick_start.md)\n- Basic Erlang or Elixir knowledge\n- Macula installed and working\n\n---","ref":"macula_http3_mesh_hello_world.html#what-we-ll-build"},{"type":"extras","title":"Project Structure - Hello World","doc":"We'll create a new Mix (Elixir) or Rebar3 (Erlang) project:\n\n```\nmacula_chat/\n├── config/\n│   └── config.exs          # Application configuration\n├── lib/\n│   ├── macula_chat.ex      # Application entry point\n│   ├── chat_room.ex        # Chat room GenServer\n│   └── chat_client.ex      # User client\n├── mix.exs                 # Project definition\n└── README.md\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#project-structure"},{"type":"extras","title":"Step 1: Create New Project - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-1-create-new-project"},{"type":"extras","title":"Using Mix (Elixir) - Hello World","doc":"```bash\nmix new macula_chat --sup\ncd macula_chat\n```","ref":"macula_http3_mesh_hello_world.html#using-mix-elixir"},{"type":"extras","title":"Using Rebar3 (Erlang) - Hello World","doc":"```bash\nrebar3 new app macula_chat\ncd macula_chat\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#using-rebar3-erlang"},{"type":"extras","title":"Step 2: Add Macula Dependency - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-2-add-macula-dependency"},{"type":"extras","title":"Mix (Elixir) - Hello World","doc":"Edit `mix.exs`:\n\n```elixir\ndefmodule MaculaChat.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      app: :macula_chat,\n      version: \"0.1.0\",\n      elixir: \"~> 1.15\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps()\n    ]\n  end\n\n  def application do\n    [\n      extra_applications: [:logger],\n      mod: {MaculaChat.Application, []}\n    ]\n  end\n\n  defp deps do\n    [\n      {:macula, \"~> 0.6\"}\n    ]\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#mix-elixir"},{"type":"extras","title":"Rebar3 (Erlang) - Hello World","doc":"Edit `rebar.config`:\n\n```erlang\n{erl_opts, [debug_info]}.\n\n{deps, [\n    {macula, \"0.6.6\"}\n]}.\n\n{shell, [\n    {apps, [macula_chat]}\n]}.\n```","ref":"macula_http3_mesh_hello_world.html#rebar3-erlang"},{"type":"extras","title":"Install Dependencies - Hello World","doc":"```bash\n# Mix\nmix deps.get\n\n# Rebar3\nrebar3 get-deps\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#install-dependencies"},{"type":"extras","title":"Step 3: Configure Macula - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-3-configure-macula"},{"type":"extras","title":"Mix Configuration - Hello World","doc":"Create `config/config.exs`:\n\n```elixir\nimport Config\n\nconfig :macula,\n  realm: \"io.macula.chat\",\n  listen_port: System.get_env(\"MACULA_PORT\", \"4433\") |> String.to_integer(),\n  discovery: [\n    methods: [:static, :mdns],\n    static_nodes: []  # Add bootstrap nodes via env var\n  ],\n  topology: [\n    type: :k_regular,\n    k: 2\n  ],\n  cert_mode: :auto_generate,\n  log_level: :info\n\n# Chat-specific config\nconfig :macula_chat,\n  username: System.get_env(\"CHAT_USER\", \"Anonymous\"),\n  room: System.get_env(\"CHAT_ROOM\", \"general\")\n```","ref":"macula_http3_mesh_hello_world.html#mix-configuration"},{"type":"extras","title":"Rebar3 Configuration - Hello World","doc":"Create `config/sys.config`:\n\n```erlang\n[\n {macula, [\n   {realm, <<\"io.macula.chat\">>},\n   {listen_port, 4433},\n   {discovery, [\n     {methods, [static, mdns]},\n     {static_nodes, []}\n   ]},\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n   {cert_mode, auto_generate},\n   {log_level, info}\n ]},\n\n {macula_chat, [\n   {username, <<\"Anonymous\">>},\n   {room, <<\"general\">>}\n ]}\n].\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#rebar3-configuration"},{"type":"extras","title":"Step 4: Implement Chat Room - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-4-implement-chat-room"},{"type":"extras","title":"Elixir Implementation - Hello World","doc":"Create `lib/chat_room.ex`:\n\n```elixir\ndefmodule MaculaChat.ChatRoom do\n  @moduledoc \"\"\"\n  Chat room GenServer that handles:\n  - Subscribing to chat messages\n  - Publishing messages to the room\n  - Tracking online users\n  \"\"\"\n\n  use GenServer\n  require Logger\n\n  @topic_prefix \"io.macula.chat.room\"","ref":"macula_http3_mesh_hello_world.html#elixir-implementation"},{"type":"extras","title":"Client API - Hello World","doc":"def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"Send a message to the chat room\"\n  def send_message(message) do\n    GenServer.cast(__MODULE__, {:send_message, message})\n  end\n\n  @doc \"Get list of online users (RPC)\"\n  def get_online_users do\n    GenServer.call(__MODULE__, :get_online_users)\n  end\n\n  @doc \"Join a chat room\"\n  def join_room(room_name) do\n    GenServer.call(__MODULE__, {:join_room, room_name})\n  end","ref":"macula_http3_mesh_hello_world.html#client-api"},{"type":"extras","title":"Server Callbacks - Hello World","doc":"def init(opts) do\n    username = Keyword.get(opts, :username, \"Anonymous\")\n    room = Keyword.get(opts, :room, \"general\")\n\n    state = %{\n      username: username,\n      room: room,\n      topic: \"#{@topic_prefix}.#{room}\",\n      presence_topic: \"#{@topic_prefix}.#{room}.presence\",\n      online_users: %{}\n    }\n\n    # Subscribe to room messages\n    :ok = Macula.PubSub.subscribe(state.topic, self())\n\n    # Subscribe to presence (join/leave notifications)\n    :ok = Macula.PubSub.subscribe(state.presence_topic, self())\n\n    # Register RPC endpoint for \"who's online\"\n    rpc_name = \"chat.#{room}.users\"\n    :ok = Macula.RPC.register(rpc_name, fn _ ->\n      {:ok, Map.keys(state.online_users)}\n    end)\n\n    # Announce presence\n    announce_join(state)\n\n    # Schedule periodic presence heartbeat\n    schedule_heartbeat()\n\n    Logger.info(\"Joined chat room: #{room} as #{username}\")\n\n    {:ok, state}\n  end\n\n  def handle_call(:get_online_users, _from, state) do\n    users = Map.keys(state.online_users)\n    {:reply, {:ok, users}, state}\n  end\n\n  def handle_call({:join_room, new_room}, _from, state) do\n    # Unsubscribe from old room\n    Macula.PubSub.unsubscribe(state.topic, self())\n    Macula.PubSub.unsubscribe(state.presence_topic, self())\n\n    # Announce leave\n    announce_leave(state)\n\n    # Update state\n    new_state = %{state |\n      room: new_room,\n      topic: \"#{@topic_prefix}.#{new_room}\",\n      presence_topic: \"#{@topic_prefix}.#{new_room}.presence\",\n      online_users: %{}\n    }\n\n    # Subscribe to new room\n    :ok = Macula.PubSub.subscribe(new_state.topic, self())\n    :ok = Macula.PubSub.subscribe(new_state.presence_topic, self())\n\n    # Announce join\n    announce_join(new_state)\n\n    Logger.info(\"Switched to chat room: #{new_room}\")\n\n    {:reply, :ok, new_state}\n  end\n\n  def handle_cast({:send_message, message}, state) do\n    # Publish message to room\n    payload = %{\n      username: state.username,\n      message: message,\n      timestamp: System.system_time(:millisecond),\n      node_id: Macula.node_id()\n    }\n\n    :ok = Macula.PubSub.publish(state.topic, payload)\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :message} = event}, state) do\n    # Received chat message\n    username = event.username\n    message = event.message\n    timestamp = event.timestamp\n\n    # Format timestamp\n    {:ok, dt} = DateTime.from_unix(timestamp, :millisecond)\n    time_str = Calendar.strftime(dt, \"%H:%M:%S\")\n\n    # Print to console\n    IO.puts(\"[#{time_str}] <#{username}> #{message}\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :join} = event}, state) do\n    # User joined\n    username = event.username\n    node_id = event.node_id\n\n    state = put_in(state.online_users[username], node_id)\n\n    Logger.info(\"#{username} joined the room\")\n    IO.puts(\"*** #{username} joined the room\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :leave} = event}, state) do\n    # User left\n    username = event.username\n\n    {_node_id, state} = pop_in(state.online_users[username])\n\n    Logger.info(\"#{username} left the room\")\n    IO.puts(\"*** #{username} left the room\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :heartbeat} = event}, state) do\n    # Presence heartbeat\n    username = event.username\n    node_id = event.node_id\n\n    state = put_in(state.online_users[username], node_id)\n\n    {:noreply, state}\n  end\n\n  def handle_info(:send_heartbeat, state) do\n    announce_heartbeat(state)\n    schedule_heartbeat()\n    {:noreply, state}\n  end","ref":"macula_http3_mesh_hello_world.html#server-callbacks"},{"type":"extras","title":"Private Functions - Hello World","doc":"defp announce_join(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :join,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp announce_leave(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :leave,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp announce_heartbeat(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :heartbeat,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp schedule_heartbeat do\n    Process.send_after(self(), :send_heartbeat, 30_000)  # Every 30 seconds\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#private-functions"},{"type":"extras","title":"Erlang Implementation - Hello World","doc":"Create `src/chat_room.erl`:\n\n```erlang\n-module(chat_room).\n-behaviour(gen_server).\n\n-export([start_link/1, send_message/1, get_online_users/0, join_room/1]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-define(TOPIC_PREFIX, <<\"io.macula.chat.room\">>).\n\n%% Client API\n\nstart_link(Opts) ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, Opts, []).\n\nsend_message(Message) ->\n    gen_server:cast(?MODULE, {send_message, Message}).\n\nget_online_users() ->\n    gen_server:call(?MODULE, get_online_users).\n\njoin_room(RoomName) ->\n    gen_server:call(?MODULE, {join_room, RoomName}).\n\n%% Server Callbacks\n\ninit(Opts) ->\n    Username = proplists:get_value(username, Opts, <<\"Anonymous\">>),\n    Room = proplists:get_value(room, Opts, <<\"general\">>),\n\n    Topic = <<?TOPIC_PREFIX/binary, \".\", Room/binary>>,\n    PresenceTopic = < >,\n\n    State = #{\n        username => Username,\n        room => Room,\n        topic => Topic,\n        presence_topic => PresenceTopic,\n        online_users => #{}\n    },\n\n    %% Subscribe to room messages\n    ok = macula_pubsub:subscribe(Topic, self()),\n    ok = macula_pubsub:subscribe(PresenceTopic, self()),\n\n    %% Register RPC endpoint\n    RpcName = <<\"chat.\", Room/binary, \".users\">>,\n    ok = macula_rpc:register(RpcName, fun(_Args) ->\n        {ok, maps:keys(maps:get(online_users, State))}\n    end),\n\n    %% Announce presence\n    announce_join(State),\n\n    %% Schedule heartbeat\n    schedule_heartbeat(),\n\n    logger:info(\"Joined chat room: ~s as ~s\", [Room, Username]),\n\n    {ok, State}.\n\nhandle_call(get_online_users, _From, State) ->\n    Users = maps:keys(maps:get(online_users, State)),\n    {reply, {ok, Users}, State};\n\nhandle_call({join_room, NewRoom}, _From, State) ->\n    %% Unsubscribe from old room\n    macula_pubsub:unsubscribe(maps:get(topic, State), self()),\n    macula_pubsub:unsubscribe(maps:get(presence_topic, State), self()),\n\n    %% Announce leave\n    announce_leave(State),\n\n    %% Update state\n    NewTopic = <<?TOPIC_PREFIX/binary, \".\", NewRoom/binary>>,\n    NewPresenceTopic = < >,\n\n    NewState = State#{\n        room => NewRoom,\n        topic => NewTopic,\n        presence_topic => NewPresenceTopic,\n        online_users => #{}\n    },\n\n    %% Subscribe to new room\n    ok = macula_pubsub:subscribe(NewTopic, self()),\n    ok = macula_pubsub:subscribe(NewPresenceTopic, self()),\n\n    %% Announce join\n    announce_join(NewState),\n\n    logger:info(\"Switched to chat room: ~s\", [NewRoom]),\n\n    {reply, ok, NewState}.\n\nhandle_cast({send_message, Message}, State) ->\n    Payload = #{\n        type => message,\n        username => maps:get(username, State),\n        message => Message,\n        timestamp => erlang:system_time(millisecond),\n        node_id => macula:node_id()\n    },\n\n    ok = macula_pubsub:publish(maps:get(topic, State), Payload),\n\n    {noreply, State}.\n\nhandle_info({event, _Topic, #{type := message} = Event}, State) ->\n    Username = maps:get(username, Event),\n    Message = maps:get(message, Event),\n    Timestamp = maps:get(timestamp, Event),\n\n    %% Print to console\n    {{Y,M,D},{H,Min,S}} = calendar:system_time_to_universal_time(Timestamp, millisecond),\n    io:format(\"[~2..0B:~2..0B:~2..0B] <~s> ~s~n\", [H, Min, S, Username, Message]),\n\n    {noreply, State};\n\nhandle_info({event, _Topic, #{type := join} = Event}, State) ->\n    Username = maps:get(username, Event),\n    NodeId = maps:get(node_id, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:put(Username, NodeId, OnlineUsers),\n\n    io:format(\"*** ~s joined the room~n\", [Username]),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info({event, _Topic, #{type := leave} = Event}, State) ->\n    Username = maps:get(username, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:remove(Username, OnlineUsers),\n\n    io:format(\"*** ~s left the room~n\", [Username]),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info({event, _Topic, #{type := heartbeat} = Event}, State) ->\n    Username = maps:get(username, Event),\n    NodeId = maps:get(node_id, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:put(Username, NodeId, OnlineUsers),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info(send_heartbeat, State) ->\n    announce_heartbeat(State),\n    schedule_heartbeat(),\n    {noreply, State}.\n\n%% Private Functions\n\nannounce_join(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => join,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nannounce_leave(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => leave,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nannounce_heartbeat(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => heartbeat,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nschedule_heartbeat() ->\n    erlang:send_after(30000, self(), send_heartbeat).\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang-implementation"},{"type":"extras","title":"Step 5: Update Application Supervisor - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-5-update-application-supervisor"},{"type":"extras","title":"Elixir - Hello World","doc":"Edit `lib/macula_chat/application.ex`:\n\n```elixir\ndefmodule MaculaChat.Application do\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    # Get config\n    username = Application.get_env(:macula_chat, :username, \"Anonymous\")\n    room = Application.get_env(:macula_chat, :room, \"general\")\n\n    children = [\n      # Start Macula mesh\n      {Macula, []},\n\n      # Start chat room\n      {MaculaChat.ChatRoom, [username: username, room: room]}\n    ]\n\n    opts = [strategy: :one_for_one, name: MaculaChat.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#elixir"},{"type":"extras","title":"Erlang - Hello World","doc":"Edit `src/macula_chat_app.erl`:\n\n```erlang\n-module(macula_chat_app).\n-behaviour(application).\n\n-export([start/2, stop/1]).\n\nstart(_StartType, _StartArgs) ->\n    %% Get config\n    {ok, Username} = application:get_env(macula_chat, username),\n    {ok, Room} = application:get_env(macula_chat, room),\n\n    Children = [\n        %% Start Macula mesh\n        #{\n            id => macula,\n            start => {macula, start_link, []},\n            restart => permanent,\n            type => supervisor\n        },\n\n        %% Start chat room\n        #{\n            id => chat_room,\n            start => {chat_room, start_link, [[{username, Username}, {room, Room}]]},\n            restart => permanent,\n            type => worker\n        }\n    ],\n\n    SupFlags = #{strategy => one_for_one, intensity => 1, period => 5},\n\n    supervisor:start_link({local, macula_chat_sup}, ?MODULE, {SupFlags, Children}).\n\nstop(_State) ->\n    ok.\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang"},{"type":"extras","title":"Step 6: Create Interactive Client - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-6-create-interactive-client"},{"type":"extras","title":"Elixir - Hello World","doc":"Create `lib/chat_client.ex`:\n\n```elixir\ndefmodule MaculaChat.Client do\n  @moduledoc \"\"\"\n  Interactive chat client - run from IEx\n  \"\"\"\n\n  @doc \"Send a message to the chat room\"\n  def say(message) when is_binary(message) do\n    MaculaChat.ChatRoom.send_message(message)\n    :ok\n  end\n\n  @doc \"List who's online\"\n  def who do\n    {:ok, users} = MaculaChat.ChatRoom.get_online_users()\n    IO.puts(\"\\nOnline users (#{length(users)}):\")\n    Enum.each(users, fn user ->\n      IO.puts(\"  - #{user}\")\n    end)\n    :ok\n  end\n\n  @doc \"Switch to different room\"\n  def join(room_name) when is_binary(room_name) do\n    :ok = MaculaChat.ChatRoom.join_room(room_name)\n    IO.puts(\"Joined room: #{room_name}\")\n    :ok\n  end\n\n  @doc \"Show help\"\n  def help do\n    IO.puts(\"\"\"\n\n    Macula Chat Client Commands:\n    =============================\n\n    Chat.say(\"message\")     - Send a message\n    Chat.who()              - List online users\n    Chat.join(\"room\")       - Switch to different room\n    Chat.help()             - Show this help\n\n    Examples:\n      Chat.say(\"Hello world!\")\n      Chat.who()\n      Chat.join(\"random\")\n\n    \"\"\")\n    :ok\n  end\nend\n\n# Alias for convenience\nalias MaculaChat.Client, as: Chat\n```","ref":"macula_http3_mesh_hello_world.html#elixir-1"},{"type":"extras","title":"Erlang - Hello World","doc":"Create `src/chat_client.erl`:\n\n```erlang\n-module(chat_client).\n-export([say/1, who/0, join/1, help/0]).\n\nsay(Message) when is_binary(Message) ->\n    chat_room:send_message(Message),\n    ok.\n\nwho() ->\n    {ok, Users} = chat_room:get_online_users(),\n    io:format(\"~nOnline users (~p):~n\", [length(Users)]),\n    lists:foreach(fun(User) ->\n        io:format(\"  - ~s~n\", [User])\n    end, Users),\n    ok.\n\njoin(RoomName) when is_binary(RoomName) ->\n    ok = chat_room:join_room(RoomName),\n    io:format(\"Joined room: ~s~n\", [RoomName]),\n    ok.\n\nhelp() ->\n    io:format(\"~n~s~n\", [\n        \"Macula Chat Client Commands:\\n\"\n        \"=============================\\n\"\n        \"\\n\"\n        \"chat_client:say(<<\\\"message\\\">>)     - Send a message\\n\"\n        \"chat_client:who()                   - List online users\\n\"\n        \"chat_client:join(<<\\\"room\\\">>)        - Switch to different room\\n\"\n        \"chat_client:help()                  - Show this help\\n\"\n        \"\\n\"\n        \"Examples:\\n\"\n        \"  chat_client:say(<<\\\"Hello world!\\\">>).\\n\"\n        \"  chat_client:who().\\n\"\n        \"  chat_client:join(<<\\\"random\\\">>).\\n\"\n    ]),\n    ok.\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang-1"},{"type":"extras","title":"Step 7: Run the Chat Application - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-7-run-the-chat-application"},{"type":"extras","title":"Terminal 1: User \"Alice\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Alice CHAT_ROOM=general MACULA_PORT=4433 iex -S mix\n\n# Erlang\nCHAT_USER=Alice CHAT_ROOM=general MACULA_PORT=4433 rebar3 shell\n\n# You should see:\n[info] Macula node started\n[info] Joined chat room: general as Alice\n```","ref":"macula_http3_mesh_hello_world.html#terminal-1-user-alice"},{"type":"extras","title":"Terminal 2: User \"Bob\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Bob CHAT_ROOM=general MACULA_PORT=4434 iex -S mix\n\n# Erlang\nCHAT_USER=Bob CHAT_ROOM=general MACULA_PORT=4434 rebar3 shell\n\n# Both terminals show:\n*** Bob joined the room\n```","ref":"macula_http3_mesh_hello_world.html#terminal-2-user-bob"},{"type":"extras","title":"Terminal 3: User \"Charlie\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Charlie CHAT_ROOM=general MACULA_PORT=4435 iex -S mix\n\n# Erlang\nCHAT_USER=Charlie CHAT_ROOM=general MACULA_PORT=4435 rebar3 shell\n\n# All terminals show:\n*** Charlie joined the room\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#terminal-3-user-charlie"},{"type":"extras","title":"Step 8: Chat! - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-8-chat"},{"type":"extras","title":"Send Messages - Hello World","doc":"**In Alice's terminal (Elixir)**:\n```elixir\nChat.say(\"Hello everyone!\")\n```\n\n**In Bob's terminal (Erlang)**:\n```erlang\nchat_client:say(<<\"Hey Alice!\">>).\n```\n\n**In Charlie's terminal**:\n```elixir\nChat.say(\"What's up?\")\n```\n\n**All terminals show**:\n```\n[12:34:56]   Hello everyone!\n[12:34:58]   Hey Alice!\n[12:35:01]   What's up?\n```","ref":"macula_http3_mesh_hello_world.html#send-messages"},{"type":"extras","title":"List Online Users - Hello World","doc":"**In any terminal (Elixir)**:\n```elixir\nChat.who()\n```\n\n**Output**:\n```\nOnline users (3):\n  - Alice\n  - Bob\n  - Charlie\n```","ref":"macula_http3_mesh_hello_world.html#list-online-users"},{"type":"extras","title":"Switch Rooms - Hello World","doc":"**In Charlie's terminal**:\n```elixir\nChat.join(\"random\")\n```\n\n**Alice and Bob's terminals show**:\n```\n*** Charlie left the room\n```\n\n**Charlie's terminal shows**:\n```\nJoined room: random\n```\n\nNow Charlie is in a different room and won't see messages in \"general\".\n\n---","ref":"macula_http3_mesh_hello_world.html#switch-rooms"},{"type":"extras","title":"Step 9: Test Fault Tolerance - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-9-test-fault-tolerance"},{"type":"extras","title":"Stop Bob's Node - Hello World","doc":"In Bob's terminal, press `Ctrl+C` twice.\n\n**Alice and Charlie's terminals show**:\n```\n*** Bob left the room\n```","ref":"macula_http3_mesh_hello_world.html#stop-bob-s-node"},{"type":"extras","title":"Restart Bob - Hello World","doc":"Restart Bob's node (same command as before).\n\n**All terminals show**:\n```\n*** Bob joined the room\n```\n\n**Messages continue flowing** - the mesh automatically reconnected Bob.\n\n---","ref":"macula_http3_mesh_hello_world.html#restart-bob"},{"type":"extras","title":"Understanding the Architecture - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#understanding-the-architecture"},{"type":"extras","title":"Message Flow (Pub/Sub) - Hello World","doc":"```\nAlice's Node                   Macula Mesh                   Bob's Node\n┌──────────────┐              ┌─────────────┐              ┌──────────────┐\n│ Chat.say()   │──publish───→ │   Topic:    │ ──route───→ │ handle_info  │\n│              │              │ io.macula.  │              │ {:event,...} │\n│              │              │ chat.room.  │              │              │\n│              │              │ general     │              │ IO.puts()    │\n└──────────────┘              └─────────────┘              └──────────────┘\n```\n\n**How it works**:\n1. Alice calls `Chat.say(\"hello\")`\n2. ChatRoom GenServer calls `Macula.PubSub.publish(topic, %{message: \"hello\"})`\n3. Macula encodes the message and sends it via QUIC to subscribers\n4. Bob's ChatRoom GenServer receives `{:event, topic, payload}`\n5. Bob's node prints the message to console\n\n**No central server** - messages route peer-to-peer through the mesh!","ref":"macula_http3_mesh_hello_world.html#message-flow-pub-sub"},{"type":"extras","title":"RPC Flow (Who's Online) - Hello World","doc":"```\nAlice's Node                   Macula Mesh                   Bob's Node\n┌──────────────┐              ┌─────────────┐              ┌──────────────┐\n│ Chat.who()   │──RPC call──→ │   Routing   │ ──lookup──→ │ RPC Handler  │\n│              │              │   Table     │              │              │\n│              │ ←──result──  │   (DHT)     │ ←─return──  │ return users │\n│              │              │             │              │              │\n│ Print users  │              └─────────────┘              └──────────────┘\n└──────────────┘\n```\n\n**How it works**:\n1. Alice calls `Chat.who()`\n2. ChatRoom calls `Macula.RPC.call(\"chat.general.users\", %{})`\n3. Macula looks up which node registered \"chat.general.users\" (could be any node)\n4. Macula routes RPC request to that node\n5. RPC handler executes and returns list of users\n6. Result routes back to Alice\n7. Alice prints the list\n\n**Distributed RPC** - any node can register an endpoint, any node can call it!\n\n---","ref":"macula_http3_mesh_hello_world.html#rpc-flow-who-s-online"},{"type":"extras","title":"Enhancements - Hello World","doc":"Try adding these features:","ref":"macula_http3_mesh_hello_world.html#enhancements"},{"type":"extras","title":"1. Private Messages (DMs) - Hello World","doc":"```elixir\n# In chat_room.ex\ndef send_dm(to_username, message) do\n  GenServer.cast(__MODULE__, {:send_dm, to_username, message})\nend\n\ndef handle_cast({:send_dm, to_username, message}, state) do\n  # Find target user's node via presence\n  case Map.get(state.online_users, to_username) do\n    nil ->\n      IO.puts(\"User #{to_username} not found\")\n\n    node_id ->\n      # Send directly to that node\n      topic = \"io.macula.chat.dm.#{node_id}\"\n      payload = %{\n        from: state.username,\n        to: to_username,\n        message: message,\n        timestamp: System.system_time(:millisecond)\n      }\n\n      Macula.PubSub.publish(topic, payload)\n  end\n\n  {:noreply, state}\nend\n```","ref":"macula_http3_mesh_hello_world.html#1-private-messages-dms"},{"type":"extras","title":"2. Message History (Last 10 Messages) - Hello World","doc":"```elixir\n# In chat_room.ex\ndef init(opts) do\n  # ... existing code ...\n\n  state = Map.put(state, :message_history, [])\n\n  # ... rest of init ...\nend\n\ndef handle_info({:event, _topic, %{type: :message} = event}, state) do\n  # ... existing code to print message ...\n\n  # Store in history\n  history = [event | state.message_history] |> Enum.take(10)\n  state = Map.put(state, :message_history, history)\n\n  {:noreply, state}\nend\n\ndef get_history do\n  GenServer.call(__MODULE__, :get_history)\nend\n\ndef handle_call(:get_history, _from, state) do\n  {:reply, {:ok, Enum.reverse(state.message_history)}, state}\nend\n```","ref":"macula_http3_mesh_hello_world.html#2-message-history-last-10-messages"},{"type":"extras","title":"3. Typing Indicator - Hello World","doc":"```elixir\n# In chat_client.ex\ndef typing do\n  # Publish ephemeral \"typing\" event\n  Macula.PubSub.publish(\"io.macula.chat.room.general.typing\", %{\n    username: MaculaChat.ChatRoom.get_username(),\n    timestamp: System.system_time(:millisecond)\n  })\nend\n```","ref":"macula_http3_mesh_hello_world.html#3-typing-indicator"},{"type":"extras","title":"4. File Sharing - Hello World","doc":"Use RPC to request file chunks:\n\n```elixir\ndef share_file(filename) do\n  # Read file and encode as base64\n  content = File.read!(filename) |> Base.encode64()\n\n  # Announce file availability\n  Macula.PubSub.publish(\"io.macula.chat.room.general.file\", %{\n    filename: Path.basename(filename),\n    size: byte_size(content),\n    owner: Macula.node_id()\n  })\n\n  # Register RPC endpoint to serve chunks\n  Macula.RPC.register(\"chat.file.#{filename}\", fn %{offset: offset, length: length} ->\n    chunk = binary_part(content, offset, length)\n    {:ok, %{chunk: chunk}}\n  end)\nend\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#4-file-sharing"},{"type":"extras","title":"What You've Learned - Hello World","doc":"Congratulations! You've built a fully distributed chat application using Macula. You now understand:\n\n✅ **Pub/Sub**: How to publish events and subscribe to topics across the mesh\n✅ **RPC**: How to register callable endpoints and invoke them from any node\n✅ **Mesh Topology**: How nodes discover each other and form a network\n✅ **Fault Tolerance**: How the mesh adapts when nodes join/leave\n✅ **Presence**: How to track who's online using heartbeats\n✅ **BEAM OTP**: How to structure applications with GenServers and supervisors\n\n---","ref":"macula_http3_mesh_hello_world.html#what-you-ve-learned"},{"type":"extras","title":"Next Steps - Hello World","doc":"- **[API Reference](macula_http3_mesh_api_reference.md)** - Explore all Macula APIs\n- **[Deployment Patterns](macula_http3_mesh_deployment_patterns.md)** - Deploy to production\n- **[Performance Tuning](macula_http3_mesh_performance.md)** - Optimize for scale\n- **[Security Model](macula_http3_mesh_security.md)** - Secure your mesh\n- **Build something cool!** Share it with the community on Discord\n\n---\n\n**Happy coding!** 🚀","ref":"macula_http3_mesh_hello_world.html#next-steps"},{"type":"extras","title":"Roadmap","doc":"# Macula HTTP/3 Mesh: Comprehensive Technical Roadmap","ref":"macula_http3_mesh_roadmap.html"},{"type":"extras","title":"Executive Summary - Roadmap","doc":"**Vision:** Macula enables distributed BEAM applications to form encrypted, self-healing mesh networks over HTTP/3, with zero infrastructure dependencies. Works behind NATs, scales to thousands of nodes, native distributed Erlang semantics - all over standard HTTPS.\n\n**The \"Wow\" Factor:**\n- Distributed Erlang over HTTP/3 (nobody else does this!)\n- Works through corporate firewalls (it's just HTTPS!)\n- Self-healing mesh topology (no central coordinator)\n- Built-in NAT traversal (QUIC magic)\n- Native BEAM implementation (minimal NIFs)\n\n**Timeline:** 20 weeks (5 months)\n\n**Outcome:** Production-ready mesh networking infrastructure for edge BEAM applications.\n\n---","ref":"macula_http3_mesh_roadmap.html#executive-summary"},{"type":"extras","title":"Table of Contents - Roadmap","doc":"1. [Understanding QUIC and HTTP/3](#understanding-quic-and-http3)\n2. [QUIC/HTTP/3 Libraries for BEAM](#quic-http3-libraries-for-beam)\n3. [Architecture Overview](#architecture-overview)\n4. [Detailed Roadmap](#detailed-roadmap)\n5. [Architecture Diagrams](#architecture-diagrams)\n6. [Technical Deep Dives](#technical-deep-dives)\n7. [Success Metrics](#success-metrics)\n\n---","ref":"macula_http3_mesh_roadmap.html#table-of-contents"},{"type":"extras","title":"Understanding QUIC and HTTP/3 - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#understanding-quic-and-http-3"},{"type":"extras","title":"What is QUIC? - Roadmap","doc":"**QUIC (Quick UDP Internet Connections)** is a modern transport protocol developed by Google and standardized by IETF as RFC 9000. It's designed to replace TCP for web traffic.\n\n#### Key Characteristics\n\n**1. UDP-Based Transport**\n```\nTraditional:  HTTP/2 → TLS → TCP → IP\nModern:       HTTP/3 → QUIC (includes TLS 1.3) → UDP → IP\n```\n\nQUIC runs over UDP instead of TCP, which provides several advantages:\n- Faster connection establishment (0-RTT and 1-RTT)\n- No head-of-line blocking across streams\n- Better performance on lossy networks\n- Easier NAT traversal (UDP is simpler than TCP for NAT)\n\n**2. Built-in Encryption**\n- TLS 1.3 is integrated into QUIC (not layered on top)\n- All packets are encrypted (except initial handshake metadata)\n- Forward secrecy by default\n- Connection migration (can change IP addresses mid-connection)\n\n**3. Multiplexed Streams**\n```\n┌─────────────────────────────────────┐\n│ QUIC Connection                     │\n│  ┌───────────┐ ┌───────────┐       │\n│  │ Stream 0  │ │ Stream 1  │  ...  │\n│  │ (Ordered) │ │ (Ordered) │       │\n│  └───────────┘ └───────────┘       │\n│                                     │\n│  Streams are independent!           │\n│  Loss in Stream 0 doesn't block     │\n│  Stream 1 (unlike TCP)              │\n└─────────────────────────────────────┘\n```\n\n**4. Connection Establishment**\n\nTraditional TCP + TLS:\n```\nClient → Server:  SYN                        (1 RTT)\nServer → Client:  SYN-ACK\nClient → Server:  ACK\nClient → Server:  ClientHello (TLS)          (2 RTT)\nServer → Client:  ServerHello + Certificate\nClient → Server:  Finished\nServer → Client:  Finished\nClient → Server:  HTTP Request               (3 RTT)\n                  Total: 3 Round Trips\n```\n\nQUIC (first connection):\n```\nClient → Server:  Initial (ClientHello)      (1 RTT)\nServer → Client:  Handshake (ServerHello)\nClient → Server:  HTTP Request               (1 RTT)\n                  Total: 1 Round Trip\n```\n\nQUIC (resumed connection):\n```\nClient → Server:  0-RTT Data + HTTP Request  (0 RTT!)\n                  Total: 0 Round Trips\n```\n\n**5. Loss Recovery**\n- Per-stream reliability (not per-connection like TCP)\n- More sophisticated than TCP (monotonically increasing packet numbers)\n- Better handling of spurious retransmissions\n- Pluggable congestion control\n\n**6. Connection Migration**\n```\nMobile device scenario:\nWiFi (IP: 192.168.1.100) → Cellular (IP: 10.20.30.40)\n\nTCP:  Connection breaks, must reconnect (new handshake)\nQUIC: Connection continues seamlessly (connection ID stays same)\n```","ref":"macula_http3_mesh_roadmap.html#what-is-quic"},{"type":"extras","title":"What is HTTP/3? - Roadmap","doc":"**HTTP/3** is the third major version of HTTP, using QUIC as its transport instead of TCP.\n\n#### HTTP Evolution\n\n```\nHTTP/1.1 (1997)\n  ↓\n  - Text-based protocol\n  - One request per connection (or pipelining)\n  - Head-of-line blocking\n\nHTTP/2 (2015)\n  ↓\n  - Binary framing\n  - Multiplexing over single TCP connection\n  - Header compression (HPACK)\n  - Still suffers from TCP head-of-line blocking\n\nHTTP/3 (2022)\n  ↓\n  - Same semantics as HTTP/2\n  - QUIC transport (UDP-based)\n  - No head-of-line blocking\n  - 0-RTT connection resumption\n  - Better mobile performance\n```\n\n#### HTTP/3 Frame Types\n\nHTTP/3 uses similar frames to HTTP/2 but adapted for QUIC:\n\n```\nFrame Types:\n- DATA:        Application data (response body)\n- HEADERS:     HTTP headers (compressed with QPACK)\n- PRIORITY:    Stream priority hints\n- CANCEL_PUSH: Cancel server push\n- SETTINGS:    Connection parameters\n- PUSH_PROMISE: Server push announcement\n- GOAWAY:      Graceful shutdown\n- MAX_PUSH_ID: Limit server push\n```\n\n#### QPACK Header Compression\n\nHTTP/3 uses QPACK (QUIC-aware header compression) instead of HPACK:\n- Dynamic table updates on dedicated stream\n- Prevents head-of-line blocking from header compression\n- Better performance on lossy networks","ref":"macula_http3_mesh_roadmap.html#what-is-http-3"},{"type":"extras","title":"Why QUIC/HTTP/3 for Macula Mesh? - Roadmap","doc":"#### 1. **NAT Traversal**\nUDP is much easier to punch through NATs than TCP:\n- Simpler state machines in NAT devices\n- Easier simultaneous open\n- Better compatibility with STUN/TURN\n\n#### 2. **Multiplexing Without Head-of-Line Blocking**\nPerfect for distributed Erlang:\n```\nProcess A → Stream 0:  send(...) → [packet lost!] → retransmit\nProcess B → Stream 1:  send(...) → delivered immediately!\n\nWith TCP: Process B would be blocked waiting for Process A's retransmit\nWith QUIC: Process B's stream is independent\n```\n\n#### 3. **Connection Migration**\nEdge devices often change networks:\n```\nIoT device switches from WiFi to cellular:\n  - TCP: Connection lost, full reconnect\n  - QUIC: Seamless migration, no interruption\n```\n\n#### 4. **Firewall Friendly**\n- Uses port 443 (standard HTTPS)\n- Looks like HTTPS to middleboxes\n- No special firewall rules needed\n\n#### 5. **0-RTT Resumption**\nReconnecting nodes don't waste time:\n```\nNode rejoins mesh after brief disconnect:\n  - TCP + TLS: 3 RTT to re-establish\n  - QUIC 0-RTT: Immediate data transmission\n```\n\n#### 6. **Built-in Encryption**\n- TLS 1.3 integrated (not optional)\n- Perfect forward secrecy\n- No configuration needed","ref":"macula_http3_mesh_roadmap.html#why-quic-http-3-for-macula-mesh"},{"type":"extras","title":"QUIC Protocol Details - Roadmap","doc":"#### Connection ID\n\nQUIC uses Connection IDs instead of 4-tuple (src IP, src port, dst IP, dst port):\n\n```\n┌─────────────────────────────────────┐\n│ QUIC Packet                         │\n├─────────────────────────────────────┤\n│ Header:                             │\n│  - Connection ID: 0x1a2b3c4d...     │ ← Identifies connection\n│  - Packet Number: 42                │\n│  - Flags: ...                       │\n├─────────────────────────────────────┤\n│ Encrypted Payload                   │\n└─────────────────────────────────────┘\n\nBenefits:\n- Connection survives IP address changes\n- Load balancers can route without decryption\n- NAT rebinding doesn't break connection\n```\n\n#### Stream Management\n\nQUIC streams are lightweight:\n\n```erlang\n% Each Erlang process can have its own stream\nspawn(fun() ->\n    {ok, StreamId} = quic:open_stream(Conn),\n    quic:send(StreamId, Data),\n    receive\n        {stream_data, StreamId, Response} -> handle(Response)\n    end,\n    quic:close_stream(StreamId)\nend).\n\n% Streams are cheap! Can create thousands\n% No overhead like TCP sockets\n```\n\n#### Congestion Control\n\nQUIC implements multiple congestion control algorithms:\n\n- **Reno**: Traditional TCP-like\n- **Cubic**: Linux default (aggressive)\n- **BBR**: Google's Bottleneck Bandwidth and RTT\n- **Custom**: Can implement your own!\n\nFor Macula Mesh:\n```erlang\n% Could implement edge-optimized congestion control\n-module(macula_congestion).\n\nestimate_bandwidth(Samples) ->\n    % Use local measurements instead of RTT\n    % Better for edge networks with variable latency\n    ...\n```\n\n#### Flow Control\n\nQUIC has flow control at two levels:\n\n1. **Stream-level**: Each stream has credit\n2. **Connection-level**: Overall connection credit\n\n```\n┌─────────────────────────────────────┐\n│ Connection Credit: 1 MB             │\n├─────────────────────────────────────┤\n│ Stream 0:  256 KB credit            │\n│ Stream 1:  512 KB credit            │\n│ Stream 2:  256 KB credit            │\n└─────────────────────────────────────┘\n\nPrevents any single stream from starving the connection\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#quic-protocol-details"},{"type":"extras","title":"QUIC/HTTP/3 Libraries for BEAM - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#quic-http-3-libraries-for-beam"},{"type":"extras","title":"1. quicer (Recommended) - Roadmap","doc":"**Repository:** https://github.com/emqx/quic\n**License:** Apache 2.0\n**Maintainer:** EMQX Team (Erlang Solutions)\n**Language:** Erlang + C (NIF wrapper)\n**Backend:** Microsoft MsQuic\n\n#### Overview\n\n`quicer` is an Erlang NIF binding for Microsoft's MsQuic library. MsQuic is a production-grade QUIC implementation used by Windows, Azure, and various Microsoft services.\n\n#### Architecture\n\n```\n┌─────────────────────────────────────┐\n│ Erlang Application                  │\n├─────────────────────────────────────┤\n│ quicer (Erlang API)                 │\n│  - quicer:listen/2                  │\n│  - quicer:connect/3                 │\n│  - quicer:send/2                    │\n│  - quicer:recv/2                    │\n├─────────────────────────────────────┤\n│ quicer NIF (C)                      │\n│  - Erlang ↔ MsQuic bridge          │\n│  - Resource management              │\n│  - Callback handling                │\n├─────────────────────────────────────┤\n│ MsQuic (C)                          │\n│  - RFC 9000 QUIC implementation     │\n│  - TLS 1.3 integration              │\n│  - Platform-specific optimizations  │\n├─────────────────────────────────────┤\n│ OS Network Stack (UDP)              │\n└─────────────────────────────────────┘\n```\n\n#### Features\n\n✅ **Supported:**\n- QUIC v1 (RFC 9000)\n- TLS 1.3\n- 0-RTT connection resumption\n- Connection migration\n- Multiple streams per connection\n- Flow control and congestion control\n- Both client and server modes\n\n❌ **Limitations:**\n- NIF dependency (requires C compilation)\n- Tied to MsQuic release cycle\n- Platform-specific quirks\n\n#### API Examples\n\n```erlang\n%% Server\nstart_server() ->\n    %% Load certificate\n    {ok, Cert} = file:read_file(\"server.crt\"),\n    {ok, Key} = file:read_file(\"server.key\"),\n\n    %% Listen options\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula/1.0\"],\n        peer_unidi_stream_count => 10,\n        peer_bidi_stream_count => 10\n    },\n\n    %% Start listener\n    {ok, Listener} = quicer:listen(\"0.0.0.0\", 4433, ListenOpts),\n\n    %% Accept loop\n    accept_loop(Listener).\n\naccept_loop(Listener) ->\n    {ok, Conn} = quicer:accept(Listener, [], 5000),\n    {ok, Conn} = quicer:handshake(Conn),\n\n    %% Spawn handler\n    spawn(fun() -> handle_connection(Conn) end),\n\n    %% Continue accepting\n    accept_loop(Listener).\n\nhandle_connection(Conn) ->\n    %% Accept stream\n    {ok, Stream} = quicer:accept_stream(Conn, []),\n\n    %% Receive data\n    {ok, Data} = quicer:recv(Stream, 0),\n\n    %% Process and respond\n    Response = process(Data),\n    ok = quicer:send(Stream, Response),\n\n    %% Close stream\n    quicer:close_stream(Stream).\n\n%% Client\nstart_client() ->\n    %% Connect options\n    ConnOpts = #{\n        alpn => [\"macula/1.0\"],\n        verify => verify_peer,\n        cacertfile => \"ca.crt\"\n    },\n\n    %% Connect\n    {ok, Conn} = quicer:connect(\"server.example.com\", 4433, ConnOpts, 5000),\n\n    %% Open stream\n    StreamOpts = #{active => false},\n    {ok, Stream} = quicer:start_stream(Conn, StreamOpts),\n\n    %% Send data\n    ok = quicer:send(Stream, <<\"Hello, QUIC!\">>),\n\n    %% Receive response\n    {ok, Response} = quicer:recv(Stream, 0),\n    io:format(\"Received: ~p~n\", [Response]),\n\n    %% Close\n    quicer:close_stream(Stream),\n    quicer:close_connection(Conn).\n```\n\n#### Production Usage\n\n**EMQX:** Used in EMQX 5.0+ for MQTT over QUIC\n- Handles millions of concurrent connections\n- Production-tested at scale\n- Good performance characteristics\n\n**RabbitMQ:** Experimental QUIC support via quicer\n- AMQP 1.0 over QUIC transport\n- Still in development\n\n#### Pros & Cons\n\n**Pros:**\n- ✅ Battle-tested (MsQuic used in Windows, Azure)\n- ✅ Actively maintained\n- ✅ Good documentation\n- ✅ Performance optimized\n- ✅ Cross-platform (Linux, macOS, Windows)\n- ✅ Production-ready (used in EMQX)\n\n**Cons:**\n- ❌ NIF dependency (requires compilation)\n- ❌ Tied to MsQuic (external C library)\n- ❌ Breaking changes between MsQuic versions\n- ❌ Limited control over low-level behavior\n\n**Verdict:** ⭐⭐⭐⭐⭐ **Best choice for Macula Mesh**","ref":"macula_http3_mesh_roadmap.html#1-quicer-recommended"},{"type":"extras","title":"2. xquic (Alternative) - Roadmap","doc":"**Repository:** https://github.com/alibaba/xquic\n**License:** Apache 2.0\n**Maintainer:** Alibaba Cloud\n**Language:** C + Erlang bindings\n**Backend:** xquic (Alibaba's QUIC)\n\n#### Overview\n\nxquic is Alibaba's in-house QUIC implementation, used in their edge CDN and cloud services.\n\n#### Features\n\n- QUIC v1 + IETF draft-29\n- HTTP/3 support\n- QUIC multipath extension\n- BBR congestion control\n- High performance (optimized for Alibaba scale)\n\n#### Erlang Bindings\n\nErlang bindings exist but are less mature than quicer:\n- https://github.com/emqx/xquic-erl (community maintained)\n\n#### Pros & Cons\n\n**Pros:**\n- ✅ Very high performance\n- ✅ Multipath QUIC support\n- ✅ Used at Alibaba scale\n\n**Cons:**\n- ❌ Less mature Erlang bindings\n- ❌ Documentation mostly in Chinese\n- ❌ Smaller community\n- ❌ Not as widely tested outside Alibaba\n\n**Verdict:** ⭐⭐⭐ **Good but less accessible**","ref":"macula_http3_mesh_roadmap.html#2-xquic-alternative"},{"type":"extras","title":"3. quinn (Rust, via Rustler) - Roadmap","doc":"**Repository:** https://github.com/quinn-rs/quinn\n**License:** Apache 2.0 / MIT\n**Language:** Rust\n**Bindings:** Could use Rustler for Erlang\n\n#### Overview\n\nquinn is a pure Rust QUIC implementation, considered one of the best non-C QUIC libraries.\n\n#### Hypothetical Erlang Integration\n\n```\n┌─────────────────────────────────────┐\n│ Erlang Application                  │\n├─────────────────────────────────────┤\n│ quinn_nif (Rustler)                 │\n│  - Erlang ↔ Rust bridge            │\n├─────────────────────────────────────┤\n│ quinn (Rust)                        │\n│  - Pure Rust QUIC implementation    │\n├─────────────────────────────────────┤\n│ tokio (Rust async runtime)          │\n└─────────────────────────────────────┘\n```\n\n#### Pros & Cons\n\n**Pros:**\n- ✅ Pure Rust (memory safe)\n- ✅ Excellent performance\n- ✅ Active development\n- ✅ Clean API\n\n**Cons:**\n- ❌ No official Erlang bindings\n- ❌ Would need to build Rustler wrapper\n- ❌ Rust async runtime complexity\n- ❌ Additional development effort\n\n**Verdict:** ⭐⭐ **Interesting but requires work**","ref":"macula_http3_mesh_roadmap.html#3-quinn-rust-via-rustler"},{"type":"extras","title":"4. Pure Erlang QUIC (Hypothetical) - Roadmap","doc":"**Status:** Doesn't exist\n**Effort:** 6-12 months of development\n\n#### Why Pure Erlang?\n\n**Pros:**\n- ✅ No NIFs (easier deployment)\n- ✅ Full control over implementation\n- ✅ Could optimize for BEAM semantics\n- ✅ Easier debugging\n\n**Cons:**\n- ❌ Huge development effort\n- ❌ Likely slower than C/Rust\n- ❌ Hard to match performance of tuned C libs\n- ❌ Cryptography still needs NIFs\n\n#### Feasibility Analysis\n\n```\nComponents needed:\n1. UDP socket handling         ✅ (gen_udp)\n2. TLS 1.3 implementation     ⚠️  (ssl app, but need low-level access)\n3. Packet parsing             ✅ (binary pattern matching)\n4. Connection state machine   ✅ (gen_statem)\n5. Stream multiplexing        ✅ (processes)\n6. Flow control               ✅ (credits/backpressure)\n7. Congestion control         ✅ (algorithms in Erlang)\n8. Loss detection             ✅ (timers + state)\n9. 0-RTT resumption          ⚠️  (needs crypto primitives)\n\nEstimated effort: 3-6 person-months for basic implementation\n                 12+ person-months for production-ready\n```\n\n**Verdict:** ⭐ **Not practical for Phase 1**","ref":"macula_http3_mesh_roadmap.html#4-pure-erlang-quic-hypothetical"},{"type":"extras","title":"Library Comparison Matrix - Roadmap","doc":"| Feature                  | quicer | xquic | quinn | Pure Erlang |\n|--------------------------|--------|-------|-------|-------------|\n| **Maturity**            | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ |\n| **Erlang Integration**  | ⭐⭐⭐⭐⭐ | ⭐⭐ | ❌ | ⭐⭐⭐⭐⭐ |\n| **Performance**         | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |\n| **Documentation**       | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | N/A |\n| **Production Ready**    | ✅ | ✅ | ✅ | ❌ |\n| **Cross-platform**      | ✅ | ✅ | ✅ | ✅ |\n| **NIF Required**        | Yes | Yes | Yes | No |\n| **Development Effort**  | Low | Medium | High | Very High |\n| **Community Support**   | Strong | Moderate | Strong | N/A |","ref":"macula_http3_mesh_roadmap.html#library-comparison-matrix"},{"type":"extras","title":"Recommendation: quicer - Roadmap","doc":"For Macula Mesh Phase 1, **quicer is the clear choice**:\n\n1. **Production-ready**: Used in EMQX with millions of connections\n2. **Well-documented**: Good examples and API docs\n3. **Actively maintained**: Regular updates, responsive maintainers\n4. **Erlang-native**: Designed for BEAM from the ground up\n5. **MsQuic backend**: Battle-tested in Microsoft services\n\n**Migration Path:**\n- Phase 1: Use quicer (proven, fast path to PoC)\n- Phase 2: Optimize (profile, tune, maybe contribute improvements)\n- Phase 3: Evaluate alternatives (if needed, could switch to pure Erlang or Rust)\n\n---","ref":"macula_http3_mesh_roadmap.html#recommendation-quicer"},{"type":"extras","title":"Architecture Overview - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#architecture-overview"},{"type":"extras","title":"High-Level Architecture - Roadmap","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│                    Macula Mesh Network                  │\n│                                                         │\n│  ┌────────┐      ┌────────┐      ┌────────┐           │\n│  │ Node A │◄────►│ Node B │◄────►│ Node C │           │\n│  │        │      │        │      │        │           │\n│  └────┬───┘      └────┬───┘      └────┬───┘           │\n│       │               │               │                │\n│       └───────────────┼───────────────┘                │\n│                       │                                │\n│                  HTTP/3 (QUIC)                         │\n│              (Encrypted, Multiplexed)                  │\n└─────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#high-level-architecture"},{"type":"extras","title":"Layered Architecture - Roadmap","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│ Layer 5: Application                                    │\n│  • Elixir/Erlang Applications                          │\n│  • Standard distributed Erlang API                     │\n│  • spawn/2, send/2, monitor/2, etc.                   │\n└─────────────────────────────────────────────────────────┘\n              ↓ (transparent to application)\n┌─────────────────────────────────────────────────────────┐\n│ Layer 4: WAMP Protocol (Optional Compatibility)        │\n│  • publish(Topic, Data)                                │\n│  • subscribe(Topic, Handler)                           │\n│  • call(Procedure, Args)                               │\n│  • register(Procedure, Handler)                        │\n└─────────────────────────────────────────────────────────┘\n              ↓\n┌─────────────────────────────────────────────────────────┐\n│ Layer 3: Mesh Routing                                  │\n│  • Node discovery (bootstrap, mDNS, DHT)               │\n│  • Membership management (SWIM gossip)                 │\n│  • Topology management (k-regular graph)               │\n│  • Message routing (DHT-based, O(log n) hops)         │\n└─────────────────────────────────────────────────────────┘\n              ↓\n┌─────────────────────────────────────────────────────────┐\n│ Layer 2: Macula Distribution Protocol                  │\n│  • Message framing (wire protocol)                     │\n│  • Handshake and authentication                        │\n│  • Process messaging (SEND, LINK, MONITOR, etc.)      │\n│  • Stream multiplexing (process ↔ stream mapping)     │\n└─────────────────────────────────────────────────────────┘\n              ↓\n┌─────────────────────────────────────────────────────────┐\n│ Layer 1: QUIC Transport (HTTP/3)                       │\n│  • quicer (Erlang NIF)                                 │\n│  • MsQuic (C library)                                  │\n│  • UDP sockets                                         │\n│  • TLS 1.3 encryption                                  │\n│  • NAT traversal (STUN/ICE)                           │\n└─────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#layered-architecture"},{"type":"extras","title":"Component Architecture - Roadmap","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│ Macula Node (Erlang/OTP Application)                   │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  ┌──────────────────────────────────────────────────┐  │\n│  │ Supervision Tree                                 │  │\n│  │                                                  │  │\n│  │  macula_sup (top-level supervisor)              │  │\n│  │    ├─ macula_connection_sup (connections)       │  │\n│  │    ├─ macula_membership (SWIM gossip)           │  │\n│  │    ├─ macula_topology (neighbor management)     │  │\n│  │    ├─ macula_routing (DHT routing)              │  │\n│  │    ├─ macula_discovery (node discovery)         │  │\n│  │    ├─ macula_pubsub (pub/sub registry)          │  │\n│  │    └─ macula_dist (distribution driver)         │  │\n│  └──────────────────────────────────────────────────┘  │\n│                                                         │\n│  ┌──────────────────────────────────────────────────┐  │\n│  │ Connection Pool (one per remote node)            │  │\n│  │                                                  │  │\n│  │  connection_1 (QUIC, 5 streams active)          │  │\n│  │  connection_2 (QUIC, 3 streams active)          │  │\n│  │  connection_3 (QUIC, 8 streams active)          │  │\n│  └──────────────────────────────────────────────────┘  │\n│                                                         │\n│  ┌──────────────────────────────────────────────────┐  │\n│  │ ETS Tables (shared state)                        │  │\n│  │                                                  │  │\n│  │  - membership_table (alive nodes)                │  │\n│  │  - routing_table (DHT entries)                   │  │\n│  │  - stream_registry (stream_id → pid)            │  │\n│  │  - subscription_registry (topic → [pids])       │  │\n│  └──────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────┘\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#component-architecture"},{"type":"extras","title":"Detailed Roadmap - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#detailed-roadmap"},{"type":"extras","title":"Phase 1: Foundation (Weeks 1-4) - Roadmap","doc":"**Goal:** Prove HTTP/3 Can Carry Erlang Distribution Traffic\n\n#### Week 1-2: QUIC Transport Layer\n\n**Objectives:**\n1. Set up quicer dependency\n2. Create basic QUIC server/client\n3. Implement bidirectional streaming\n4. Build connection management\n\n**Deliverables:**\n\n```erlang\n%% File: macula_quic_echo.erl\n%% Simple QUIC echo server/client to validate transport\n\n-module(macula_quic_echo).\n-export([start_server/1, start_client/2]).\n\nstart_server(Port) ->\n    %% Generate self-signed cert for testing\n    {Cert, Key} = macula_cert:generate_self_signed(\"localhost\"),\n\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula/1.0\"],\n        idle_timeout_ms => 10000,\n        peer_unidi_stream_count => 10,\n        peer_bidi_stream_count => 100\n    },\n\n    {ok, Listener} = quicer:listen(Port, ListenOpts),\n    io:format(\"QUIC server listening on port ~p~n\", [Port]),\n\n    accept_loop(Listener).\n\naccept_loop(Listener) ->\n    case quicer:accept(Listener, [], infinity) of\n        {ok, Conn} ->\n            %% Complete handshake\n            {ok, Conn} = quicer:handshake(Conn),\n\n            %% Get peer info\n            {ok, PeerAddr} = quicer:getopt(Conn, peer_addr),\n            io:format(\"Accepted connection from ~p~n\", [PeerAddr]),\n\n            %% Spawn connection handler\n            spawn_link(fun() -> handle_connection(Conn) end),\n\n            %% Continue accepting\n            accept_loop(Listener);\n        {error, Reason} ->\n            io:format(\"Accept error: ~p~n\", [Reason]),\n            timer:sleep(1000),\n            accept_loop(Listener)\n    end.\n\nhandle_connection(Conn) ->\n    %% Accept streams\n    stream_accept_loop(Conn).\n\nstream_accept_loop(Conn) ->\n    case quicer:accept_stream(Conn, []) of\n        {ok, Stream} ->\n            %% Spawn stream handler\n            spawn_link(fun() -> echo_stream(Stream) end),\n            stream_accept_loop(Conn);\n        {error, closed} ->\n            io:format(\"Connection closed~n\");\n        {error, Reason} ->\n            io:format(\"Stream accept error: ~p~n\", [Reason])\n    end.\n\necho_stream(Stream) ->\n    case quicer:recv(Stream, 0) of\n        {ok, Data} ->\n            io:format(\"Received: ~p~n\", [Data]),\n            quicer:send(Stream, Data),\n            echo_stream(Stream);\n        {error, closed} ->\n            quicer:close_stream(Stream);\n        {error, Reason} ->\n            io:format(\"Recv error: ~p~n\", [Reason]),\n            quicer:close_stream(Stream)\n    end.\n\nstart_client(Host, Port) ->\n    ConnOpts = #{\n        alpn => [\"macula/1.0\"],\n        verify => verify_none  %% For testing only!\n    },\n\n    io:format(\"Connecting to ~s:~p~n\", [Host, Port]),\n    {ok, Conn} = quicer:connect(Host, Port, ConnOpts, 5000),\n\n    %% Open stream\n    {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n\n    %% Send message\n    Message = <<\"Hello, QUIC!\">>,\n    ok = quicer:send(Stream, Message),\n    io:format(\"Sent: ~p~n\", [Message]),\n\n    %% Receive echo\n    {ok, Echo} = quicer:recv(Stream, 0),\n    io:format(\"Received echo: ~p~n\", [Echo]),\n\n    %% Close\n    quicer:close_stream(Stream),\n    quicer:close_connection(Conn).\n```\n\n**Testing:**\n```bash\n# Terminal 1: Start server\n$ erl -pa _build/default/lib/*/ebin\n1> macula_quic_echo:start_server(4433).\n\n# Terminal 2: Connect client\n$ erl -pa _build/default/lib/*/ebin\n1> macula_quic_echo:start_client(\"localhost\", 4433).\n```\n\n**Success Criteria:**\n- ✅ Server accepts QUIC connections\n- ✅ Client can connect and exchange data\n- ✅ Multiple streams work concurrently\n- ✅ Connection survives stream closure\n\n---\n\n#### Week 3: Message Framing Protocol\n\n**Objectives:**\n1. Design Macula wire protocol v1\n2. Implement message encoding/decoding\n3. Define message types for distribution\n\n**Wire Protocol Specification:**\n\n```\nMacula Wire Protocol v1\n=======================\n\nAll integers are big-endian.\n\nPacket Format:\n┌──────┬──────┬───────┬────────┬─────────┐\n│ Ver  │ Type │ Flags │ Length │ Payload │\n│ (1B) │ (1B) │ (2B)  │ (4B)   │ (N B)   │\n└──────┴──────┴───────┴────────┴─────────┘\n\nVersion (1 byte):\n  - 0x01: Version 1\n\nType (1 byte):\n  - 0x01: HANDSHAKE\n  - 0x02: HEARTBEAT\n  - 0x03: SEND           (send message to process)\n  - 0x04: REG_SEND       (send to registered name)\n  - 0x05: EXIT           (process exit signal)\n  - 0x06: LINK           (link processes)\n  - 0x07: UNLINK         (unlink processes)\n  - 0x08: MONITOR        (monitor process)\n  - 0x09: DEMONITOR      (demonitor)\n  - 0x0A: GROUP_LEADER   (group leader operations)\n  - 0x0B: RPC            (remote procedure call)\n  - 0x0C: SPAWN_REQUEST  (spawn on remote node)\n  - 0x0D: SPAWN_REPLY    (spawn result)\n\nFlags (2 bytes):\n  Bit 0: COMPRESSED (payload is compressed)\n  Bit 1: FRAGMENTED (part of fragmented message)\n  Bit 2-15: Reserved\n\nLength (4 bytes):\n  - Payload length in bytes (max 16 MB)\n\nPayload (N bytes):\n  - Message-type specific data\n  - Encoded using Erlang External Term Format (EETF)\n```\n\n**Implementation:**\n\n```erlang\n%% File: macula_protocol.erl\n-module(macula_protocol).\n-export([encode/2, decode/1]).\n\n%% Protocol version\n-define(VERSION, 1).\n\n%% Message types\n-define(MSG_HANDSHAKE, 16#01).\n-define(MSG_HEARTBEAT, 16#02).\n-define(MSG_SEND, 16#03).\n-define(MSG_REG_SEND, 16#04).\n-define(MSG_EXIT, 16#05).\n-define(MSG_LINK, 16#06).\n-define(MSG_UNLINK, 16#07).\n-define(MSG_MONITOR, 16#08).\n-define(MSG_DEMONITOR, 16#09).\n-define(MSG_GROUP_LEADER, 16#0A).\n-define(MSG_RPC, 16#0B).\n-define(MSG_SPAWN_REQUEST, 16#0C).\n-define(MSG_SPAWN_REPLY, 16#0D).\n\n%% Flags\n-define(FLAG_COMPRESSED, 16#0001).\n-define(FLAG_FRAGMENTED, 16#0002).\n\n%% Encode message\nencode(Type, Payload) when is_integer(Type), Type >= 0, Type =< 255 ->\n    encode(Type, 0, Payload).\n\nencode(Type, Flags, Payload) ->\n    %% Serialize payload\n    PayloadBin = term_to_binary(Payload, [compressed]),\n    Length = byte_size(PayloadBin),\n\n    %% Check size limit (16 MB)\n    if\n        Length > 16#1000000 ->\n            {error, payload_too_large};\n        true ->\n            %% Build packet\n            <<?VERSION:8, Type:8, Flags:16, Length:32, PayloadBin/binary>>\n    end.\n\n%% Decode message\ndecode(<<?VERSION:8, Type:8, Flags:16, Length:32, PayloadBin:Length/binary, Rest/binary>>) ->\n    %% Deserialize payload\n    Payload = binary_to_term(PayloadBin),\n\n    {ok, #{\n        type => Type,\n        flags => Flags,\n        payload => Payload\n    }, Rest};\ndecode(Bin) when byte_size(Bin) < 8 ->\n    {error, insufficient_data};\ndecode(< >) when Version =/= ?VERSION ->\n    {error, {unsupported_version, Version}};\ndecode(_) ->\n    {error, invalid_packet}.\n\n%% Helper: Encode SEND message\nencode_send(FromPid, ToPid, Message) ->\n    encode(?MSG_SEND, {FromPid, ToPid, Message}).\n\n%% Helper: Encode LINK message\nencode_link(Pid1, Pid2) ->\n    encode(?MSG_LINK, {Pid1, Pid2}).\n\n%% Helper: Encode MONITOR message\nencode_monitor(Pid, Ref, MonitoredPid) ->\n    encode(?MSG_MONITOR, {Pid, Ref, MonitoredPid}).\n\n%% Helper: Encode SPAWN_REQUEST message\nencode_spawn_request(ReqId, Module, Function, Args) ->\n    encode(?MSG_SPAWN_REQUEST, {ReqId, Module, Function, Args}).\n```\n\n**Handshake Protocol:**\n\n```erlang\n%% File: macula_handshake.erl\n-module(macula_handshake).\n-export([perform/1, accept/1]).\n\n-record(handshake, {\n    version = ?MACULA_VERSION,\n    node_name :: atom(),\n    node_id :: binary(),      %% SHA256(certificate)\n    capabilities = [] :: [atom()],\n    creation :: integer(),    %% Node start time\n    challenge :: binary()     %% Random bytes for auth\n}).\n\n%% Initiate handshake (client side)\nperform(Conn) ->\n    %% Generate our handshake\n    Handshake = #handshake{\n        node_name = node(),\n        node_id = macula_identity:node_id(),\n        capabilities = [compression, rpc, monitoring, streams],\n        creation = erlang:system_time(millisecond),\n        challenge = crypto:strong_rand_bytes(32)\n    },\n\n    %% Send handshake\n    Packet = macula_protocol:encode(?MSG_HANDSHAKE, Handshake),\n    {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n    ok = quicer:send(Stream, Packet),\n\n    %% Receive remote handshake\n    {ok, ResponsePacket} = quicer:recv(Stream, 0),\n    {ok, #{payload := RemoteHandshake}, _} = macula_protocol:decode(ResponsePacket),\n\n    %% Verify compatibility\n    case check_compatibility(Handshake, RemoteHandshake) of\n        ok ->\n            %% Send acknowledgment\n            Ack = macula_protocol:encode(?MSG_HANDSHAKE, {ack, Handshake#handshake.challenge}),\n            ok = quicer:send(Stream, Ack),\n            {ok, RemoteHandshake};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept handshake (server side)\naccept(Conn) ->\n    %% Accept stream\n    {ok, Stream} = quicer:accept_stream(Conn, []),\n\n    %% Receive handshake\n    {ok, Packet} = quicer:recv(Stream, 0),\n    {ok, #{payload := RemoteHandshake}, _} = macula_protocol:decode(Packet),\n\n    %% Generate our handshake\n    Handshake = #handshake{\n        node_name = node(),\n        node_id = macula_identity:node_id(),\n        capabilities = [compression, rpc, monitoring, streams],\n        creation = erlang:system_time(millisecond),\n        challenge = crypto:strong_rand_bytes(32)\n    },\n\n    %% Verify compatibility\n    case check_compatibility(Handshake, RemoteHandshake) of\n        ok ->\n            %% Send our handshake\n            Response = macula_protocol:encode(?MSG_HANDSHAKE, Handshake),\n            ok = quicer:send(Stream, Response),\n\n            %% Wait for acknowledgment\n            {ok, AckPacket} = quicer:recv(Stream, 0),\n            {ok, #{payload := {ack, Challenge}}, _} = macula_protocol:decode(AckPacket),\n\n            %% Verify challenge\n            if\n                Challenge =:= Handshake#handshake.challenge ->\n                    {ok, RemoteHandshake};\n                true ->\n                    {error, invalid_challenge}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\ncheck_compatibility(Local, Remote) ->\n    %% Check version\n    if\n        Local#handshake.version =/= Remote#handshake.version ->\n            {error, version_mismatch};\n        true ->\n            %% Check capabilities\n            CommonCaps = sets:intersection(\n                sets:from_list(Local#handshake.capabilities),\n                sets:from_list(Remote#handshake.capabilities)\n            ),\n            if\n                sets:size(CommonCaps) > 0 -> ok;\n                true -> {error, no_common_capabilities}\n            end\n    end.\n```\n\n---\n\n#### Week 4: Basic Distribution Protocol\n\n**Objectives:**\n1. Implement net_kernel distribution driver\n2. Support basic message sending\n3. Enable process spawning\n\n**Distribution Driver:**\n\n```erlang\n%% File: macula_dist.erl\n%% Erlang distribution protocol driver for Macula\n%%\n%% This module implements the callbacks required by Erlang's net_kernel\n%% to use Macula as a custom distribution protocol.\n\n-module(macula_dist).\n\n%% Distribution driver callbacks\n-export([\n    listen/1,\n    accept/1,\n    accept_connection/5,\n    setup/5,\n    close/1,\n    select/1,\n    is_node_name/1,\n    address/0\n]).\n\n%% Internal API\n-export([\n    send/2,\n    send/3,\n    recv/2\n]).\n\n-record(macula_dist_state, {\n    listener,      %% QUIC listener\n    connection,    %% QUIC connection\n    node,          %% Remote node name\n    streams = #{}  %% Map: purpose => stream\n}).\n\n%% Listen for incoming connections\nlisten(Name) ->\n    %% Extract port from name (e.g., node@host:4433)\n    Port = extract_port(Name, 4433),\n\n    %% Generate certificate\n    {Cert, Key} = macula_cert:generate_node_cert(Name),\n\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula-dist/1.0\"],\n        peer_bidi_stream_count => 100\n    },\n\n    case quicer:listen(Port, ListenOpts) of\n        {ok, Listener} ->\n            {ok, {Listener, #macula_dist_state{listener = Listener}}};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept incoming connection\naccept(Listen) ->\n    Listener = element(1, Listen),\n    case quicer:accept(Listener, [], infinity) of\n        {ok, Conn} ->\n            %% Perform handshake\n            case macula_handshake:accept(Conn) of\n                {ok, RemoteHandshake} ->\n                    RemoteNode = RemoteHandshake#handshake.node_name,\n                    State = #macula_dist_state{\n                        connection = Conn,\n                        node = RemoteNode\n                    },\n                    {ok, Conn, State};\n                {error, Reason} ->\n                    quicer:close_connection(Conn),\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept connection (post-handshake setup)\naccept_connection(AcceptPid, DistCtrl, MyNode, Allowed, SetupTime) ->\n    %% This is called by net_kernel after accept/1 succeeds\n    gen_server:call(DistCtrl, {accept_connection, AcceptPid, MyNode, Allowed, SetupTime}).\n\n%% Setup outgoing connection\nsetup(Node, Type, MyNode, LongOrShortNames, SetupTime) ->\n    %% Extract host and port\n    {Host, Port} = parse_node_name(Node),\n\n    %% Connect\n    ConnOpts = #{\n        alpn => [\"macula-dist/1.0\"],\n        verify => verify_peer\n    },\n\n    case quicer:connect(Host, Port, ConnOpts, 5000) of\n        {ok, Conn} ->\n            %% Perform handshake\n            case macula_handshake:perform(Conn) of\n                {ok, RemoteHandshake} ->\n                    State = #macula_dist_state{\n                        connection = Conn,\n                        node = Node\n                    },\n                    {ok, Conn, State};\n                {error, Reason} ->\n                    quicer:close_connection(Conn),\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Close connection\nclose(Conn) ->\n    quicer:close_connection(Conn),\n    ok.\n\n%% Select (for epmd compatibility)\nselect(Node) ->\n    %% Macula doesn't use epmd\n    {ok, Node}.\n\n%% Check if valid node name\nis_node_name(Node) when is_atom(Node) ->\n    case atom_to_list(Node) of\n        [$@ | _] -> false;\n        Name ->\n            case string:chr(Name, $@) of\n                0 -> false;\n                _ -> true\n            end\n    end;\nis_node_name(_) ->\n    false.\n\n%% Get address (for net_kernel)\naddress() ->\n    %% Return local node address\n    {ok, {0, 0, 0, 0}}.\n\n%% Send message to process on remote node\nsend(Conn, Pid, Message) ->\n    %% Encode SEND message\n    Packet = macula_protocol:encode_send(self(), Pid, Message),\n\n    %% Get or create stream for this message\n    {ok, Stream} = get_or_create_stream(Conn, control),\n\n    %% Send\n    quicer:send(Stream, Packet).\n\nsend(Conn, Name, Message) when is_atom(Name) ->\n    %% Send to registered name\n    Packet = macula_protocol:encode(?MSG_REG_SEND, {self(), Name, Message}),\n    {ok, Stream} = get_or_create_stream(Conn, control),\n    quicer:send(Stream, Packet).\n\n%% Receive message\nrecv(Conn, Timeout) ->\n    %% Accept next stream with data\n    case quicer:accept_stream(Conn, [], Timeout) of\n        {ok, Stream} ->\n            case quicer:recv(Stream, 0) of\n                {ok, Packet} ->\n                    {ok, Msg, _} = macula_protocol:decode(Packet),\n                    {ok, Msg};\n                {error, Reason} ->\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%%% Internal functions\n\nget_or_create_stream(Conn, Purpose) ->\n    %% Look up existing stream for this purpose\n    %% If not found, create new stream\n    case ets:lookup(macula_streams, {Conn, Purpose}) of\n        [{_, Stream}] ->\n            {ok, Stream};\n        [] ->\n            {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n            ets:insert(macula_streams, {{Conn, Purpose}, Stream}),\n            {ok, Stream}\n    end.\n\nparse_node_name(Node) when is_atom(Node) ->\n    case string:split(atom_to_list(Node), \"@\") of\n        [_Name, HostPort] ->\n            case string:split(HostPort, \":\") of\n                [Host, Port] -> {Host, list_to_integer(Port)};\n                [Host] -> {Host, 4433}  %% Default port\n            end;\n        _ ->\n            {error, invalid_node_name}\n    end.\n\nextract_port(Name, Default) ->\n    case string:split(atom_to_list(Name), \":\") of\n        [_, Port] -> list_to_integer(Port);\n        _ -> Default\n    end.\n```\n\n**Testing:**\n\n```bash\n# Terminal 1: Start first node\n$ erl -name node1@localhost:4433 -proto_dist macula -pa _build/default/lib/*/ebin\n\n# Terminal 2: Start second node\n$ erl -name node2@localhost:4434 -proto_dist macula -pa _build/default/lib/*/ebin\n\n# In node2:\n(node2@localhost:4434)1> net_kernel:connect_node('node1@localhost:4433').\ntrue\n\n(node2@localhost:4434)2> nodes().\n['node1@localhost:4433']\n\n(node2@localhost:4434)3> {node1, 'node1@localhost:4433'} ! {hello, from, node2}.\n{hello, from, node2}\n\n# In node1, check process mailbox:\n(node1@localhost:4433)1> receive Msg -> Msg end.\n{hello, from, node2}\n\n# Spawn remote process:\n(node2@localhost:4434)4> spawn('node1@localhost:4433', fun() ->\n    io:format(\"Running on ~p!~n\", [node()])\nend).\n<12345.67.0>\n\n# On node1, see output:\nRunning on 'node1@localhost:4433'!\n```\n\n**Success Criteria:**\n- ✅ Two nodes can connect via Macula\n- ✅ `nodes()` shows connected nodes\n- ✅ Messages can be sent between nodes\n- ✅ Remote spawning works\n- ✅ Basic distributed Erlang operations function\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-1-foundation-weeks-1-4"},{"type":"extras","title":"Phase 2: Mesh Topology (Weeks 5-8) - Roadmap","doc":"**Goal:** Move Beyond Point-to-Point to Self-Organizing Mesh\n\n#### Week 5-6: Node Discovery and Membership\n\n**Objectives:**\n1. Implement multi-strategy node discovery\n2. Build SWIM-based membership protocol\n3. Handle node joins, leaves, failures\n\n**Node Discovery:**\n\n```erlang\n%% File: macula_discovery.erl\n-module(macula_discovery).\n-behaviour(gen_server).\n\n-export([start_link/0, discover/0, get_known_nodes/0]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-record(state, {\n    bootstrap_nodes = [],\n    known_nodes = sets:new(),\n    discovery_interval = 30000  %% 30 seconds\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\ndiscover() ->\n    gen_server:call(?MODULE, discover).\n\nget_known_nodes() ->\n    gen_server:call(?MODULE, get_known_nodes).\n\ninit([]) ->\n    %% Load bootstrap nodes from config\n    Bootstrap = application:get_env(macula, bootstrap_nodes, []),\n\n    %% Start discovery timer\n    erlang:send_after(1000, self(), discover),\n\n    {ok, #state{bootstrap_nodes = Bootstrap}}.\n\nhandle_call(discover, _From, State) ->\n    %% Run all discovery strategies in parallel\n    Self = self(),\n    spawn(fun() -> Self ! {discovered, discover_via_bootstrap(State#state.bootstrap_nodes)} end),\n    spawn(fun() -> Self ! {discovered, discover_via_mdns()} end),\n    spawn(fun() -> Self ! {discovered, discover_via_dns_srv()} end),\n\n    {reply, ok, State};\n\nhandle_call(get_known_nodes, _From, State) ->\n    Nodes = sets:to_list(State#state.known_nodes),\n    {reply, Nodes, State}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(discover, State) ->\n    %% Trigger discovery\n    discover(),\n\n    %% Schedule next discovery\n    erlang:send_after(State#state.discovery_interval, self(), discover),\n    {noreply, State};\n\nhandle_info({discovered, Nodes}, State) ->\n    %% Merge discovered nodes\n    KnownNodes = lists:foldl(\n        fun(Node, Acc) -> sets:add_element(Node, Acc) end,\n        State#state.known_nodes,\n        Nodes\n    ),\n\n    %% Notify membership protocol\n    macula_membership:discovered_nodes(Nodes),\n\n    {noreply, State#state{known_nodes = KnownNodes}}.\n\n%%% Discovery Strategies\n\n%% Strategy 1: Bootstrap Nodes\ndiscover_via_bootstrap(Bootstrap) ->\n    %% Try to connect to bootstrap nodes\n    lists:filtermap(fun(Node) ->\n        case macula_connection:ping(Node, 1000) of\n            pong -> {true, Node};\n            timeout -> false\n        end\n    end, Bootstrap).\n\n%% Strategy 2: mDNS (local network)\ndiscover_via_mdns() ->\n    %% Send mDNS query for _macula._udp.local\n    case macula_mdns:discover(\"_macula._udp.local\", 2000) of\n        {ok, Nodes} -> Nodes;\n        {error, _} -> []\n    end.\n\n%% Strategy 3: DNS SRV Records\ndiscover_via_dns_srv() ->\n    %% Query DNS SRV for _macula._udp.example.com\n    Domain = application:get_env(macula, dns_domain, \"macula.local\"),\n    SRVName = \"_macula._udp.\" ++ Domain,\n\n    case inet_res:lookup(SRVName, in, srv) of\n        [] -> [];\n        Records ->\n            %% Extract host:port from SRV records\n            lists:map(fun({_Priority, _Weight, Port, Host}) ->\n                list_to_atom(atom_to_list(node()) ++ \"@\" ++ Host ++ \":\" ++ integer_to_list(Port))\n            end, Records)\n    end.\n```\n\n**SWIM Membership Protocol:**\n\n```erlang\n%% File: macula_membership.erl\n%% SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol\n-module(macula_membership).\n-behaviour(gen_server).\n\n-export([start_link/0, join/1, leave/0, get_members/0, discovered_nodes/1]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-record(member, {\n    node_id,\n    address,\n    state = alive,      %% alive | suspect | dead\n    incarnation = 0,    %% For conflict resolution\n    last_seen,          %% Timestamp\n    metadata = #{}      %% Arbitrary key-value data\n}).\n\n-record(state, {\n    local_member,\n    members = #{},       %% node_id => member\n    protocol_period = 1000,  %% 1 second\n    suspect_timeout = 5000,  %% 5 seconds\n    ping_targets = []\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\njoin(BootstrapNode) ->\n    gen_server:call(?MODULE, {join, BootstrapNode}).\n\nleave() ->\n    gen_server:call(?MODULE, leave).\n\nget_members() ->\n    gen_server:call(?MODULE, get_members).\n\ndiscovered_nodes(Nodes) ->\n    gen_server:cast(?MODULE, {discovered_nodes, Nodes}).\n\ninit([]) ->\n    %% Create local member\n    Local = #member{\n        node_id = macula_identity:node_id(),\n        address = macula_identity:address(),\n        state = alive,\n        incarnation = 0,\n        last_seen = erlang:system_time(millisecond),\n        metadata = #{\n            node_name => node(),\n            started_at => erlang:system_time(millisecond)\n        }\n    },\n\n    %% Start protocol tick\n    erlang:send_after(1000, self(), protocol_tick),\n\n    {ok, #state{local_member = Local}}.\n\nhandle_call({join, BootstrapNode}, _From, State) ->\n    %% Contact bootstrap node and exchange membership\n    case macula_connection:connect(BootstrapNode) of\n        {ok, Conn} ->\n            %% Send join request\n            Request = {join, State#state.local_member},\n            case macula_rpc:call(Conn, ?MODULE, handle_join, [Request]) of\n                {ok, RemoteMembers} ->\n                    %% Merge members\n                    Members = maps:merge(State#state.members, RemoteMembers),\n                    {reply, ok, State#state{members = Members}};\n                {error, Reason} ->\n                    {reply, {error, Reason}, State}\n            end;\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\n\nhandle_call(get_members, _From, State) ->\n    Members = maps:values(State#state.members),\n    AliveMembers = lists:filter(fun(M) -> M#member.state =:= alive end, Members),\n    {reply, AliveMembers, State};\n\nhandle_call(leave, _From, State) ->\n    %% Broadcast leave message\n    Members = maps:values(State#state.members),\n    Msg = {leave, State#state.local_member},\n    lists:foreach(fun(Member) ->\n        macula_connection:send(Member#member.node_id, Msg)\n    end, Members),\n\n    {stop, normal, ok, State}.\n\nhandle_cast({discovered_nodes, Nodes}, State) ->\n    %% Add discovered nodes to members (if not already known)\n    NewMembers = lists:foldl(fun(Node, Acc) ->\n        NodeId = macula_identity:node_id(Node),\n        case maps:is_key(NodeId, Acc) of\n            true -> Acc;\n            false ->\n                Member = #member{\n                    node_id = NodeId,\n                    address = Node,\n                    state = alive,\n                    last_seen = erlang:system_time(millisecond)\n                },\n                maps:put(NodeId, Member, Acc)\n        end\n    end, State#state.members, Nodes),\n\n    {noreply, State#state{members = NewMembers}};\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(protocol_tick, State) ->\n    %% SWIM protocol tick\n    NewState = swim_tick(State),\n\n    %% Schedule next tick\n    erlang:send_after(State#state.protocol_period, self(), protocol_tick),\n\n    {noreply, NewState};\n\nhandle_info({ping, From, Incarnation}, State) ->\n    %% Respond to ping\n    macula_connection:send(From, {ack, State#state.local_member#member.incarnation}),\n    {noreply, State};\n\nhandle_info({ack, _Incarnation}, State) ->\n    %% Received ack from ping\n    {noreply, State};\n\nhandle_info({ping_req, Target, From}, State) ->\n    %% Indirect ping request\n    case macula_connection:ping(Target, 500) of\n        pong ->\n            macula_connection:send(From, {ping_req_ack, Target});\n        timeout ->\n            macula_connection:send(From, {ping_req_timeout, Target})\n    end,\n    {noreply, State}.\n\n%%% SWIM Protocol Implementation\n\nswim_tick(State) ->\n    %% 1. Select random member to ping\n    case select_random_member(State#state.members) of\n        {ok, Target} ->\n            case direct_ping(Target) of\n                pong ->\n                    %% Update last_seen\n                    update_member_state(Target#member.node_id, alive, State);\n                timeout ->\n                    %% Try indirect ping via other members\n                    case indirect_ping(Target, State) of\n                        ok ->\n                            update_member_state(Target#member.node_id, alive, State);\n                        failed ->\n                            %% Mark as suspect\n                            State1 = update_member_state(Target#member.node_id, suspect, State),\n                            %% Schedule suspicion timeout\n                            erlang:send_after(State#state.suspect_timeout, self(),\n                                {suspect_timeout, Target#member.node_id}),\n                            State1\n                    end\n            end;\n        error ->\n            State\n    end,\n\n    %% 2. Gossip membership changes\n    gossip_changes(State),\n\n    State.\n\ndirect_ping(Target) ->\n    case macula_connection:ping(Target#member.node_id, 1000) of\n        pong -> pong;\n        _ -> timeout\n    end.\n\nindirect_ping(Target, State) ->\n    %% Select K random members for indirect ping\n    K = 3,\n    Members = maps:values(State#state.members),\n    Proxies = select_random_n(Members, K),\n\n    %% Send ping_req to proxies\n    Ref = make_ref(),\n    lists:foreach(fun(Proxy) ->\n        macula_connection:send(Proxy#member.node_id, {ping_req, Target, self(), Ref})\n    end, Proxies),\n\n    %% Wait for responses\n    wait_for_ping_req_responses(Ref, K, 2000).\n\nwait_for_ping_req_responses(_Ref, 0, _Timeout) ->\n    failed;\nwait_for_ping_req_responses(Ref, Remaining, Timeout) ->\n    receive\n        {ping_req_ack, _Target, Ref} ->\n            ok;\n        {ping_req_timeout, _Target, Ref} ->\n            wait_for_ping_req_responses(Ref, Remaining - 1, Timeout)\n    after Timeout ->\n        failed\n    end.\n\ngossip_changes(State) ->\n    %% Select random peers for gossip\n    Members = maps:values(State#state.members),\n    GossipTargets = select_random_n(Members, 3),\n\n    %% Get recent changes\n    Changes = get_recent_changes(State),\n\n    %% Send to targets\n    lists:foreach(fun(Target) ->\n        macula_connection:send(Target#member.node_id, {gossip, Changes})\n    end, GossipTargets).\n\nget_recent_changes(State) ->\n    %% Get members that changed state recently (last 10 seconds)\n    Now = erlang:system_time(millisecond),\n    RecentWindow = 10000,\n\n    maps:filter(fun(_NodeId, Member) ->\n        (Now - Member#member.last_seen)  \n    case maps:find(NodeId, State#state.members) of\n        {ok, Member} ->\n            UpdatedMember = Member#member{\n                state = NewState,\n                last_seen = erlang:system_time(millisecond)\n            },\n            Members = maps:put(NodeId, UpdatedMember, State#state.members),\n            State#state{members = Members};\n        error ->\n            State\n    end.\n\nselect_random_member(Members) when map_size(Members) > 0 ->\n    List = maps:values(Members),\n    {ok, lists:nth(rand:uniform(length(List)), List)};\nselect_random_member(_) ->\n    error.\n\nselect_random_n(List, N) when length(List) = \n    List;\nselect_random_n(List, N) ->\n    %% Shuffle and take N\n    Shuffled = [X || {_, X} <- lists:sort([{rand:uniform(), E} || E <- List])],\n    lists:sublist(Shuffled, N).\n```\n\n---\n\n#### Week 7: Topology Management and Routing\n\n**Objectives:**\n1. Implement k-regular graph topology\n2. Build DHT-based routing\n3. Optimize for low diameter\n\n**Topology Manager:**\n\n```erlang\n%% File: macula_topology.erl\n%% Manages connection topology using k-regular graph\n%% Each node maintains K connections to neighbors on consistent hash ring\n\n-module(macula_topology).\n-behaviour(gen_server).\n\n-export([start_link/0, maintain/0, get_neighbors/0]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-define(K_NEIGHBORS, 6).  %% Number of neighbors to maintain\n\n-record(state, {\n    neighbors = [],         %% Current neighbor connections\n    desired_neighbors = [], %% Neighbors we should connect to\n    ring_position          %% Our position on hash ring\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\nmaintain() ->\n    gen_server:call(?MODULE, maintain).\n\nget_neighbors() ->\n    gen_server:call(?MODULE, get_neighbors).\n\ninit([]) ->\n    %% Calculate our position on hash ring\n    NodeId = macula_identity:node_id(),\n    Position = crypto:hash(sha256, NodeId),\n\n    %% Start maintenance timer\n    erlang:send_after(5000, self(), maintain),\n\n    {ok, #state{ring_position = Position}}.\n\nhandle_call(get_neighbors, _From, State) ->\n    {reply, State#state.neighbors, State};\n\nhandle_call(maintain, _From, State) ->\n    NewState = maintain_topology(State),\n    {reply, ok, NewState}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(maintain, State) ->\n    NewState = maintain_topology(State),\n    erlang:send_after(5000, self(), maintain),\n    {noreply, NewState}.\n\nmaintain_topology(State) ->\n    %% Get all known members\n    Members = macula_membership:get_members(),\n\n    %% Select desired neighbors using consistent hashing\n    DesiredNeighbors = select_neighbors(Members, ?K_NEIGHBORS, State#state.ring_position),\n\n    %% Current connections\n    CurrentNeighbors = State#state.neighbors,\n\n    %% Find missing connections\n    Missing = DesiredNeighbors -- CurrentNeighbors,\n\n    %% Find extra connections (if we're over K neighbors)\n    Extra = CurrentNeighbors -- DesiredNeighbors,\n\n    %% Connect to missing\n    lists:foreach(fun(NodeId) ->\n        case macula_connection:connect(NodeId) of\n            {ok, _Conn} ->\n                io:format(\"Connected to neighbor: ~p~n\", [NodeId]);\n            {error, Reason} ->\n                io:format(\"Failed to connect to ~p: ~p~n\", [NodeId, Reason])\n        end\n    end, Missing),\n\n    %% Disconnect extra (if too many connections)\n    if\n        length(CurrentNeighbors) > ?K_NEIGHBORS * 2 ->\n            lists:foreach(fun(NodeId) ->\n                macula_connection:disconnect(NodeId)\n            end, Extra);\n        true ->\n            ok\n    end,\n\n    %% Update state\n    NewNeighbors = (CurrentNeighbors ++ Missing) -- Extra,\n    State#state{\n        neighbors = NewNeighbors,\n        desired_neighbors = DesiredNeighbors\n    }.\n\nselect_neighbors(Members, K, MyPosition) ->\n    %% Place all members on hash ring\n    Ring = lists:map(fun(Member) ->\n        NodeId = Member#member.node_id,\n        Position = crypto:hash(sha256, NodeId),\n        {Position, NodeId}\n    end, Members),\n\n    %% Sort by position\n    SortedRing = lists:sort(Ring),\n\n    %% Find our position\n    MyIndex = find_position(MyPosition, SortedRing),\n\n    %% Select K clockwise neighbors (for redundancy, select K/2 clockwise + K/2 counter-clockwise)\n    ClockwiseCount = K div 2,\n    CounterClockwiseCount = K - ClockwiseCount,\n\n    Clockwise = select_clockwise(MyIndex, ClockwiseCount, SortedRing),\n    CounterClockwise = select_counter_clockwise(MyIndex, CounterClockwiseCount, SortedRing),\n\n    Clockwise ++ CounterClockwise.\n\nfind_position(MyPosition, Ring) ->\n    find_position(MyPosition, Ring, 0).\n\nfind_position(_MyPosition, [], _Index) ->\n    0;\nfind_position(MyPosition, [{Position, _NodeId} | _Rest], Index) when Position >= MyPosition ->\n    Index;\nfind_position(MyPosition, [_H | Rest], Index) ->\n    find_position(MyPosition, Rest, Index + 1).\n\nselect_clockwise(MyIndex, Count, Ring) ->\n    RingSize = length(Ring),\n    Indices = [(MyIndex + I) rem RingSize || I <- lists:seq(1, Count)],\n    [NodeId || {Idx, {_Pos, NodeId}} <- lists:zip(Indices, Ring), Idx =:= element(1, lists:nth(Idx + 1, lists:zip(lists:seq(0, RingSize - 1), Ring)))].\n\nselect_counter_clockwise(MyIndex, Count, Ring) ->\n    RingSize = length(Ring),\n    Indices = [(MyIndex - I + RingSize) rem RingSize || I <- lists:seq(1, Count)],\n    [NodeId || {Idx, {_Pos, NodeId}} <- lists:zip(Indices, Ring), Idx =:= element(1, lists:nth(Idx + 1, lists:zip(lists:seq(0, RingSize - 1), Ring)))].\n```\n\n**DHT Routing:**\n\n```erlang\n%% File: macula_routing.erl\n%% Kademlia-inspired DHT routing for mesh\n\n-module(macula_routing).\n-export([route/2, find_node/1, find_closest_nodes/2]).\n\n-define(K, 20).  %% Replication factor\n-define(ALPHA, 3).  %% Concurrency parameter\n\n%% Route message to destination node\nroute(DestNodeId, Message) ->\n    case macula_connection:is_connected(DestNodeId) of\n        true ->\n            %% Direct connection, send immediately\n            macula_connection:send(DestNodeId, Message);\n        false ->\n            %% Find next hop via DHT\n            NextHop = find_next_hop(DestNodeId),\n            forward(NextHop, DestNodeId, Message)\n    end.\n\n%% Find next hop closer to destination\nfind_next_hop(DestNodeId) ->\n    MyNodeId = macula_identity:node_id(),\n\n    %% Get connected neighbors\n    Neighbors = macula_topology:get_neighbors(),\n\n    %% Calculate XOR distance from each neighbor to destination\n    Distances = lists:map(fun(NeighborId) ->\n        Dist = xor_distance(NeighborId, DestNodeId),\n        {Dist, NeighborId}\n    end, Neighbors),\n\n    %% Sort by distance (closest first)\n    Sorted = lists:sort(Distances),\n\n    %% Return closest neighbor\n    case Sorted of\n        [{_Dist, NextHop} | _] ->\n            %% Check if NextHop is closer than us\n            MyDist = xor_distance(MyNodeId, DestNodeId),\n            if\n                _Dist   NextHop;\n                true -> DestNodeId  %% We're closest, destination must be dead\n            end;\n        [] ->\n            %% No neighbors, can't route\n            {error, no_route}\n    end.\n\n%% Forward message to next hop\nforward(NextHop, FinalDest, Message) ->\n    ForwardMsg = {forward, FinalDest, Message},\n    macula_connection:send(NextHop, ForwardMsg).\n\n%% XOR distance metric (like Kademlia)\nxor_distance(A, B) when is_binary(A), is_binary(B) ->\n    crypto:bytes_to_integer(crypto:exor(A, B));\nxor_distance(A, B) ->\n    xor_distance(term_to_binary(A), term_to_binary(B)).\n\n%% Find node by ID (iterative lookup)\nfind_node(TargetId) ->\n    find_node(TargetId, [], [macula_identity:node_id()]).\n\nfind_node(TargetId, Queried, Closest) ->\n    %% Select ALPHA closest unqueried nodes\n    ToQuery = select_unqueried(Closest, Queried, ?ALPHA),\n\n    case ToQuery of\n        [] ->\n            %% No more nodes to query, return closest\n            {ok, lists:sublist(Closest, ?K)};\n        _ ->\n            %% Query nodes in parallel\n            Results = query_nodes(ToQuery, TargetId),\n\n            %% Merge results\n            NewClosest = merge_and_sort(Closest, Results, TargetId),\n            NewQueried = Queried ++ ToQuery,\n\n            %% Check if we found target\n            case lists:member(TargetId, NewClosest) of\n                true -> {ok, TargetId};\n                false -> find_node(TargetId, NewQueried, NewClosest)\n            end\n    end.\n\nquery_nodes(Nodes, TargetId) ->\n    %% Query each node for closer nodes\n    lists:flatmap(fun(NodeId) ->\n        case macula_rpc:call(NodeId, ?MODULE, find_closest_nodes, [TargetId, ?K], 1000) of\n            {ok, Nodes} -> Nodes;\n            {error, _} -> []\n        end\n    end, Nodes).\n\nfind_closest_nodes(TargetId, K) ->\n    %% Return K closest known nodes to TargetId\n    Members = macula_membership:get_members(),\n    Distances = [{xor_distance(M#member.node_id, TargetId), M#member.node_id} || M <- Members],\n    Sorted = lists:sort(Distances),\n    {ok, [NodeId || {_Dist, NodeId} <- lists:sublist(Sorted, K)]}.\n\nselect_unqueried(Closest, Queried, Alpha) ->\n    Unqueried = Closest -- Queried,\n    lists:sublist(Unqueried, Alpha).\n\nmerge_and_sort(Closest, New, TargetId) ->\n    All = lists:usort(Closest ++ New),\n    Distances = [{xor_distance(NodeId, TargetId), NodeId} || NodeId <- All],\n    Sorted = lists:sort(Distances),\n    [NodeId || {_Dist, NodeId} <- Sorted].\n```\n\n---\n\n(Continuing in next section due to length...)","ref":"macula_http3_mesh_roadmap.html#phase-2-mesh-topology-weeks-5-8"},{"type":"extras","title":"Phase 3: NAT Traversal (Weeks 9-12) - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#phase-3-nat-traversal-weeks-9-12"},{"type":"extras","title":"Phase 4: WAMP Layer (Weeks 13-16) - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#phase-4-wamp-layer-weeks-13-16"},{"type":"extras","title":"Phase 5: Production Hardening (Weeks 17-20) - Roadmap","doc":"---","ref":"macula_http3_mesh_roadmap.html#phase-5-production-hardening-weeks-17-20"},{"type":"extras","title":"Architecture Diagrams - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#architecture-diagrams"},{"type":"extras","title":"1. System Architecture - Roadmap","doc":"```\n┌─────────────────────────────────────────────────────────────────────┐\n│                         Macula Mesh Network                         │\n│                                                                     │\n│  Internet / WAN                                                     │\n│  ┌──────────────────────────────────────────────────────────────┐  │\n│  │                                                              │  │\n│  │  ┌─────────┐          ┌─────────┐          ┌─────────┐     │  │\n│  │  │ Node A  │◄────────►│ Node B  │◄────────►│ Node C  │     │  │\n│  │  │ (USA)   │          │ (Europe)│          │ (Asia)  │     │  │\n│  │  └────┬────┘          └────┬────┘          └────┬────┘     │  │\n│  │       │                    │                    │          │  │\n│  │       └────────────────────┼────────────────────┘          │  │\n│  │                            │                                │  │\n│  │                   HTTP/3 (QUIC/UDP)                         │  │\n│  │                     Port 443/UDP                            │  │\n│  └──────────────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  NAT/Firewall Traversal:                                           │\n│  • STUN for public address discovery                               │\n│  • ICE for connectivity checks                                     │\n│  • UDP hole punching                                               │\n│  • TURN relay as fallback                                          │\n└─────────────────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#1-system-architecture"},{"type":"extras","title":"2. Node Internal Architecture - Roadmap","doc":"```\n┌─────────────────────────────────────────────────────────────────────┐\n│ Macula Node (BEAM VM)                                               │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ Application Layer                                          │    │\n│  │  • Elixir/Erlang Apps                                      │    │\n│  │  • spawn/2, send/2, monitor/2                             │    │\n│  │  • Transparent distribution                                │    │\n│  └────────────────────────────────────────────────────────────┘    │\n│                             ↓                                       │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ WAMP Compatibility Layer (Optional)                        │    │\n│  │  • publish/subscribe                                       │    │\n│  │  • call/register (RPC)                                     │    │\n│  └────────────────────────────────────────────────────────────┘    │\n│                             ↓                                       │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ Mesh Services                                              │    │\n│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │    │\n│  │  │ Discovery    │  │ Membership   │  │ Topology     │    │    │\n│  │  │ (Bootstrap,  │  │ (SWIM        │  │ (k-regular   │    │    │\n│  │  │  mDNS, DNS)  │  │  Gossip)     │  │  graph)      │    │    │\n│  │  └──────────────┘  └──────────────┘  └──────────────┘    │    │\n│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │    │\n│  │  │ Routing      │  │ Pub/Sub      │  │ RPC          │    │    │\n│  │  │ (DHT,        │  │ (Topic-based │  │ (Request/    │    │    │\n│  │  │  Kademlia)   │  │  Registry)   │  │  Response)   │    │    │\n│  │  └──────────────┘  └──────────────┘  └──────────────┘    │    │\n│  └────────────────────────────────────────────────────────────┘    │\n│                             ↓                                       │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ Macula Distribution Protocol                               │    │\n│  │  • Message framing (wire protocol)                         │    │\n│  │  • Handshake & authentication                              │    │\n│  │  • Stream multiplexing                                     │    │\n│  │  • Process ↔ Stream mapping                               │    │\n│  └────────────────────────────────────────────────────────────┘    │\n│                             ↓                                       │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ QUIC Transport (via quicer NIF)                            │    │\n│  │  ┌──────────────────────────────────────────────────┐     │    │\n│  │  │ MsQuic (C library)                                │     │    │\n│  │  │  • RFC 9000 QUIC implementation                   │     │    │\n│  │  │  • TLS 1.3 integrated                             │     │    │\n│  │  │  • Streams, flow control, congestion control      │     │    │\n│  │  └──────────────────────────────────────────────────┘     │    │\n│  └────────────────────────────────────────────────────────────┘    │\n│                             ↓                                       │\n│  ┌────────────────────────────────────────────────────────────┐    │\n│  │ UDP Sockets (OS Network Stack)                             │    │\n│  └────────────────────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#2-node-internal-architecture"},{"type":"extras","title":"3. Message Flow Diagram - Roadmap","doc":"```\nProcess A (Node 1)                                  Process B (Node 2)\n      │                                                    │\n      │ Pid ! Message                                     │\n      ├──────────────────────┐                            │\n      │                      │                            │\n      ▼                      │                            │\n macula_dist                 │                            │\n      │                      │                            │\n      │ encode_send()        │                            │\n      ├─────────────┐        │                            │\n      │             │        │                            │\n      ▼             │        │                            │\n macula_protocol    │        │                            │\n      │             │        │                            │\n      │ Frame:      │        │                            │\n      │ [Ver|Type|  │        │                            │\n      │  Flags|Len| │        │                            │\n      │  Payload]   │        │                            │\n      ├─────────────┘        │                            │\n      │                      │                            │\n      ▼                      │                            │\n macula_connection           │                            │\n      │                      │                            │\n      │ Get/Create Stream    │                            │\n      ├─────────────┐        │                            │\n      │             │        │                            │\n      ▼             │        │                            │\n quicer (NIF)       │        │                            │\n      │             │        │                            │\n      │ quicer:send()        │                            │\n      ├─────────────┘        │                            │\n      │                      │                            │\n      ▼                      │                            │\n   MsQuic (C)                │                            │\n      │                      │                            │\n      │ QUIC Packet          │                            │\n      │ (encrypted)          │                            │\n      ├──────────────────────┘                            │\n      │                                                   │\n      ▼                                                   │\n   UDP Socket                                             │\n      │                                                   │\n      │ ═════════════════════════════════════════════►   │\n      │           Network (Internet)                     │\n      │                                                  │\n      │                                            UDP Socket\n      │                                                  │\n      │                                                  ▼\n      │                                             MsQuic (C)\n      │                                                  │\n      │                                                  │ Decrypt\n      │                                                  │ Reassemble\n      │                                                  ├─────────┐\n      │                                                  │         │\n      │                                                  ▼         │\n      │                                            quicer (NIF)    │\n      │                                                  │         │\n      │                                                  │ quicer:recv()\n      │                                                  ├─────────┘\n      │                                                  │\n      │                                                  ▼\n      │                                         macula_connection\n      │                                                  │\n      │                                                  │ Stream → Pid lookup\n      │                                                  ├─────────┐\n      │                                                  │         │\n      │                                                  ▼         │\n      │                                          macula_protocol   │\n      │                                                  │         │\n      │                                                  │ decode()│\n      │                                                  ├─────────┘\n      │                                                  │\n      │                                                  ▼\n      │                                            macula_dist\n      │                                                  │\n      │                                                  │ Deliver to process\n      │                                                  ├────────┐\n      │                                                  │        │\n      │                                                  ▼        │\n      │                                            Process B      │\n      │                                                  │        │\n      │                                                  │ receive │\n      │                                                  │   Message\n      │                                                  ├────────┘\n      │                                                  │\n      │                                                  ▼\n```","ref":"macula_http3_mesh_roadmap.html#3-message-flow-diagram"},{"type":"extras","title":"4. Mesh Topology Diagram - Roadmap","doc":"```\n┌──────────────────────────────────────────────────────────────────┐\n│ Consistent Hash Ring (k-regular graph, k=6)                     │\n│                                                                  │\n│                          Node 3                                 │\n│                            ●                                    │\n│                       ╱         ╲                               │\n│                  ╱                  ╲                            │\n│             ╱                           ╲                        │\n│        ╱                                    ╲                    │\n│   Node 2 ●─────────────────────────────●  Node 4               │\n│       │   ╲                         ╱   │                       │\n│       │       ╲                 ╱       │                       │\n│       │           ╲         ╱           │                       │\n│       │               ● Node 5          │                       │\n│       │           ╱         ╲           │                       │\n│       │       ╱                 ╲       │                       │\n│       │   ╱                         ╲   │                       │\n│   Node 1 ●─────────────────────────────● Node 6                │\n│        ╲                                    ╱                    │\n│             ╲                           ╱                        │\n│                  ╲                  ╱                            │\n│                       ╲         ╱                               │\n│                            ●                                    │\n│                        Node 7                                   │\n│                                                                  │\n│  Each node connects to K neighbors (K=6 in this example)       │\n│  • K/2 clockwise neighbors (3)                                 │\n│  • K/2 counter-clockwise neighbors (3)                         │\n│                                                                  │\n│  Properties:                                                    │\n│  • Low diameter (O(log n) hops between any two nodes)         │\n│  • High fault tolerance (multiple paths)                       │\n│  • Scalable (each node has fixed K connections)               │\n└──────────────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#4-mesh-topology-diagram"},{"type":"extras","title":"5. NAT Traversal Flow - Roadmap","doc":"```\n┌──────────────────────────────────────────────────────────────────┐\n│ NAT Traversal Using STUN + ICE                                   │\n│                                                                  │\n│  Node A (behind NAT)          STUN Server         Node B (public)│\n│       │                            │                      │      │\n│       │  1. STUN Binding Request   │                      │      │\n│       ├───────────────────────────►│                      │      │\n│       │                            │                      │      │\n│       │  2. STUN Response          │                      │      │\n│       │     (Public IP: 1.2.3.4)   │                      │      │\n│       │◄───────────────────────────┤                      │      │\n│       │                            │                      │      │\n│       │  3. Register with Signaling Server               │      │\n│       │     POST /register                                │      │\n│       │     { candidates: [                               │      │\n│       │       {type: \"host\", addr: \"192.168.1.100\"},      │      │\n│       │       {type: \"srflx\", addr: \"1.2.3.4\"}            │      │\n│       │     ]}                                             │      │\n│       ├───────────────────────────────────────────────────►│      │\n│       │                                                    │      │\n│       │  4. Query for Node B candidates                   │      │\n│       │     GET /lookup/node_b                            │      │\n│       ├───────────────────────────────────────────────────►│      │\n│       │                                                    │      │\n│       │  5. Receive Node B candidates                     │      │\n│       │     { candidates: [{type: \"host\", addr: \"5.6.7.8\"}]}    │\n│       │◄───────────────────────────────────────────────────┤      │\n│       │                                                    │      │\n│       │  6. Connectivity Checks (ICE)                     │      │\n│       │     Send STUN probes to all candidate pairs       │      │\n│       ├───────────────────────────────────────────────────►│      │\n│       │◄───────────────────────────────────────────────────┤      │\n│       │                                                    │      │\n│       │  7. Select best candidate pair                    │      │\n│       │     (Direct: 1.2.3.4 ↔ 5.6.7.8)                  │      │\n│       │                                                    │      │\n│       │  8. Establish QUIC Connection                     │      │\n│       │═══════════════════════════════════════════════════►│      │\n│       │                                                    │      │\n│       │  9. Communication over QUIC/UDP                   │      │\n│       │◄══════════════════════════════════════════════════►│      │\n│       │                                                    │      │\n└──────────────────────────────────────────────────────────────────┘\n```","ref":"macula_http3_mesh_roadmap.html#5-nat-traversal-flow"},{"type":"extras","title":"6. Development Roadmap Gantt Chart - Roadmap","doc":"```\nWeek  Phase   Milestone\n────────────────────────────────────────────────────────────────────\n 1-2  │■■■■■■│ QUIC Transport Layer\n      │      │ • quicer integration\n      │      │ • Basic client/server\n      │      │ • Bidirectional streams\n────────────────────────────────────────────────────────────────────\n 3    │  ■■■ │ Message Framing Protocol\n      │      │ • Wire protocol spec\n      │      │ • Encode/decode\n      │      │ • Handshake\n────────────────────────────────────────────────────────────────────\n 4    │   ■■■│ Distribution Protocol\n      │      │ • net_kernel driver\n      │      │ • Basic messaging\n      │      │ • Remote spawn\n────────────────────────────────────────────────────────────────────\n 5-6  │    ■■■■■│ Node Discovery\n      │        │ • Bootstrap\n      │        │ • mDNS\n      │        │ • SWIM membership\n────────────────────────────────────────────────────────────────────\n 7    │       ■■■│ Topology & Routing\n      │          │ • k-regular graph\n      │          │ • DHT routing\n────────────────────────────────────────────────────────────────────\n 8    │        ■■│ Testing & Validation\n      │          │ • Chaos testing\n      │          │ • Benchmarks\n────────────────────────────────────────────────────────────────────\n 9-10 │         ■■■■│ NAT Traversal\n      │             │ • STUN client\n      │             │ • ICE implementation\n────────────────────────────────────────────────────────────────────\n11-12 │           ■■■■│ Hole Punching\n      │               │ • UDP hole punch\n      │               │ • TURN relay\n────────────────────────────────────────────────────────────────────\n13-14 │             ■■■■│ Distributed Pub/Sub\n      │                 │ • Topic registry\n      │                 │ • Content routing\n────────────────────────────────────────────────────────────────────\n15-16 │               ■■■■│ RPC Layer\n      │                   │ • Sync RPC\n      │                   │ • WAMP compat\n────────────────────────────────────────────────────────────────────\n17    │                 ■■│ Security\n      │                   │ • TLS certs\n      │                   │ • Rate limiting\n────────────────────────────────────────────────────────────────────\n18    │                  ■■│ Monitoring\n      │                    │ • Metrics\n      │                    │ • Visualization\n────────────────────────────────────────────────────────────────────\n19    │                   ■■│ Performance\n      │                     │ • Optimization\n      │                     │ • Benchmarks\n────────────────────────────────────────────────────────────────────\n20    │                    ■■│ Documentation\n      │                      │ • Arch guide\n      │                      │ • API docs\n────────────────────────────────────────────────────────────────────\n\nLegend:\n■ = Active development\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#6-development-roadmap-gantt-chart"},{"type":"extras","title":"Technical Deep Dives - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#technical-deep-dives"},{"type":"extras","title":"Deep Dive 1: QUIC vs TCP for Distributed Erlang - Roadmap","doc":"**Why QUIC is Better for Distributed Erlang:**\n\n#### 1. Head-of-Line Blocking\n\n**TCP Problem:**\n```\nProcess A sends: ──[Packet 1]──[Packet 2]──[Packet 3*LOST]──[Packet 4]──►\n                                          ▲\n                                          │\n                        All packets 4+ blocked until 3 retransmitted!\n\nProcess B waiting to receive Packet 4:  ⏳ BLOCKED\n```\n\n**QUIC Solution:**\n```\nStream 0 (Process A): ──[Pkt 1]──[Pkt 2]──[Pkt 3*LOST]──►\n                                          ▲ Retransmit only this\n                                          │\nStream 1 (Process B): ──[Pkt 1]──[Pkt 2]──[Pkt 3]──► ✓ NOT BLOCKED!\n\nIndependent streams = No cross-stream blocking\n```\n\n#### 2. Connection Migration\n\n**TCP Problem:**\n```\nMobile device moves from WiFi to Cellular:\n\nWiFi IP:     192.168.1.100:5000\n             ↓ [Connection established]\n             ↓ [Active transfers]\n             ↓ [Network switches]\nCellular IP: 10.20.30.40:6000\n             ↓ [TCP connection LOST]\n             ↓ [Must re-establish: 3 RTT]\n             ↓ [Resume transfers]\n```\n\n**QUIC Solution:**\n```\nWiFi IP:     192.168.1.100:5000\n             ↓ [Connection ID: 0x1a2b3c4d]\n             ↓ [Active transfers]\n             ↓ [Network switches]\nCellular IP: 10.20.30.40:6000\n             ↓ [Same Connection ID!]\n             ↓ [Continue immediately: 0 RTT]\n             ↓ [Transfers uninterrupted]\n```\n\n#### 3. 0-RTT Resumption\n\n**TCP + TLS 1.2:**\n```\nClient → Server: SYN                      RTT 1\nServer → Client: SYN-ACK\nClient → Server: ACK\nClient → Server: ClientHello              RTT 2\nServer → Client: ServerHello + Certificate\nClient → Server: Finished\nServer → Client: Finished\nClient → Server: HTTP Request             RTT 3\n\nTotal: 3 RTT before application data\n```\n\n**QUIC (with 0-RTT token):**\n```\nClient → Server: Initial + 0-RTT Data + App Request   RTT 0\n\nTotal: 0 RTT! Data sent immediately\n```\n\nThis is HUGE for edge devices that frequently reconnect!\n\n#### 4. Multiplexing Efficiency\n\n**HTTP/2 over TCP:**\n```\n┌──────────────────────────────────────┐\n│ TCP Connection                       │\n│  ┌──────────────────────────────┐   │\n│  │ HTTP/2 Multiplexing          │   │\n│  │  Stream 1, Stream 2, ...     │   │\n│  └──────────────────────────────┘   │\n│                                      │\n│ Problem: TCP sees bytes, not streams │\n│ Single packet loss blocks ALL streams│\n└──────────────────────────────────────┘\n```\n\n**HTTP/3 over QUIC:**\n```\n┌──────────────────────────────────────┐\n│ QUIC Connection                      │\n│  Stream 1 (independent)              │\n│  Stream 2 (independent)              │\n│  Stream 3 (independent)              │\n│  ...                                 │\n│                                      │\n│ QUIC understands streams natively!   │\n│ Packet loss only affects one stream  │\n└──────────────────────────────────────┘\n```\n\nFor Erlang distribution with millions of processes, this is critical!\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-1-quic-vs-tcp-for-distributed-erlang"},{"type":"extras","title":"Deep Dive 2: SWIM Gossip Protocol - Roadmap","doc":"**SWIM: Scalable Weakly-consistent Infection-style Process Group Membership**\n\n#### Why SWIM?\n\nTraditional heartbeat protocols don't scale:\n```\nN nodes sending heartbeats to all others:\n  Network load: O(N²) messages per period\n\nExample: 1000 nodes, 1 sec heartbeat\n  = 1,000,000 messages/sec\n  = NOT SCALABLE\n```\n\nSWIM uses gossip:\n```\nEach node:\n  - Pings 1 random member per period\n  - Gossips to K random members\n\nNetwork load: O(N) messages per period\n\nExample: 1000 nodes, K=3\n  = 1000 pings + 3000 gossip = 4000 messages/sec\n  = SCALABLE!\n```\n\n#### SWIM Algorithm\n\n```\nEvery protocol period (1 second):\n\n1. SELECT random member M\n2. PING M (wait for ACK)\n   ├─ If ACK received → M is alive\n   └─ If timeout → INDIRECT PING\n\n3. INDIRECT PING:\n   ├─ Select K random members (e.g., K=3)\n   ├─ Ask each to ping M on your behalf\n   └─ If any ACK → M is alive\n       If all timeout → M is SUSPECT\n\n4. SUSPECT handling:\n   ├─ Don't immediately mark M as dead\n   ├─ Give time for refutation (5 seconds)\n   ├─ M can increase its \"incarnation number\" to refute\n   └─ If no refutation → M is DEAD\n\n5. GOSSIP:\n   ├─ Select K random members\n   └─ Send recent membership changes\n       (new members, state changes, etc.)\n```\n\n#### Suspicion Mechanism\n\n```\nTimeline:\n\nT+0s:  Node fails to respond to ping\n       │\n       ▼\n       Mark as SUSPECT (not dead!)\n       │\n       ├─ Broadcast \"Node X is suspect\"\n       │  via gossip\n       │\nT+1s:  │  Other nodes hear rumor\n       │  └─► Try to ping Node X\n       │       └─► Some may succeed!\n       │\nT+2s:  │  Node X hears it's suspected\n       │  └─► Refutes by increasing\n       │       incarnation number\n       │\nT+5s:  ▼\n       If no refutation → Mark as DEAD\n       │\n       └─ Broadcast \"Node X is dead\"\n```\n\nThis prevents false positives from temporary network glitches!\n\n#### Gossip Dissemination\n\n```\nEpidemic-style spread:\n\nT+0: Node A detects change (Node X joined)\n     ┌───────┐\n     │   A   │ knows: X joined\n     └───────┘\n\nT+1: A gossips to B, C, D (K=3 random)\n     ┌───────┐   ┌───────┐   ┌───────┐   ┌───────┐\n     │   A   │──►│   B   │──►│   C   │──►│   D   │\n     └───────┘   └───────┘   └───────┘   └───────┘\n                  knows       knows       knows\n\nT+2: B, C, D gossip to 3 others each (exponential spread)\n     9 nodes know\n\nT+3: 27 nodes know\n\nT+log₃(N): All nodes know!\n```\n\nConvergence time: **O(log N)**\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-2-swim-gossip-protocol"},{"type":"extras","title":"Deep Dive 3: Kademlia DHT for Routing - Roadmap","doc":"**Why DHT (Distributed Hash Table)?**\n\nIn large mesh networks, full mesh (N² connections) doesn't scale:\n```\nNodes  Connections  Problem\n  10       45       OK\n 100     4,950      Getting expensive\n1000   499,500      IMPOSSIBLE\n```\n\nDHT enables O(log N) routing:\n```\nNodes  Hops (log₂ N)\n  10        3\n 100        6\n1000       10\n```\n\n#### Kademlia Basics\n\n**XOR Distance Metric:**\n```\nNode IDs are 256-bit hashes (SHA256)\n\nNode A: 0x3a7f...\nNode B: 0x8c12...\n\nDistance = A XOR B\n         = 0x3a7f... XOR 0x8c12...\n         = 0xb66d...\n\nProperties:\n  • d(A, B) = d(B, A)  (symmetric)\n  • d(A, A) = 0\n  • d(A, B) + d(B, C) >= d(A, C)  (triangle inequality)\n```\n\n**k-buckets:**\n```\nEach node maintains k-buckets for distance ranges:\n\nBucket 0:  Distance 2^0  to 2^1   (1 hop away)\nBucket 1:  Distance 2^1  to 2^2   (2 hops)\nBucket 2:  Distance 2^2  to 2^3   (4 hops)\n...\nBucket 255: Distance 2^255 to 2^256 (very far)\n\nEach bucket stores up to K nodes (e.g., K=20)\n```\n\n**Routing:**\n```\nTo send message to target T:\n\n1. Calculate distance: d = XOR(my_id, T)\n2. Find bucket for distance d\n3. Select closest node N from bucket\n4. Forward to N\n5. Repeat until reached T\n\nMax hops: log₂(total_nodes)\n```\n\n#### Iterative Node Lookup\n\n```erlang\nfind_node(TargetId) ->\n    % Start with K closest known nodes\n    Closest = get_k_closest(TargetId, K),\n    find_node_iter(TargetId, Closest, [], K).\n\nfind_node_iter(TargetId, Closest, Queried, K) ->\n    % Select ALPHA unqueried nodes to ask\n    ToQuery = select_closest_unqueried(Closest, Queried, ALPHA),\n\n    if\n        ToQuery =:= [] ->\n            % No more to query, return result\n            lists:sublist(Closest, K);\n        true ->\n            % Query nodes in parallel\n            Results = pmap(fun(Node) ->\n                rpc:call(Node, kademlia, get_closest, [TargetId, K])\n            end, ToQuery),\n\n            % Merge results and sort by distance\n            NewClosest = merge_and_sort(Closest, lists:flatten(Results), TargetId),\n            NewQueried = Queried ++ ToQuery,\n\n            % Check if target found\n            case lists:member(TargetId, NewClosest) of\n                true -> {found, TargetId};\n                false -> find_node_iter(TargetId, NewClosest, NewQueried, K)\n            end\n    end.\n```\n\nComplexity: **O(log N)** lookups, **O(ALPHA * log N)** messages\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-3-kademlia-dht-for-routing"},{"type":"extras","title":"Success Metrics - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#success-metrics"},{"type":"extras","title":"Phase 1 Success Criteria - Roadmap","doc":"- ✅ **QUIC Transport Works**\n  - Server accepts connections\n  - Client can connect\n  - Bidirectional streams function\n  - Connection survives stream closure\n\n- ✅ **Wire Protocol Implemented**\n  - Messages encode/decode correctly\n  - Handshake completes successfully\n  - All message types supported\n\n- ✅ **Basic Distribution Functions**\n  - `net_kernel:connect_node/1` works\n  - `nodes()` shows connected nodes\n  - Message sending: `{Name, Node} ! Msg`\n  - Remote spawn: `spawn(Node, Fun)`\n  - Process linking works\n  - Monitoring works\n\n**Deliverable:** Two Erlang nodes communicating over HTTP/3\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-1-success-criteria"},{"type":"extras","title":"Phase 2 Success Criteria - Roadmap","doc":"- ✅ **Node Discovery Works**\n  - Bootstrap discovery functional\n  - mDNS discovery works locally\n  - DNS SRV discovery works\n\n- ✅ **Membership Protocol Stable**\n  - SWIM protocol running\n  - Failures detected within 10 seconds\n  - Gossip converges in O(log N) time\n  - No false positives in stable network\n\n- ✅ **Topology Self-Organizes**\n  - Nodes form k-regular graph\n  - New nodes join smoothly\n  - Departed nodes removed from topology\n  - Healing after network partition\n\n- ✅ **Routing Functions**\n  - Messages route through mesh\n  - DHT lookup finds nodes\n  - O(log N) hops for routing\n\n**Deliverable:** 20+ node mesh that self-heals from failures\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-2-success-criteria"},{"type":"extras","title":"Phase 3 Success Criteria - Roadmap","doc":"- ✅ **NAT Traversal Works**\n  - STUN discovers public address\n  - ICE negotiates connectivity\n  - UDP hole punching succeeds (>80%)\n  - TURN relay works as fallback\n\n- ✅ **Real-World Scenarios**\n  - Home router NAT traversed\n  - Corporate firewall traversed\n  - Mobile hotspot NAT traversed\n  - Symmetric NAT handled\n\n**Deliverable:** Nodes behind different NATs forming mesh\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-3-success-criteria"},{"type":"extras","title":"Phase 4 Success Criteria - Roadmap","doc":"- ✅ **Pub/Sub Works**\n  - Topic subscriptions work\n  - Messages routed by topic\n  - Pattern matching (prefix/wildcard)\n  - Scalable (not flooding all nodes)\n\n- ✅ **RPC Works**\n  - Synchronous RPC calls\n  - Timeouts handled correctly\n  - Error propagation works\n\n- ✅ **WAMP Compatible**\n  - Existing WAMP clients can connect\n  - Subscribe/Publish semantics match\n  - Call/Register semantics match\n\n**Deliverable:** Example Platform PoC runs on Macula Mesh\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-4-success-criteria"},{"type":"extras","title":"Phase 5 Success Criteria - Roadmap","doc":"- ✅ **Security Hardened**\n  - TLS certificates managed\n  - Message authentication\n  - Rate limiting prevents DoS\n  - Access control enforced\n\n- ✅ **Production Monitoring**\n  - Prometheus metrics exported\n  - Topology visualization works\n  - Alerts fire on anomalies\n  - Distributed tracing available\n\n- ✅ **Performance Acceptable**\n  - <10ms latency (local)\n  - <100ms latency (internet)\n  - >10,000 msg/sec throughput\n  - Scales to 1000+ nodes\n\n- ✅ **Documentation Complete**\n  - Architecture guide published\n  - API reference docs\n  - Deployment guide\n  - Migration from Bondy guide\n\n**Deliverable:** Production-ready Macula Mesh 1.0\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-5-success-criteria"},{"type":"extras","title":"Conclusion - Roadmap","doc":"Macula HTTP/3 Mesh represents a unique opportunity to build **world-class distributed infrastructure for the BEAM ecosystem**. By leveraging QUIC's modern transport capabilities, we can create a mesh network that:\n\n1. **Works anywhere** - Through NATs, firewalls, mobile networks\n2. **Scales effortlessly** - O(log N) routing, not O(N²) connections\n3. **Feels native** - Standard Erlang distribution semantics\n4. **Performs brilliantly** - 0-RTT reconnection, no head-of-line blocking\n5. **Stands out** - Nobody else has this for BEAM\n\nThis is a **20-week journey** that will culminate in a \"Wow, how do they do it?\" moment.\n\n**Next Steps:**\n1. Set up development environment\n2. Integrate quicer dependency\n3. Build Week 1 deliverable (QUIC echo server/client)\n4. Start the journey! 🚀\n\n---","ref":"macula_http3_mesh_roadmap.html#conclusion"},{"type":"extras","title":"References - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#references"},{"type":"extras","title":"QUIC & HTTP/3 - Roadmap","doc":"- [RFC 9000: QUIC Transport Protocol](https://www.rfc-editor.org/rfc/rfc9000.html)\n- [RFC 9001: Using TLS to Secure QUIC](https://www.rfc-editor.org/rfc/rfc9001.html)\n- [RFC 9114: HTTP/3](https://www.rfc-editor.org/rfc/rfc9114.html)\n- [MsQuic Documentation](https://github.com/microsoft/msquic/tree/main/docs)","ref":"macula_http3_mesh_roadmap.html#quic-http-3"},{"type":"extras","title":"Libraries - Roadmap","doc":"- [quicer (Erlang NIF)](https://github.com/emqx/quic)\n- [xquic (Alibaba)](https://github.com/alibaba/xquic)\n- [quinn (Rust)](https://github.com/quinn-rs/quinn)","ref":"macula_http3_mesh_roadmap.html#libraries"},{"type":"extras","title":"Algorithms - Roadmap","doc":"- [SWIM: Scalable Membership Protocol](https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf)\n- [Kademlia: A Peer-to-peer Information System](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)\n- [Consistent Hashing](https://www.cs.princeton.edu/courses/archive/fall09/cos518/papers/chash.pdf)","ref":"macula_http3_mesh_roadmap.html#algorithms"},{"type":"extras","title":"Related Work - Roadmap","doc":"- [Partisan: Flexible Distributed Erlang](https://github.com/lasp-lang/partisan)\n- [Bondy: Distributed WAMP Router](https://github.com/bondy-io/bondy)\n- [Riak Core: Distributed Systems Framework](https://github.com/basho/riak_core)\n\n---\n\n**Document Version:** 1.0\n**Last Updated:** 2025-11-07\n**Author:** Macula Architecture Team\n**Status:** Proposal","ref":"macula_http3_mesh_roadmap.html#related-work"},{"type":"extras","title":"Documentation Status","doc":"# Macula HTTP/3 Mesh - Documentation Status Tracker\n\n**Last Updated**: 2025-01-08\n\nThis file tracks the completion status of all Macula HTTP/3 Mesh documentation.\n\n---","ref":"documentation_status.html"},{"type":"extras","title":"Status Legend - Documentation Status","doc":"- ✅ **Complete**: Document is comprehensive and ready for use\n- 🚧 **Skeleton**: Structure exists, needs content\n- ⚠️ **Planned**: Outlined in root index, not yet created\n- 📝 **In Progress**: Actively being written\n\n---","ref":"documentation_status.html#status-legend"},{"type":"extras","title":"Core Architecture (P0) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Technical Roadmap](macula_http3_mesh_roadmap.md) | ✅ Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) | ✅ Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) | ✅ Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [Documentation Root](macula_http3_mesh_root.md) | ✅ Complete | P0 | 100% | Week 0 | 2025-01-08 |\n\n**Summary**: 4/4 complete (100%)\n\n---","ref":"documentation_status.html#core-architecture-p0"},{"type":"extras","title":"Getting Started (P1) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Quick Start Guide](macula_http3_mesh_quick_start.md) | ✅ Complete | P1 | 100% | Week 4 | 2025-01-08 |\n| [Hello World Tutorial](macula_http3_mesh_hello_world.md) | ✅ Complete | P1 | 100% | Week 4 | 2025-01-08 |\n\n**Summary**: 2/2 complete (100%)\n\n---","ref":"documentation_status.html#getting-started-p1"},{"type":"extras","title":"API and Protocol (P1) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Wire Protocol Spec](macula_http3_mesh_protocol_spec.md) | 🚧 Skeleton | P1 | 10% | Week 8 | 2025-01-08 |\n| [API Reference](macula_http3_mesh_api_reference.md) | 🚧 Skeleton | P1 | 10% | Week 12 | 2025-01-08 |\n\n**Summary**: 0/2 complete (20% average progress)\n\n---","ref":"documentation_status.html#api-and-protocol-p1"},{"type":"extras","title":"Advanced Topics - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md) | 🚧 Skeleton | P2 | 10% | Week 12 | 2025-01-08 |\n| [Security Model](macula_http3_mesh_security.md) | 🚧 Skeleton | P1 | 10% | Week 16 | 2025-01-08 |\n| [Performance Tuning](macula_http3_mesh_performance.md) | 🚧 Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Observability Guide](macula_http3_mesh_observability.md) | 🚧 Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Deployment Patterns](macula_http3_mesh_deployment_patterns.md) | 🚧 Skeleton | P1 | 10% | Week 20 | 2025-01-08 |\n| [Gateway Operations](macula_http3_mesh_gateway_ops.md) | 🚧 Skeleton | P2 | 10% | Week 24 | 2025-01-08 |\n\n**Summary**: 0/6 complete (10% average progress)\n\n---","ref":"documentation_status.html#advanced-topics"},{"type":"extras","title":"Comparisons - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [WAMP Comparison](macula_http3_mesh_vs_wamp.md) | 🚧 Skeleton | P2 | 10% | Week 8 | 2025-01-08 |\n| [libp2p Comparison](macula_http3_mesh_vs_libp2p.md) | 🚧 Skeleton | P3 | 10% | Week 12 | 2025-01-08 |\n\n**Summary**: 0/2 complete (10% average progress)\n\n---","ref":"documentation_status.html#comparisons"},{"type":"extras","title":"Reference Materials - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Design Decision Log](macula_http3_mesh_decisions.md) | 🚧 Skeleton | P2 | 10% | Ongoing | 2025-01-08 |\n| [Glossary](macula_http3_mesh_glossary.md) | 🚧 Skeleton | P2 | 10% | Week 4 | 2025-01-08 |\n| [FAQ](macula_http3_mesh_faq.md) | 🚧 Skeleton | P1 | 10% | Week 4 | 2025-01-08 |\n| [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md) | 🚧 Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Contributing Guide](macula_http3_mesh_contributing.md) | 🚧 Skeleton | P2 | 10% | Week 4 | 2025-01-08 |\n\n**Summary**: 0/5 complete (10% average progress)\n\n---","ref":"documentation_status.html#reference-materials"},{"type":"extras","title":"Overall Progress - Documentation Status","doc":"| Category | Complete | In Progress | Planned | Total | Completion % |\n|----------|----------|-------------|---------|-------|--------------|\n| Core Architecture (P0) | 4 | 0 | 0 | 4 | 100% |\n| Getting Started (P1) | 2 | 0 | 0 | 2 | 100% |\n| API and Protocol (P1) | 0 | 2 | 0 | 2 | 20% |\n| Advanced Topics | 0 | 6 | 0 | 6 | 10% |\n| Comparisons | 0 | 2 | 0 | 2 | 10% |\n| Reference Materials | 0 | 5 | 0 | 5 | 10% |\n| **TOTAL** | **6** | **15** | **0** | **21** | **34%** |\n\n---","ref":"documentation_status.html#overall-progress"},{"type":"extras","title":"Priority Breakdown - Documentation Status","doc":"","ref":"documentation_status.html#priority-breakdown"},{"type":"extras","title":"P0 (Must have before code) - Documentation Status","doc":"- ✅ 4/4 complete (100%)","ref":"documentation_status.html#p0-must-have-before-code"},{"type":"extras","title":"P1 (Required for MVP release) - Documentation Status","doc":"- ✅ 2/6 complete (33%)\n- 🚧 Need: Wire Protocol Spec, API Reference, Security Model, Deployment Patterns, FAQ","ref":"documentation_status.html#p1-required-for-mvp-release"},{"type":"extras","title":"P2 (Important for production) - Documentation Status","doc":"- 🚧 0/8 complete (0%)","ref":"documentation_status.html#p2-important-for-production"},{"type":"extras","title":"P3 (Nice to have) - Documentation Status","doc":"- 🚧 0/1 complete (0%)\n\n---","ref":"documentation_status.html#p3-nice-to-have"},{"type":"extras","title":"Completion Roadmap - Documentation Status","doc":"","ref":"documentation_status.html#completion-roadmap"},{"type":"extras","title":"Immediate Priorities (Next 2 weeks) - Documentation Status","doc":"1. **FAQ** - Quick wins, high user value\n2. **Glossary** - Reference for all other docs\n3. **Wire Protocol Spec** - Critical for implementers","ref":"documentation_status.html#immediate-priorities-next-2-weeks"},{"type":"extras","title":"Short Term (Weeks 3-8) - Documentation Status","doc":"4. **API Reference** - Essential for developers\n5. **Security Model** - Critical for production use\n6. **WAMP Comparison** - Address \"why not WAMP\" question\n7. **Design Decision Log** - Document architectural choices","ref":"documentation_status.html#short-term-weeks-3-8"},{"type":"extras","title":"Medium Term (Weeks 9-16) - Documentation Status","doc":"8. **Deployment Patterns** - Production deployment guidance\n9. **NAT Traversal Deep Dive** - Technical deep dive\n10. **Performance Tuning** - Optimization guide\n11. **Observability Guide** - Monitoring and debugging","ref":"documentation_status.html#medium-term-weeks-9-16"},{"type":"extras","title":"Long Term (Weeks 17+) - Documentation Status","doc":"12. **Gateway Operations** - Advanced realm features\n13. **Troubleshooting Guide** - Support documentation\n14. **Contributing Guide** - Community building\n15. **libp2p Comparison** - Additional comparison\n\n---","ref":"documentation_status.html#long-term-weeks-17"},{"type":"extras","title":"Contribution Workflow - Documentation Status","doc":"","ref":"documentation_status.html#contribution-workflow"},{"type":"extras","title":"How to Contribute to Documentation - Documentation Status","doc":"1. **Choose a skeleton document** from the table above\n2. **Claim it** by creating an issue or commenting in Discord\n3. **Fill in sections** following the existing structure\n4. **Update this status file** with your progress\n5. **Submit PR** when section(s) are complete\n6. **Code review** from maintainers\n7. **Merge** and update \"Last Updated\" date","ref":"documentation_status.html#how-to-contribute-to-documentation"},{"type":"extras","title":"Section-by-Section Approach - Documentation Status","doc":"You don't need to complete an entire document! Contribute section by section:\n- Pick one section from a skeleton\n- Fill it in completely\n- Submit PR with partial completion\n- Update completion % in this file","ref":"documentation_status.html#section-by-section-approach"},{"type":"extras","title":"Tracking Your Progress - Documentation Status","doc":"When working on a document:\n1. Update status from 🚧 to 📝 (in progress)\n2. Update completion % as sections are finished\n3. When 100% complete, change status to ✅\n4. Update \"Last Updated\" date\n\n---","ref":"documentation_status.html#tracking-your-progress"},{"type":"extras","title":"Document Quality Standards - Documentation Status","doc":"","ref":"documentation_status.html#document-quality-standards"},{"type":"extras","title":"Complete (✅) Criteria - Documentation Status","doc":"A document is \"Complete\" when it has:\n- ✅ All sections from skeleton filled in\n- ✅ Code examples tested and working\n- ✅ Diagrams added where helpful\n- ✅ Links to related docs\n- ✅ No ⚠️ TODO markers remaining\n- ✅ Reviewed by at least one other person","ref":"documentation_status.html#complete-criteria"},{"type":"extras","title":"Skeleton (🚧) Criteria - Documentation Status","doc":"A document is \"Skeleton\" when it has:\n- ✅ Clear structure with section headings\n- ✅ ⚠️ TODO markers indicating what needs to be written\n- ✅ Estimated effort and priority\n- ✅ Outline of content to be added\n\n---","ref":"documentation_status.html#skeleton-criteria"},{"type":"extras","title":"Need Help? - Documentation Status","doc":"- **Questions about what to write?** Check the document outline and related complete docs\n- **Technical questions?** Ask in Discord #documentation channel\n- **Want to collaborate?** Find others working on same doc area\n- **Stuck?** Tag a maintainer for guidance\n\n---","ref":"documentation_status.html#need-help"},{"type":"extras","title":"Maintainers - Documentation Status","doc":"Documentation maintainers who can review PRs:\n- [To be assigned]\n\n---\n\n**This file is updated automatically when documentation PRs are merged.**","ref":"documentation_status.html#maintainers"},{"type":"extras","title":"Contributing","doc":"STDIN\n   1 # Macula HTTP/3 Mesh - Contributing Guide\n   2 \n   3 **How to contribute to Macula**\n   4 \n   5 **Status**: 🚧 SKELETON - Needs completion\n   6 **Priority**: P2\n   7 **Estimated effort**: 4 hours\n   8 \n   9 ---\n  10 \n  11","ref":"macula_http3_mesh_contributing.html"},{"type":"extras","title":"Welcome - Contributing","doc":"12 \n  13 ⚠️ **TODO**: Welcome message for contributors.\n  14 \n  15 ---\n  16 \n  17","ref":"macula_http3_mesh_contributing.html#welcome"},{"type":"extras","title":"Code of Conduct - Contributing","doc":"18 \n  19 ⚠️ **TODO**: Community code of conduct.\n  20 \n  21 ---\n  22 \n  23","ref":"macula_http3_mesh_contributing.html#code-of-conduct"},{"type":"extras","title":"Development Setup - Contributing","doc":"24 \n  25 ⚠️ **TODO**: How to set up development environment.\n  26 \n  27 **Sections needed**:\n  28 - Prerequisites\n  29 - Fork and clone\n  30 - Install dependencies\n  31 - Run tests\n  32 - Start local mesh\n  33 \n  34 ---\n  35 \n  36","ref":"macula_http3_mesh_contributing.html#development-setup"},{"type":"extras","title":"Testing Requirements - Contributing","doc":"37 \n  38 ⚠️ **TODO**: Testing standards.\n  39 \n  40 **Topics**:\n  41 - Unit tests (EUnit/ExUnit)\n  42 - Integration tests\n  43 - Property-based tests (PropEr/StreamData)\n  44 - Coverage requirements\n  45 \n  46 ---\n  47 \n  48","ref":"macula_http3_mesh_contributing.html#testing-requirements"},{"type":"extras","title":"Code Style Guide - Contributing","doc":"49 \n  50 ⚠️ **TODO**: Erlang/Elixir coding conventions.\n  51 \n  52 **Topics**:\n  53 - Formatting (mix format, erlfmt)\n  54 - Naming conventions\n  55 - Documentation requirements\n  56 - Type specifications\n  57 \n  58 ---\n  59 \n  60","ref":"macula_http3_mesh_contributing.html#code-style-guide"},{"type":"extras","title":"Documentation Requirements - Contributing","doc":"61 \n  62 ⚠️ **TODO**: How to document code.\n  63 \n  64 ---\n  65 \n  66","ref":"macula_http3_mesh_contributing.html#documentation-requirements"},{"type":"extras","title":"Pull Request Process - Contributing","doc":"67 \n  68 ⚠️ **TODO**: PR workflow.\n  69 \n  70 **Steps**:\n  71 1. Create feature branch\n  72 2. Make changes\n  73 3. Write tests\n  74 4. Update docs\n  75 5. Submit PR\n  76 6. Code review\n  77 7. Merge\n  78 \n  79 ---\n  80 \n  81","ref":"macula_http3_mesh_contributing.html#pull-request-process"},{"type":"extras","title":"Release Process - Contributing","doc":"82 \n  83 ⚠️ **TODO**: How releases are managed.\n  84 \n  85 ---\n  86 \n  87","ref":"macula_http3_mesh_contributing.html#release-process"},{"type":"extras","title":"Community Channels - Contributing","doc":"88 \n  89 ⚠️ **TODO**: Where to get help and discuss.\n  90 \n  91 **Channels**:\n  92 - GitHub Discussions\n  93 - Discord server\n  94 - Mailing list\n  95 - Monthly community calls\n  96 \n  97 ---\n  98 \n  99","ref":"macula_http3_mesh_contributing.html#community-channels"},{"type":"extras","title":"Roadmap and Feature Requests - Contributing","doc":"100 \n 101 ⚠️ **TODO**: How to propose new features.\n 102 \n 103 ---\n 104 \n 105","ref":"macula_http3_mesh_contributing.html#roadmap-and-feature-requests"},{"type":"extras","title":"Reporting Issues - Contributing","doc":"106 \n 107 ⚠️ **TODO**: Bug report template and guidelines.\n 108 \n 109 ---\n 110 \n 111","ref":"macula_http3_mesh_contributing.html#reporting-issues"},{"type":"extras","title":"Recognition - Contributing","doc":"112 \n 113 ⚠️ **TODO**: How contributors are recognized.\n 114 \n 115 ---\n 116 \n 117 **Last Updated**: 2025-01-08\n 118 **Contributors**: [Add names as sections are completed]","ref":"macula_http3_mesh_contributing.html#recognition"},{"type":"extras","title":"Memory Management","doc":"# Memory Management Architecture\n**Status:** ✅ **PRODUCTION-READY** (Completed 2025-11-14)\n**Project:** Macula HTTP/3 Mesh Platform\n\n---","ref":"readme-3.html"},{"type":"extras","title":"Overview - Memory Management","doc":"Macula implements comprehensive memory management to prevent OOM (Out-Of-Memory) crashes through **5 critical fixes** that bound memory usage and enable automatic cleanup.\n\n**Problem Solved:** Platform experienced OOM crashes after 30-60 minutes of operation due to unbounded data structure growth.\n\n**Solution:** Bounded pools, backpressure mechanisms, TTL-based cleanup, coordinated map management, and process monitoring.\n\n**Result:** Stable memory usage, no crashes, production-ready platform.\n\n---","ref":"readme-3.html#overview"},{"type":"extras","title":"5 Critical Memory Leak Fixes - Memory Management","doc":"","ref":"readme-3.html#5-critical-memory-leak-fixes"},{"type":"extras","title":"1. Bounded Connection Pool (macula_gateway_mesh) - Memory Management","doc":"**Problem:** Unbounded mesh connection pool\n**Solution:** LRU eviction, max 1,000 connections\n**Module:** `src/macula_gateway_mesh.erl`\n**Tests:** 22 tests passing\n**Documentation:** [02_service_ttl_cleanup.md](02_service_ttl_cleanup.md)\n\n**Key Implementation:**\n- Track last access time for each connection\n- Evict Least Recently Used when pool is full\n- O(1) connection lookup and update\n\n---","ref":"readme-3.html#1-bounded-connection-pool-macula_gateway_mesh"},{"type":"extras","title":"2. Client Connection Limits (macula_gateway_client_manager) - Memory Management","doc":"**Problem:** Unbounded client connections\n**Solution:** Backpressure mechanism, max 10,000 clients (configurable)\n**Module:** `src/macula_gateway_client_manager.erl`\n**Tests:** 30 tests passing\n**Documentation:** [03_stream_cleanup.md](03_stream_cleanup.md)\n\n**Key Implementation:**\n- Check pool size before accepting new client\n- Return `{error, max_clients_reached}` when full\n- Graceful degradation under load\n\n---","ref":"readme-3.html#2-client-connection-limits-macula_gateway_client_manager"},{"type":"extras","title":"3. Service TTL/Cleanup (macula_service_registry) - Memory Management","doc":"**Problem:** Unbounded `local_services` map\n**Solution:** 300-second TTL, periodic cleanup\n**Modules:**\n  - `src/macula_service_registry.erl` (cleanup function)\n  - `src/macula_advertisement_manager.erl` (periodic timer)\n**Tests:** 27 tests passing\n**Documentation:**\n  - [02_service_ttl_cleanup.md](02_service_ttl_cleanup.md)\n  - [06_periodic_cleanup.md](06_periodic_cleanup.md)\n\n**Key Implementation:**\n- Track `advertised_at` timestamp for each service\n- Automatic cleanup every 60 seconds\n- Remove services older than 300 seconds\n\n---","ref":"readme-3.html#3-service-ttl-cleanup-macula_service_registry"},{"type":"extras","title":"4. Stream Cleanup (macula_gateway_client_manager) - Memory Management","doc":"**Problem:** `client_streams` map leaked on disconnect\n**Solution:** Coordinated cleanup of both `clients` and `client_streams` maps\n**Module:** `src/macula_gateway_client_manager.erl`\n**Tests:** 32 tests passing (includes 2 new stream tests)\n**Documentation:** [03_stream_cleanup.md](03_stream_cleanup.md)\n\n**Key Implementation:**\n- Extract `node_id` from client info before removal\n- Atomic cleanup of both maps\n- Works for both explicit disconnect and crashes\n\n---","ref":"readme-3.html#4-stream-cleanup-macula_gateway_client_manager"},{"type":"extras","title":"5. Caller Process Monitoring (macula_rpc_handler) - Memory Management","doc":"**Problem:** Dead caller processes left entries for 5 seconds\n**Solution:** Monitor caller processes, immediate cleanup via DOWN messages\n**Module:** `src/macula_rpc_handler.erl`\n**Tests:** 27 tests passing (includes 2 new monitoring tests)\n**Documentation:**\n  - [04_caller_monitoring.md](04_caller_monitoring.md)\n  - [05_caller_monitoring_tests.md](05_caller_monitoring_tests.md)\n\n**Key Implementation:**\n- Two-way mapping: `MonitorRef ↔ CallId/ServiceKey`\n- Handle DOWN messages for immediate cleanup\n- Cancel timers to prevent leaks\n\n---","ref":"readme-3.html#5-caller-process-monitoring-macula_rpc_handler"},{"type":"extras","title":"Documentation Index - Memory Management","doc":"","ref":"readme-3.html#documentation-index"},{"type":"extras","title":"Implementation Details - Memory Management","doc":"1. [**Overview**](01_overview.md) - Complete implementation summary (all 5 fixes)\n2. [**Service TTL Cleanup**](02_service_ttl_cleanup.md) - Fix #3 details\n3. [**Stream Cleanup**](03_stream_cleanup.md) - Fix #4 details\n4. [**Caller Monitoring**](04_caller_monitoring.md) - Fix #5 details\n5. [**Caller Monitoring Tests**](05_caller_monitoring_tests.md) - Fix #5 test coverage\n6. [**Periodic Cleanup**](06_periodic_cleanup.md) - Automation (Task B)","ref":"readme-3.html#implementation-details"},{"type":"extras","title":"Testing & Validation - Memory Management","doc":"7. [**Load Testing**](07_load_testing.md) - Load test script & results\n8. [**Complete Summary**](08_complete_summary.md) - Comprehensive final report","ref":"readme-3.html#testing-validation"},{"type":"extras","title":"Maintenance & Operations - Memory Management","doc":"9. [**Housekeeping Report**](09_housekeeping_report.md) - Architecture review, code quality analysis, future improvements","ref":"readme-3.html#maintenance-operations"},{"type":"extras","title":"Visual Documentation - Memory Management","doc":"10. [**Diagrams**](diagrams/) - Mermaid diagrams for all memory management mechanisms\n\n---","ref":"readme-3.html#visual-documentation"},{"type":"extras","title":"Architecture Diagram - Memory Management","doc":"![Memory Management Overview](diagrams/memory_management_overview.mermaid)\n\nThe platform implements memory management at 3 layers:\n\n```\nGateway Layer (Infrastructure)\n├── mesh: Bounded Pool (LRU, max 1,000)\n├── client_manager: Client Limits (backpressure, max 10,000)\n└── client_manager: Stream Cleanup (coordinated maps)\n\nService Layer\n├── service_registry: TTL Cleanup (300s expiry)\n└── advertisement_manager: Periodic Cleanup (60s interval)\n\nApplication Layer\n└── rpc_handler: Caller Monitoring (immediate cleanup)\n```\n\n---","ref":"readme-3.html#architecture-diagram"},{"type":"extras","title":"Test Coverage - Memory Management","doc":"All memory leak fixes are comprehensively tested:\n\n| Fix | Module | Tests | Status |\n|-----|--------|-------|--------|\n| #1 Bounded Pool | `macula_gateway_mesh` | 22 | ✅ PASS |\n| #2 Client Limits | `macula_gateway_client_manager` | 30 | ✅ PASS |\n| #3 Service TTL | `macula_service_registry` | 27 | ✅ PASS |\n| #4 Stream Cleanup | `macula_gateway_client_manager` | 32 | ✅ PASS |\n| #5 Caller Monitoring | `macula_rpc_handler` | 27 | ✅ PASS |\n\n**Total:** 138 tests (7 new tests added for memory leak fixes)\n**All tests passing:** ✅\n\n---","ref":"readme-3.html#test-coverage"},{"type":"extras","title":"Production Monitoring - Memory Management","doc":"","ref":"readme-3.html#production-monitoring"},{"type":"extras","title":"Key Metrics to Monitor - Memory Management","doc":"1. **Connection Pool Size**\n   - Should stay ≤ 1,000\n   - Alert if consistently at max\n\n2. **Client Count**\n   - Should stay ≤ 10,000\n   - Track rejection rate (`max_clients_reached` errors)\n\n3. **Service Registry Size**\n   - Should remain stable over time\n   - Monitor periodic cleanup logs\n\n4. **Stream Map Size**\n   - Should match client count\n   - No orphaned entries\n\n5. **Pending Calls/Queries**\n   - Should trend toward 0\n   - Spikes OK, sustained high values indicate issues","ref":"readme-3.html#key-metrics-to-monitor"},{"type":"extras","title":"Log Monitoring - Memory Management","doc":"**Service Cleanup (runs every 60s):**\n```erlang\n[info] Service cleanup: removed 3 expired service(s)  % Normal\n[debug] Service cleanup: no expired services          % Also normal\n```\n\n**Client Rejections:**\n```erlang\n[warn] Client connection rejected: max_clients_reached  % Monitor frequency\n```\n\n**Caller Cleanup:**\n```erlang\n[debug] Cleaned up pending call due to caller death  % Expected behavior\n```\n\n---","ref":"readme-3.html#log-monitoring"},{"type":"extras","title":"Quick Start - Memory Management","doc":"","ref":"readme-3.html#quick-start"},{"type":"extras","title":"Understanding the Fixes - Memory Management","doc":"1. **Start here:** [Complete Summary](08_complete_summary.md)\n2. **Deep dive:** Individual fix documentation (02-06)\n3. **Visual learners:** [Diagrams](diagrams/)\n4. **Troubleshooting:** [Housekeeping Report](09_housekeeping_report.md) (Section 3: Documentation)","ref":"readme-3.html#understanding-the-fixes"},{"type":"extras","title":"Implementation References - Memory Management","doc":"All fixes follow idiomatic Erlang patterns:\n- ✅ Pattern matching on function heads\n- ✅ Guards instead of `if`/`case`\n- ✅ Atomic state updates\n- ✅ OTP best practices (process monitoring, timers)\n- ✅ No deep nesting\n\nSee [Housekeeping Report](09_housekeeping_report.md) Section 2 for code quality analysis.\n\n---","ref":"readme-3.html#implementation-references"},{"type":"extras","title":"Performance Impact - Memory Management","doc":"**Before Fixes:**\n- OOM crashes after 30-60 minutes\n- Unbounded memory growth\n- No cleanup mechanisms\n\n**After Fixes:**\n- Stable memory usage\n- Bounded pools prevent growth\n- Automatic cleanup maintains stability\n- No OOM crashes observed\n\n**Overhead:**\n- LRU tracking: O(1) per operation\n- Periodic cleanup: Runs every 60s, negligible CPU\n- Process monitoring: Native Erlang, no overhead\n\n---","ref":"readme-3.html#performance-impact"},{"type":"extras","title":"Future Improvements - Memory Management","doc":"See [Housekeeping Report](09_housekeeping_report.md) Section 5 for detailed recommendations:","ref":"readme-3.html#future-improvements"},{"type":"extras","title":"High Priority - Memory Management","doc":"- Memory metrics/observability (telemetry integration)\n- Troubleshooting guide for production","ref":"readme-3.html#high-priority"},{"type":"extras","title":"Medium Priority - Memory Management","doc":"- Refactor nested case statements for clarity\n- Memory pressure handling (dynamic limits)","ref":"readme-3.html#medium-priority"},{"type":"extras","title":"Low Priority - Memory Management","doc":"- Memory manager behavior abstraction\n- Unified memory management interface\n\n---","ref":"readme-3.html#low-priority"},{"type":"extras","title":"Related Documentation - Memory Management","doc":"- [Gateway Refactoring](../gateway_refactoring_plan.md) - Context for client_manager extraction\n- [Code Review Report](../CODE_REVIEW_REPORT.md) - Overall code quality assessment\n- [CLAUDE.md](../../CLAUDE.md) - Development guidelines and memory management summary\n\n---","ref":"readme-3.html#related-documentation"},{"type":"extras","title":"Contributors - Memory Management","doc":"**Implementation:** Completed 2025-11-14\n**Documentation:** ~2,500 lines across 9 documents\n**Diagrams:** 5 Mermaid diagrams\n**Time Investment:** ~6 hours (fixes + tests + docs)\n\n---","ref":"readme-3.html#contributors"},{"type":"extras","title":"Status: Production Ready ✅ - Memory Management","doc":"All 5 critical memory leak fixes are:\n- ✅ Implemented and tested\n- ✅ Following idiomatic Erlang patterns\n- ✅ Comprehensively documented\n- ✅ Production-ready\n\n**Deployment Recommendation:** Ready for staging → production with monitoring in place.\n\n---\n\n**Last Updated:** 2025-11-14\n**Next Review:** After first production deployment","ref":"readme-3.html#status-production-ready"}],"proglang":"erlang","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}