searchData={"items":[{"type":"module","title":"macula_app","doc":"macula public API","ref":"macula_app.html"},{"type":"function","title":"macula_app.start/2","doc":"","ref":"macula_app.html#start/2"},{"type":"function","title":"macula_app.stop/1","doc":"","ref":"macula_app.html#stop/1"},{"type":"module","title":"macula_cache","doc":"Generic LRU cache implementation. Provides least-recently-used eviction with configurable max size.","ref":"macula_cache.html"},{"type":"type","title":"macula_cache.cache/0","doc":"","ref":"macula_cache.html#t:cache/0"},{"type":"function","title":"macula_cache.clear/1","doc":"Clear all entries.","ref":"macula_cache.html#clear/1"},{"type":"type","title":"macula_cache.entry/0","doc":"","ref":"macula_cache.html#t:entry/0"},{"type":"function","title":"macula_cache.get/2","doc":"Get entry from cache. Returns {ok, Value, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU).","ref":"macula_cache.html#get/2"},{"type":"type","title":"macula_cache.key/0","doc":"","ref":"macula_cache.html#t:key/0"},{"type":"function","title":"macula_cache.keys/1","doc":"Get all keys in cache (most recent first).","ref":"macula_cache.html#keys/1"},{"type":"function","title":"macula_cache.max_size/1","doc":"Get max size.","ref":"macula_cache.html#max_size/1"},{"type":"function","title":"macula_cache.new/1","doc":"Create new cache with max size.","ref":"macula_cache.html#new/1"},{"type":"function","title":"macula_cache.put/3","doc":"Put entry in cache with current timestamp.","ref":"macula_cache.html#put/3"},{"type":"function","title":"macula_cache.put/4","doc":"Put entry in cache with custom timestamp (for testing).","ref":"macula_cache.html#put/4"},{"type":"function","title":"macula_cache.remove/2","doc":"Remove entry from cache.","ref":"macula_cache.html#remove/2"},{"type":"function","title":"macula_cache.size/1","doc":"Get number of entries.","ref":"macula_cache.html#size/1"},{"type":"type","title":"macula_cache.timestamp/0","doc":"","ref":"macula_cache.html#t:timestamp/0"},{"type":"type","title":"macula_cache.value/0","doc":"","ref":"macula_cache.html#t:value/0"},{"type":"module","title":"macula_client","doc":"Macula SDK - Main API module for HTTP/3 mesh client operations. This module provides the primary interface for applications to connect to Macula mesh networks and perform pub/sub and RPC operations over HTTP/3 (QUIC) transport. Quick Start Connect to a mesh, publish events, subscribe to topics, and make RPC calls. See individual function documentation for detailed examples with code.","ref":"macula_client.html"},{"type":"type","title":"macula_client.args/0","doc":"Arguments for RPC calls.","ref":"macula_client.html#t:args/0"},{"type":"function","title":"macula_client.call/3","doc":"Make a synchronous RPC call. Calls a remote procedure and waits for the result. Examples <span class=\"w\">  </span><span class=\"c1\">%% Simple RPC call</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6163995473-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">User</span><span class=\"p\" data-group-id=\"6163995473-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">call</span><span class=\"p\" data-group-id=\"6163995473-2\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6163995473-3\">&lt;&lt;</span><span class=\"s\">&quot;my.app.get_user&quot;</span><span class=\"p\" data-group-id=\"6163995473-3\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6163995473-4\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6163995473-5\">&lt;&lt;</span><span class=\"s\">&quot;user-123&quot;</span><span class=\"p\" data-group-id=\"6163995473-5\">&gt;&gt;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6163995473-4\">}</span><span class=\"p\" data-group-id=\"6163995473-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% With timeout</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6163995473-6\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"p\" data-group-id=\"6163995473-6\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">call</span><span class=\"p\" data-group-id=\"6163995473-7\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6163995473-8\">&lt;&lt;</span><span class=\"s\">&quot;my.app.process&quot;</span><span class=\"p\" data-group-id=\"6163995473-8\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"p\" data-group-id=\"6163995473-9\">#{</span><span class=\"ss\">data</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6163995473-10\">&lt;&lt;</span><span class=\"s\">&quot;large&quot;</span><span class=\"p\" data-group-id=\"6163995473-10\">&gt;&gt;</span><span class=\"p\" data-group-id=\"6163995473-9\">}</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"p\" data-group-id=\"6163995473-11\">#{</span><span class=\"ss\">timeout</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">30000</span><span class=\"p\" data-group-id=\"6163995473-11\">}</span><span class=\"p\" data-group-id=\"6163995473-7\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#call/3"},{"type":"function","title":"macula_client.call/4","doc":"Make an RPC call with options.","ref":"macula_client.html#call/4"},{"type":"type","title":"macula_client.client/0","doc":"Reference to a connected Macula mesh client.","ref":"macula_client.html#t:client/0"},{"type":"function","title":"macula_client.connect/2","doc":"Connect to a Macula mesh network. Creates a new HTTP/3 (QUIC) connection to the specified mesh endpoint. Options realm  - Required. Binary realm identifier (e.g.,  <<\"my.app.realm\">> ) auth  - Optional. Authentication map with  api_key  or other auth methods timeout  - Optional. Connection timeout in milliseconds (default: 5000) node_id  - Optional. 32-byte node ID (generated if not provided) Examples <span class=\"w\">  </span><span class=\"c1\">%% Basic connection</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6515165655-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Client</span><span class=\"p\" data-group-id=\"6515165655-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">connect</span><span class=\"p\" data-group-id=\"6515165655-2\">(</span><span class=\"p\" data-group-id=\"6515165655-3\">&lt;&lt;</span><span class=\"s\">&quot;https://mesh.local:443&quot;</span><span class=\"p\" data-group-id=\"6515165655-3\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-4\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">realm</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-5\">&lt;&lt;</span><span class=\"s\">&quot;my.realm&quot;</span><span class=\"p\" data-group-id=\"6515165655-5\">&gt;&gt;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6515165655-4\">}</span><span class=\"p\" data-group-id=\"6515165655-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% With API key authentication</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6515165655-6\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Client</span><span class=\"p\" data-group-id=\"6515165655-6\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">connect</span><span class=\"p\" data-group-id=\"6515165655-7\">(</span><span class=\"p\" data-group-id=\"6515165655-8\">&lt;&lt;</span><span class=\"s\">&quot;https://mesh.local:443&quot;</span><span class=\"p\" data-group-id=\"6515165655-8\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-9\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">realm</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-10\">&lt;&lt;</span><span class=\"s\">&quot;my.realm&quot;</span><span class=\"p\" data-group-id=\"6515165655-10\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">auth</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-11\">#{</span><span class=\"ss\">api_key</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"6515165655-12\">&lt;&lt;</span><span class=\"s\">&quot;secret-key&quot;</span><span class=\"p\" data-group-id=\"6515165655-12\">&gt;&gt;</span><span class=\"p\" data-group-id=\"6515165655-11\">}</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"6515165655-9\">}</span><span class=\"p\" data-group-id=\"6515165655-7\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#connect/2"},{"type":"function","title":"macula_client.disconnect/1","doc":"Disconnect from the Macula mesh. Cleanly closes the HTTP/3 connection and cleans up all subscriptions.","ref":"macula_client.html#disconnect/1"},{"type":"type","title":"macula_client.event_data/0","doc":"Event payload data. Typically a map that will be JSON-encoded.","ref":"macula_client.html#t:event_data/0"},{"type":"type","title":"macula_client.options/0","doc":"Connection or operation options.","ref":"macula_client.html#t:options/0"},{"type":"type","title":"macula_client.procedure/0","doc":"RPC procedure name. Example:  \"my.app.get_user\" .","ref":"macula_client.html#t:procedure/0"},{"type":"function","title":"macula_client.publish/3","doc":"Publish an event to a topic. Publishes data to the specified topic. All subscribers to this topic will receive the event. Topic Design Topics should describe EVENT TYPES, not entity instances: Good:  <<\"my.app.user.registered\">>  (event type) Bad:  <<\"my.app.user.123.registered\">>  (entity ID in topic) Entity IDs belong in the event payload, not the topic name. Examples <span class=\"w\">  </span><span class=\"c1\">%% Publish with default options</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">publish</span><span class=\"p\" data-group-id=\"1616653639-1\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-2\">&lt;&lt;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"p\" data-group-id=\"1616653639-2\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-3\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">type</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-4\">&lt;&lt;</span><span class=\"s\">&quot;user.registered&quot;</span><span class=\"p\" data-group-id=\"1616653639-4\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">user_id</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-5\">&lt;&lt;</span><span class=\"s\">&quot;user-123&quot;</span><span class=\"p\" data-group-id=\"1616653639-5\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"ss\">email</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-6\">&lt;&lt;</span><span class=\"s\">&quot;user@example.com&quot;</span><span class=\"p\" data-group-id=\"1616653639-6\">&gt;&gt;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"1616653639-3\">}</span><span class=\"p\" data-group-id=\"1616653639-1\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Publish with options</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">publish</span><span class=\"p\" data-group-id=\"1616653639-7\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-8\">&lt;&lt;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"p\" data-group-id=\"1616653639-8\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-9\">#{</span><span class=\"w\">\n      </span><span class=\"ss\">data</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-10\">&lt;&lt;</span><span class=\"s\">&quot;important&quot;</span><span class=\"p\" data-group-id=\"1616653639-10\">&gt;&gt;</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"1616653639-9\">}</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1616653639-11\">#{</span><span class=\"ss\">acknowledge</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"ss\">true</span><span class=\"p\" data-group-id=\"1616653639-11\">}</span><span class=\"p\" data-group-id=\"1616653639-7\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#publish/3"},{"type":"function","title":"macula_client.publish/4","doc":"Publish an event with options.","ref":"macula_client.html#publish/4"},{"type":"function","title":"macula_client.subscribe/3","doc":"Subscribe to a topic. Subscribes to events on the specified topic. The callback function will be invoked for each event received. Callback Function The callback receives the event data and should return  ok . Examples <span class=\"w\">  </span><span class=\"c1\">%% Simple subscription</span><span class=\"w\">\n  </span><span class=\"p\" data-group-id=\"9443972824-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SubRef</span><span class=\"p\" data-group-id=\"9443972824-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">subscribe</span><span class=\"p\" data-group-id=\"9443972824-2\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"9443972824-3\">&lt;&lt;</span><span class=\"s\">&quot;my.app.events&quot;</span><span class=\"p\" data-group-id=\"9443972824-3\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">\n      </span><span class=\"nf\">fun</span><span class=\"p\" data-group-id=\"9443972824-4\">(</span><span class=\"n\">EventData</span><span class=\"p\" data-group-id=\"9443972824-4\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\">\n          </span><span class=\"nc\">io</span><span class=\"p\">:</span><span class=\"nf\">format</span><span class=\"p\" data-group-id=\"9443972824-5\">(</span><span class=\"s\">&quot;Event: </span><span class=\"si\">~p</span><span class=\"si\">~n</span><span class=\"s\">&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"9443972824-6\">[</span><span class=\"n\">EventData</span><span class=\"p\" data-group-id=\"9443972824-6\">]</span><span class=\"p\" data-group-id=\"9443972824-5\">)</span><span class=\"p\">,</span><span class=\"w\">\n          </span><span class=\"ss\">ok</span><span class=\"w\">\n      </span><span class=\"k\">end</span><span class=\"p\" data-group-id=\"9443972824-2\">)</span><span class=\"p\">.</span><span class=\"w\">\n \n  </span><span class=\"c1\">%% Unsubscribe later</span><span class=\"w\">\n  </span><span class=\"ss\">ok</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_client</span><span class=\"p\">:</span><span class=\"nf\">unsubscribe</span><span class=\"p\" data-group-id=\"9443972824-7\">(</span><span class=\"n\">Client</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SubRef</span><span class=\"p\" data-group-id=\"9443972824-7\">)</span><span class=\"p\">.</span>","ref":"macula_client.html#subscribe/3"},{"type":"type","title":"macula_client.subscription_ref/0","doc":"Reference to an active subscription for unsubscribe operations.","ref":"macula_client.html#t:subscription_ref/0"},{"type":"type","title":"macula_client.topic/0","doc":"Topic name for pub/sub operations. Topics should describe event types, not entity IDs. Example:  \"my.app.user.registered\"  (good), not  \"my.app.user.123.registered\"  (bad - ID belongs in payload).","ref":"macula_client.html#t:topic/0"},{"type":"function","title":"macula_client.unsubscribe/2","doc":"Unsubscribe from a topic. Removes the subscription identified by the subscription reference.","ref":"macula_client.html#unsubscribe/2"},{"type":"module","title":"macula_connection","doc":"Macula SDK connection manager. Manages individual HTTP/3 (QUIC) connections to Macula mesh nodes. Handles connection lifecycle, authentication, message sending/receiving, and subscription management.","ref":"macula_connection.html"},{"type":"function","title":"macula_connection.call/3","doc":"Make an RPC call through this client (default timeout).","ref":"macula_connection.html#call/3"},{"type":"function","title":"macula_connection.call/4","doc":"Make an RPC call through this client with options.","ref":"macula_connection.html#call/4"},{"type":"function","title":"macula_connection.publish/3","doc":"Publish an event through this client (no options).","ref":"macula_connection.html#publish/3"},{"type":"function","title":"macula_connection.publish/4","doc":"Publish an event through this client with options.","ref":"macula_connection.html#publish/4"},{"type":"function","title":"macula_connection.start_link/2","doc":"Start a client connection to a Macula mesh.","ref":"macula_connection.html#start_link/2"},{"type":"function","title":"macula_connection.stop/1","doc":"Stop the client connection.","ref":"macula_connection.html#stop/1"},{"type":"function","title":"macula_connection.subscribe/3","doc":"Subscribe to a topic through this client.","ref":"macula_connection.html#subscribe/3"},{"type":"function","title":"macula_connection.unsubscribe/2","doc":"Unsubscribe from a topic.","ref":"macula_connection.html#unsubscribe/2"},{"type":"module","title":"macula_core_types","doc":"Core type definitions and encoding/decoding for Macula. Provides fundamental types like node IDs, realm IDs, and addresses.","ref":"macula_core_types.html"},{"type":"type","title":"macula_core_types.address/0","doc":"","ref":"macula_core_types.html#t:address/0"},{"type":"function","title":"macula_core_types.decode_address/1","doc":"Decode binary address format to {IP, Port} tuple.","ref":"macula_core_types.html#decode_address/1"},{"type":"function","title":"macula_core_types.encode_address/1","doc":"Encode an IP address and port to binary format. Format: - 1 byte: IP version (4 or 6) - 4 or 16 bytes: IP address - 2 bytes: port (big-endian)","ref":"macula_core_types.html#encode_address/1"},{"type":"type","title":"macula_core_types.ip_address/0","doc":"","ref":"macula_core_types.html#t:ip_address/0"},{"type":"type","title":"macula_core_types.node_id/0","doc":"32-byte unique node identifier","ref":"macula_core_types.html#t:node_id/0"},{"type":"function","title":"macula_core_types.node_id/0","doc":"Generate a unique node ID. Uses cryptographically strong random bytes for uniqueness.","ref":"macula_core_types.html#node_id/0"},{"type":"type","title":"macula_core_types.port_number/0","doc":"","ref":"macula_core_types.html#t:port_number/0"},{"type":"type","title":"macula_core_types.realm_id/0","doc":"32-byte realm identifier","ref":"macula_core_types.html#t:realm_id/0"},{"type":"function","title":"macula_core_types.realm_id/1","doc":"Generate a deterministic realm ID from a realm name. Same name always produces the same ID (uses SHA-256 hash).","ref":"macula_core_types.html#realm_id/1"},{"type":"module","title":"macula_discovery","doc":"Generic DHT-based service discovery. Provides cache-integrated lookup and announcement operations. Used by both pub/sub and RPC discovery layers.","ref":"macula_discovery.html"},{"type":"function","title":"macula_discovery.announce/2","doc":"Announce value to DHT.","ref":"macula_discovery.html#announce/2"},{"type":"function","title":"macula_discovery.filter_by_age/3","doc":"Filter items by age based on last_seen timestamp and TTL. Items must have #{last_seen := integer()} in their structure.","ref":"macula_discovery.html#filter_by_age/3"},{"type":"function","title":"macula_discovery.find/2","doc":"Find values for a key via DHT lookup.","ref":"macula_discovery.html#find/2"},{"type":"function","title":"macula_discovery.find_with_cache/3","doc":"Find values with cache (default TTL: 300 seconds).","ref":"macula_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_discovery.find_with_cache/4","doc":"Find values with cache and custom TTL.","ref":"macula_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_discovery.key/0","doc":"","ref":"macula_discovery.html#t:key/0"},{"type":"type","title":"macula_discovery.lookup_fun/0","doc":"","ref":"macula_discovery.html#t:lookup_fun/0"},{"type":"type","title":"macula_discovery.publish_fun/0","doc":"","ref":"macula_discovery.html#t:publish_fun/0"},{"type":"function","title":"macula_discovery.unannounce/2","doc":"Remove value from DHT.","ref":"macula_discovery.html#unannounce/2"},{"type":"type","title":"macula_discovery.unpublish_fun/0","doc":"","ref":"macula_discovery.html#t:unpublish_fun/0"},{"type":"type","title":"macula_discovery.value/0","doc":"","ref":"macula_discovery.html#t:value/0"},{"type":"module","title":"macula_gateway","doc":"Macula Gateway - HTTP/3 Message Router Main API module for the Macula Gateway. The gateway can be embedded in applications or run standalone. Architecture: - QUIC Listener: Accepts HTTP/3 connections from SDK clients - Router: Routes pub/sub messages between clients - RPC: Handles remote procedure calls - Realm Manager: Manages multiple realms Usage (Embedded): <span class=\"w\">   </span><span class=\"p\" data-group-id=\"1163403729-1\">{</span><span class=\"ss\">ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Pid</span><span class=\"p\" data-group-id=\"1163403729-1\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">macula_gateway</span><span class=\"p\">:</span><span class=\"nf\">start_link</span><span class=\"p\" data-group-id=\"1163403729-2\">(</span><span class=\"p\" data-group-id=\"1163403729-3\">[</span><span class=\"w\">\n       </span><span class=\"p\" data-group-id=\"1163403729-4\">{</span><span class=\"ss\">port</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">9443</span><span class=\"p\" data-group-id=\"1163403729-4\">}</span><span class=\"p\">,</span><span class=\"w\">\n       </span><span class=\"p\" data-group-id=\"1163403729-5\">{</span><span class=\"ss\">realm</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\" data-group-id=\"1163403729-6\">&lt;&lt;</span><span class=\"s\">&quot;com.example.realm&quot;</span><span class=\"p\" data-group-id=\"1163403729-6\">&gt;&gt;</span><span class=\"p\" data-group-id=\"1163403729-5\">}</span><span class=\"w\">\n   </span><span class=\"p\" data-group-id=\"1163403729-3\">]</span><span class=\"p\" data-group-id=\"1163403729-2\">)</span><span class=\"p\">.</span> Usage (Standalone): <span class=\"w\">   </span><span class=\"nc\">application</span><span class=\"p\">:</span><span class=\"nf\">start</span><span class=\"p\" data-group-id=\"3829092687-1\">(</span><span class=\"ss\">macula_gateway</span><span class=\"p\" data-group-id=\"3829092687-1\">)</span><span class=\"p\">.</span>","ref":"macula_gateway.html"},{"type":"function","title":"macula_gateway.get_stats/1","doc":"Get gateway statistics.","ref":"macula_gateway.html#get_stats/1"},{"type":"function","title":"macula_gateway.handle_call/3","doc":"","ref":"macula_gateway.html#handle_call/3"},{"type":"function","title":"macula_gateway.handle_cast/2","doc":"","ref":"macula_gateway.html#handle_cast/2"},{"type":"function","title":"macula_gateway.handle_info/2","doc":"","ref":"macula_gateway.html#handle_info/2"},{"type":"function","title":"macula_gateway.init/1","doc":"","ref":"macula_gateway.html#init/1"},{"type":"function","title":"macula_gateway.start_link/0","doc":"Start the gateway with default options.","ref":"macula_gateway.html#start_link/0"},{"type":"function","title":"macula_gateway.start_link/1","doc":"Start the gateway with custom options. Options: {port, Port} - Listen port (default: 9443) {realm, Realm} - Default realm (default: \"macula.default\")","ref":"macula_gateway.html#start_link/1"},{"type":"function","title":"macula_gateway.stop/1","doc":"Stop the gateway.","ref":"macula_gateway.html#stop/1"},{"type":"function","title":"macula_gateway.terminate/2","doc":"","ref":"macula_gateway.html#terminate/2"},{"type":"module","title":"macula_gateway_diagnostics","doc":"Macula Gateway Diagnostics Service Provides simple diagnostic procedures that clients can call to verify connectivity and test the gateway's RPC functionality. Available procedures: - com.macula.diagnostics.hello - Returns a friendly greeting with gateway info - com.macula.diagnostics.echo - Echoes back the arguments sent by client - com.macula.diagnostics.info - Returns detailed gateway information Usage: The diagnostics service automatically registers when the gateway starts. Clients can call these procedures using the Macula SDK: Elixir: {:ok, result} = MaculaSdk.Client.call(client, \"com.macula.diagnostics.hello\", %{}) Result: %{ \"message\" => \"Hello from Macula Gateway!\", \"gateway\" => \"macula@127.0.0.1\", \"realm\" => \"com.example.realm\", \"uptime_seconds\" => 42, \"timestamp\" => 1699612800 }","ref":"macula_gateway_diagnostics.html"},{"type":"function","title":"macula_gateway_diagnostics.handle_call/3","doc":"","ref":"macula_gateway_diagnostics.html#handle_call/3"},{"type":"function","title":"macula_gateway_diagnostics.handle_cast/2","doc":"","ref":"macula_gateway_diagnostics.html#handle_cast/2"},{"type":"function","title":"macula_gateway_diagnostics.handle_info/2","doc":"","ref":"macula_gateway_diagnostics.html#handle_info/2"},{"type":"function","title":"macula_gateway_diagnostics.init/1","doc":"","ref":"macula_gateway_diagnostics.html#init/1"},{"type":"function","title":"macula_gateway_diagnostics.register_procedures/1","doc":"Register diagnostic procedures with the gateway","ref":"macula_gateway_diagnostics.html#register_procedures/1"},{"type":"function","title":"macula_gateway_diagnostics.start_link/1","doc":"Start the diagnostics service","ref":"macula_gateway_diagnostics.html#start_link/1"},{"type":"function","title":"macula_gateway_diagnostics.terminate/2","doc":"","ref":"macula_gateway_diagnostics.html#terminate/2"},{"type":"module","title":"macula_gateway_health","doc":"Macula Gateway Health Check Server Provides HTTP health endpoints for Kubernetes liveness and readiness probes. Runs on a separate port (8080) from the main QUIC gateway (9443). Endpoints: GET /health - Overall health status GET /ready - Readiness check (can accept traffic) GET /live - Liveness check (process is alive) GET /metrics - Basic metrics (optional)","ref":"macula_gateway_health.html"},{"type":"function","title":"macula_gateway_health.handle_call/3","doc":"","ref":"macula_gateway_health.html#handle_call/3"},{"type":"function","title":"macula_gateway_health.handle_cast/2","doc":"","ref":"macula_gateway_health.html#handle_cast/2"},{"type":"function","title":"macula_gateway_health.handle_info/2","doc":"","ref":"macula_gateway_health.html#handle_info/2"},{"type":"function","title":"macula_gateway_health.init/1","doc":"","ref":"macula_gateway_health.html#init/1"},{"type":"function","title":"macula_gateway_health.is_healthy/0","doc":"Check if the gateway is healthy.","ref":"macula_gateway_health.html#is_healthy/0"},{"type":"function","title":"macula_gateway_health.set_ready/1","doc":"Set the readiness state.","ref":"macula_gateway_health.html#set_ready/1"},{"type":"function","title":"macula_gateway_health.start_link/1","doc":"Start the health check server.","ref":"macula_gateway_health.html#start_link/1"},{"type":"function","title":"macula_gateway_health.stop/0","doc":"Stop the health check server.","ref":"macula_gateway_health.html#stop/0"},{"type":"function","title":"macula_gateway_health.terminate/2","doc":"","ref":"macula_gateway_health.html#terminate/2"},{"type":"module","title":"macula_id","doc":"ID generation utilities for Macula. Provides functions for generating various types of IDs.","ref":"macula_id.html"},{"type":"function","title":"macula_id.from_hex/1","doc":"Convert hex string to binary.","ref":"macula_id.html#from_hex/1"},{"type":"function","title":"macula_id.from_uuid/1","doc":"Convert UUID string to 16-byte binary ID.","ref":"macula_id.html#from_uuid/1"},{"type":"function","title":"macula_id.hash_id/1","doc":"Generate deterministic 256-bit hash ID from data.","ref":"macula_id.html#hash_id/1"},{"type":"function","title":"macula_id.message_id/0","doc":"Generate 128-bit (16-byte) random message ID.","ref":"macula_id.html#message_id/0"},{"type":"function","title":"macula_id.node_id/0","doc":"Generate 256-bit (32-byte) random node ID.","ref":"macula_id.html#node_id/0"},{"type":"function","title":"macula_id.session_id/0","doc":"Generate 128-bit (16-byte) random session ID.","ref":"macula_id.html#session_id/0"},{"type":"function","title":"macula_id.to_hex/1","doc":"Convert binary to lowercase hex string.","ref":"macula_id.html#to_hex/1"},{"type":"function","title":"macula_id.to_uuid/1","doc":"Convert 16-byte or 32-byte binary ID to UUID string format. For 16-byte: 8-4-4-4-12 (e.g., \"12345678-90ab-cdef-1234-567890abcdef\") For 32-byte: Uses first 16 bytes","ref":"macula_id.html#to_uuid/1"},{"type":"module","title":"macula_membership_detector","doc":"SWIM failure detector (pure logic, no GenServer). Orchestrates member list, gossip, and protocol timing.","ref":"macula_membership_detector.html"},{"type":"function","title":"macula_membership_detector.add_member/2","doc":"Add a member to the list.","ref":"macula_membership_detector.html#add_member/2"},{"type":"function","title":"macula_membership_detector.apply_gossip_updates/2","doc":"Apply received gossip updates.","ref":"macula_membership_detector.html#apply_gossip_updates/2"},{"type":"type","title":"macula_membership_detector.detector_state/0","doc":"","ref":"macula_membership_detector.html#t:detector_state/0"},{"type":"function","title":"macula_membership_detector.get_alive_members/1","doc":"Get all alive members.","ref":"macula_membership_detector.html#get_alive_members/1"},{"type":"function","title":"macula_membership_detector.get_gossip_updates/2","doc":"Get gossip updates to piggyback on messages.","ref":"macula_membership_detector.html#get_gossip_updates/2"},{"type":"function","title":"macula_membership_detector.get_member/2","doc":"Get a member by node ID.","ref":"macula_membership_detector.html#get_member/2"},{"type":"function","title":"macula_membership_detector.local_node_id/1","doc":"Get local node ID.","ref":"macula_membership_detector.html#local_node_id/1"},{"type":"function","title":"macula_membership_detector.mark_dead/2","doc":"Mark a member as dead.","ref":"macula_membership_detector.html#mark_dead/2"},{"type":"function","title":"macula_membership_detector.mark_suspect/2","doc":"Mark a member as suspect.","ref":"macula_membership_detector.html#mark_suspect/2"},{"type":"function","title":"macula_membership_detector.new/2","doc":"Create a new detector state.","ref":"macula_membership_detector.html#new/2"},{"type":"function","title":"macula_membership_detector.protocol_period/1","doc":"Get protocol period.","ref":"macula_membership_detector.html#protocol_period/1"},{"type":"function","title":"macula_membership_detector.refute_suspicion/1","doc":"Refute suspicion (increment local incarnation).","ref":"macula_membership_detector.html#refute_suspicion/1"},{"type":"function","title":"macula_membership_detector.select_probe_target/1","doc":"Select a random member to probe (excluding self).","ref":"macula_membership_detector.html#select_probe_target/1"},{"type":"module","title":"macula_membership_gossip","doc":"Gossip dissemination for SWIM protocol. Tracks membership updates and provides them for piggybacking. Uses exponential decay: log(N) messages per update.","ref":"macula_membership_gossip.html"},{"type":"function","title":"macula_membership_gossip.add_update/4","doc":"Add a membership update to gossip. If a more recent update exists, it's replaced.","ref":"macula_membership_gossip.html#add_update/4"},{"type":"function","title":"macula_membership_gossip.get_updates/2","doc":"Get updates to piggyback on messages. Returns most recent updates first, limited by max_updates.","ref":"macula_membership_gossip.html#get_updates/2"},{"type":"type","title":"macula_membership_gossip.gossip_state/0","doc":"","ref":"macula_membership_gossip.html#t:gossip_state/0"},{"type":"function","title":"macula_membership_gossip.mark_transmitted/2","doc":"Mark an update as transmitted (increment transmit count).","ref":"macula_membership_gossip.html#mark_transmitted/2"},{"type":"function","title":"macula_membership_gossip.merge_updates/2","doc":"Merge received gossip updates into local state. Uses SWIM merge semantics (higher incarnation wins, etc.).","ref":"macula_membership_gossip.html#merge_updates/2"},{"type":"function","title":"macula_membership_gossip.new/0","doc":"Create a new gossip state.","ref":"macula_membership_gossip.html#new/0"},{"type":"function","title":"macula_membership_gossip.prune/2","doc":"Prune updates that have been transmitted enough times. Target is typically log(N) where N is cluster size.","ref":"macula_membership_gossip.html#prune/2"},{"type":"type","title":"macula_membership_gossip.update/0","doc":"","ref":"macula_membership_gossip.html#t:update/0"},{"type":"module","title":"macula_membership_list","doc":"Membership list for SWIM protocol. Maintains cluster membership view with fast concurrent access. Uses map-based storage (could be ETS in production).","ref":"macula_membership_list.html"},{"type":"function","title":"macula_membership_list.add_member/2","doc":"Add a new member to the list. If member already exists, this is a no-op (use update_member instead).","ref":"macula_membership_list.html#add_member/2"},{"type":"function","title":"macula_membership_list.get_alive_members/1","doc":"Get all alive members.","ref":"macula_membership_list.html#get_alive_members/1"},{"type":"function","title":"macula_membership_list.get_all_members/1","doc":"Get all members.","ref":"macula_membership_list.html#get_all_members/1"},{"type":"function","title":"macula_membership_list.get_member/2","doc":"Get a member by node ID.","ref":"macula_membership_list.html#get_member/2"},{"type":"function","title":"macula_membership_list.get_random_members/2","doc":"Get N random members from the list.","ref":"macula_membership_list.html#get_random_members/2"},{"type":"function","title":"macula_membership_list.get_random_members/3","doc":"Get N random members excluding specified node ID.","ref":"macula_membership_list.html#get_random_members/3"},{"type":"function","title":"macula_membership_list.get_suspect_members/1","doc":"Get all suspect members.","ref":"macula_membership_list.html#get_suspect_members/1"},{"type":"type","title":"macula_membership_list.member_list/0","doc":"","ref":"macula_membership_list.html#t:member_list/0"},{"type":"function","title":"macula_membership_list.new/1","doc":"Create a new membership list with the local node.","ref":"macula_membership_list.html#new/1"},{"type":"function","title":"macula_membership_list.remove_member/2","doc":"Remove a member from the list.","ref":"macula_membership_list.html#remove_member/2"},{"type":"function","title":"macula_membership_list.size/1","doc":"Get the number of members in the list.","ref":"macula_membership_list.html#size/1"},{"type":"function","title":"macula_membership_list.update_member/2","doc":"Update an existing member (or add if not present). Uses merge semantics to resolve conflicts.","ref":"macula_membership_list.html#update_member/2"},{"type":"module","title":"macula_membership_member","doc":"Member record and state transitions for SWIM protocol. Represents a single node in the membership list.","ref":"macula_membership_member.html"},{"type":"function","title":"macula_membership_member.address/1","doc":"Get address.","ref":"macula_membership_member.html#address/1"},{"type":"function","title":"macula_membership_member.compare/2","doc":"Compare two members to determine which is more recent. Returns: gt (M1 is newer), lt (M1 is older), eq (same)","ref":"macula_membership_member.html#compare/2"},{"type":"function","title":"macula_membership_member.incarnation/1","doc":"Get incarnation number.","ref":"macula_membership_member.html#incarnation/1"},{"type":"function","title":"macula_membership_member.mark_alive/2","doc":"Mark member as alive with new incarnation (refutation). Dead members cannot be revived.","ref":"macula_membership_member.html#mark_alive/2"},{"type":"function","title":"macula_membership_member.mark_dead/1","doc":"Mark member as dead (confirmed failure).","ref":"macula_membership_member.html#mark_dead/1"},{"type":"function","title":"macula_membership_member.mark_suspect/1","doc":"Mark member as suspect (failed to respond to ping).","ref":"macula_membership_member.html#mark_suspect/1"},{"type":"type","title":"macula_membership_member.member/0","doc":"","ref":"macula_membership_member.html#t:member/0"},{"type":"function","title":"macula_membership_member.merge/2","doc":"Merge two member states, keeping the most recent information. Rules: 1. Dead always wins 2. Higher incarnation wins 3. Same incarnation: suspect > alive","ref":"macula_membership_member.html#merge/2"},{"type":"function","title":"macula_membership_member.metadata/1","doc":"Get metadata.","ref":"macula_membership_member.html#metadata/1"},{"type":"function","title":"macula_membership_member.new/2","doc":"Create a new member with alive status and incarnation 0.","ref":"macula_membership_member.html#new/2"},{"type":"function","title":"macula_membership_member.new/3","doc":"Create a new member with custom metadata.","ref":"macula_membership_member.html#new/3"},{"type":"function","title":"macula_membership_member.node_id/1","doc":"Get node ID.","ref":"macula_membership_member.html#node_id/1"},{"type":"type","title":"macula_membership_member.status/0","doc":"","ref":"macula_membership_member.html#t:status/0"},{"type":"function","title":"macula_membership_member.status/1","doc":"Get status.","ref":"macula_membership_member.html#status/1"},{"type":"module","title":"macula_names","doc":"Shared naming utilities for hierarchical dot-separated names. Used by both pub/sub topics and RPC procedure names. Supports DNS-style reverse notation: org.domain.service.method","ref":"macula_names.html"},{"type":"type","title":"macula_names.name/0","doc":"","ref":"macula_names.html#t:name/0"},{"type":"function","title":"macula_names.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_names.html#namespace/1"},{"type":"function","title":"macula_names.normalize/1","doc":"Normalize name (lowercase, trim, remove double dots).","ref":"macula_names.html#normalize/1"},{"type":"type","title":"macula_names.options/0","doc":"","ref":"macula_names.html#t:options/0"},{"type":"function","title":"macula_names.segment_count/1","doc":"Count number of segments in name.","ref":"macula_names.html#segment_count/1"},{"type":"function","title":"macula_names.validate/1","doc":"Validate name syntax with default options (no wildcards).","ref":"macula_names.html#validate/1"},{"type":"function","title":"macula_names.validate/2","doc":"Validate name syntax with options. Valid names: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen - Optionally allow wildcards (* and #) for patterns - No leading or trailing dots - No double dots","ref":"macula_names.html#validate/2"},{"type":"module","title":"macula_node","doc":"Node identity and metadata management. Represents a single node in the Macula mesh.","ref":"macula_node.html"},{"type":"type","title":"macula_node.address/0","doc":"","ref":"macula_node.html#t:address/0"},{"type":"function","title":"macula_node.equals/2","doc":"Check if two nodes are equal (by ID).","ref":"macula_node.html#equals/2"},{"type":"function","title":"macula_node.from_binary/1","doc":"Decode node from binary.","ref":"macula_node.html#from_binary/1"},{"type":"function","title":"macula_node.get_address/1","doc":"Get address.","ref":"macula_node.html#get_address/1"},{"type":"function","title":"macula_node.get_id/1","doc":"Get node ID.","ref":"macula_node.html#get_id/1"},{"type":"function","title":"macula_node.get_metadata/1","doc":"Get metadata.","ref":"macula_node.html#get_metadata/1"},{"type":"function","title":"macula_node.get_realm/1","doc":"Get realm.","ref":"macula_node.html#get_realm/1"},{"type":"type","title":"macula_node.macula_node/0","doc":"","ref":"macula_node.html#t:macula_node/0"},{"type":"type","title":"macula_node.metadata/0","doc":"","ref":"macula_node.html#t:metadata/0"},{"type":"function","title":"macula_node.new/1","doc":"Create new node with random ID.","ref":"macula_node.html#new/1"},{"type":"function","title":"macula_node.new/2","doc":"Create new node with random ID and metadata.","ref":"macula_node.html#new/2"},{"type":"type","title":"macula_node.node_id/0","doc":"32-byte unique identifier","ref":"macula_node.html#t:node_id/0"},{"type":"type","title":"macula_node.realm/0","doc":"","ref":"macula_node.html#t:realm/0"},{"type":"function","title":"macula_node.set_address/2","doc":"Set address.","ref":"macula_node.html#set_address/2"},{"type":"function","title":"macula_node.set_metadata/2","doc":"Set metadata (replaces existing).","ref":"macula_node.html#set_metadata/2"},{"type":"function","title":"macula_node.to_binary/1","doc":"Encode node to binary.","ref":"macula_node.html#to_binary/1"},{"type":"function","title":"macula_node.update_metadata/2","doc":"Update metadata (merges with existing).","ref":"macula_node.html#update_metadata/2"},{"type":"module","title":"macula_protocol_decoder","doc":"Protocol message decoder for Macula mesh. Decodes binary wire format to message maps.","ref":"macula_protocol_decoder.html"},{"type":"function","title":"macula_protocol_decoder.decode/1","doc":"Decode a binary message to {Type, Msg} tuple. Returns {ok, {Type, Msg}} on success or {error, Reason} on failure.","ref":"macula_protocol_decoder.html#decode/1"},{"type":"module","title":"macula_protocol_encoder","doc":"Protocol message encoder for Macula mesh. Encodes message maps to binary wire format. Frame Format (8-byte header + payload): - Version (1 byte): Protocol version (currently 0x01) - Type (1 byte): Message type ID - Flags (1 byte): Reserved for future use (0x00) - Reserved (1 byte): Must be 0x00 - Payload Length (4 bytes): Big-endian uint32 - Payload (N bytes): MessagePack-encoded message data","ref":"macula_protocol_encoder.html"},{"type":"function","title":"macula_protocol_encoder.encode/2","doc":"Encode a message to binary format. Returns a binary with 8-byte header + MessagePack payload.","ref":"macula_protocol_encoder.html#encode/2"},{"type":"module","title":"macula_protocol_types","doc":"Protocol message type definitions and constants for Macula mesh. Defines all message types that can be sent over QUIC streams.","ref":"macula_protocol_types.html"},{"type":"type","title":"macula_protocol_types.call_msg/0","doc":"","ref":"macula_protocol_types.html#t:call_msg/0"},{"type":"type","title":"macula_protocol_types.cast_msg/0","doc":"","ref":"macula_protocol_types.html#t:cast_msg/0"},{"type":"type","title":"macula_protocol_types.connect_msg/0","doc":"","ref":"macula_protocol_types.html#t:connect_msg/0"},{"type":"type","title":"macula_protocol_types.disconnect_msg/0","doc":"","ref":"macula_protocol_types.html#t:disconnect_msg/0"},{"type":"type","title":"macula_protocol_types.message/0","doc":"","ref":"macula_protocol_types.html#t:message/0"},{"type":"type","title":"macula_protocol_types.message_type/0","doc":"","ref":"macula_protocol_types.html#t:message_type/0"},{"type":"function","title":"macula_protocol_types.message_type_id/1","doc":"Get numeric ID for a message type.","ref":"macula_protocol_types.html#message_type_id/1"},{"type":"function","title":"macula_protocol_types.message_type_name/1","doc":"Get message type name from numeric ID.","ref":"macula_protocol_types.html#message_type_name/1"},{"type":"type","title":"macula_protocol_types.ping_msg/0","doc":"","ref":"macula_protocol_types.html#t:ping_msg/0"},{"type":"type","title":"macula_protocol_types.pong_msg/0","doc":"","ref":"macula_protocol_types.html#t:pong_msg/0"},{"type":"type","title":"macula_protocol_types.publish_msg/0","doc":"","ref":"macula_protocol_types.html#t:publish_msg/0"},{"type":"type","title":"macula_protocol_types.reply_msg/0","doc":"","ref":"macula_protocol_types.html#t:reply_msg/0"},{"type":"type","title":"macula_protocol_types.subscribe_msg/0","doc":"","ref":"macula_protocol_types.html#t:subscribe_msg/0"},{"type":"type","title":"macula_protocol_types.unsubscribe_msg/0","doc":"","ref":"macula_protocol_types.html#t:unsubscribe_msg/0"},{"type":"module","title":"macula_pubsub_cache","doc":"LRU cache for remote subscriber lists. Caches DHT query results to avoid repeated lookups. Wraps macula_cache with subscriber-specific logic.","ref":"macula_pubsub_cache.html"},{"type":"type","title":"macula_pubsub_cache.cache/0","doc":"","ref":"macula_pubsub_cache.html#t:cache/0"},{"type":"function","title":"macula_pubsub_cache.clear/1","doc":"Clear all entries.","ref":"macula_pubsub_cache.html#clear/1"},{"type":"function","title":"macula_pubsub_cache.get/2","doc":"Get entry from cache. Returns {ok, Subscribers, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU).","ref":"macula_pubsub_cache.html#get/2"},{"type":"function","title":"macula_pubsub_cache.invalidate/2","doc":"Invalidate (remove) entry.","ref":"macula_pubsub_cache.html#invalidate/2"},{"type":"function","title":"macula_pubsub_cache.is_expired/3","doc":"Check if entry is expired based on TTL. This checks if entry exists and its age exceeds TTL.","ref":"macula_pubsub_cache.html#is_expired/3"},{"type":"function","title":"macula_pubsub_cache.max_size/1","doc":"Get max size.","ref":"macula_pubsub_cache.html#max_size/1"},{"type":"function","title":"macula_pubsub_cache.new/1","doc":"Create new cache with max size.","ref":"macula_pubsub_cache.html#new/1"},{"type":"function","title":"macula_pubsub_cache.put/3","doc":"Put entry in cache.","ref":"macula_pubsub_cache.html#put/3"},{"type":"function","title":"macula_pubsub_cache.put_with_timestamp/4","doc":"Put entry with custom timestamp (for testing).","ref":"macula_pubsub_cache.html#put_with_timestamp/4"},{"type":"function","title":"macula_pubsub_cache.size/1","doc":"Get number of entries.","ref":"macula_pubsub_cache.html#size/1"},{"type":"module","title":"macula_pubsub_delivery","doc":"Message routing and delivery to local and remote subscribers. Combines local registry and remote discovery for full fan-out.","ref":"macula_pubsub_delivery.html"},{"type":"function","title":"macula_pubsub_delivery.deliver_local/2","doc":"Deliver message to all matching local subscribers.","ref":"macula_pubsub_delivery.html#deliver_local/2"},{"type":"function","title":"macula_pubsub_delivery.deliver_remote/3","doc":"Deliver message to remote subscribers via QUIC.","ref":"macula_pubsub_delivery.html#deliver_remote/3"},{"type":"type","title":"macula_pubsub_delivery.delivery_result/0","doc":"","ref":"macula_pubsub_delivery.html#t:delivery_result/0"},{"type":"type","title":"macula_pubsub_delivery.discovery_fun/0","doc":"","ref":"macula_pubsub_delivery.html#t:discovery_fun/0"},{"type":"function","title":"macula_pubsub_delivery.get_matching_patterns/2","doc":"Get all unique patterns that match the topic. Used for remote subscriber discovery.","ref":"macula_pubsub_delivery.html#get_matching_patterns/2"},{"type":"type","title":"macula_pubsub_delivery.message/0","doc":"","ref":"macula_pubsub_delivery.html#t:message/0"},{"type":"function","title":"macula_pubsub_delivery.publish/4","doc":"Publish message to both local and remote subscribers. Returns {LocalResults, RemoteResults}.","ref":"macula_pubsub_delivery.html#publish/4"},{"type":"type","title":"macula_pubsub_delivery.send_fun/0","doc":"","ref":"macula_pubsub_delivery.html#t:send_fun/0"},{"type":"module","title":"macula_pubsub_discovery","doc":"DHT integration for finding remote subscribers. Uses Kademlia DHT to publish and discover subscriptions. Wraps macula_discovery with pub/sub-specific types.","ref":"macula_pubsub_discovery.html"},{"type":"type","title":"macula_pubsub_discovery.address/0","doc":"","ref":"macula_pubsub_discovery.html#t:address/0"},{"type":"function","title":"macula_pubsub_discovery.announce/4","doc":"Announce local subscription to DHT.","ref":"macula_pubsub_discovery.html#announce/4"},{"type":"type","title":"macula_pubsub_discovery.dht_lookup_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_lookup_fun/0"},{"type":"type","title":"macula_pubsub_discovery.dht_publish_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_publish_fun/0"},{"type":"type","title":"macula_pubsub_discovery.dht_unpublish_fun/0","doc":"","ref":"macula_pubsub_discovery.html#t:dht_unpublish_fun/0"},{"type":"function","title":"macula_pubsub_discovery.find_subscribers/2","doc":"Find remote subscribers for a pattern via DHT.","ref":"macula_pubsub_discovery.html#find_subscribers/2"},{"type":"function","title":"macula_pubsub_discovery.find_with_cache/3","doc":"Find subscribers with cache (default TTL: 300 seconds).","ref":"macula_pubsub_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_pubsub_discovery.find_with_cache/4","doc":"Find subscribers with cache and custom TTL.","ref":"macula_pubsub_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_pubsub_discovery.node_id/0","doc":"","ref":"macula_pubsub_discovery.html#t:node_id/0"},{"type":"type","title":"macula_pubsub_discovery.pattern/0","doc":"","ref":"macula_pubsub_discovery.html#t:pattern/0"},{"type":"type","title":"macula_pubsub_discovery.subscriber/0","doc":"","ref":"macula_pubsub_discovery.html#t:subscriber/0"},{"type":"function","title":"macula_pubsub_discovery.unannounce/3","doc":"Remove local subscription from DHT.","ref":"macula_pubsub_discovery.html#unannounce/3"},{"type":"module","title":"macula_pubsub_registry","doc":"Local subscription registry for pub/sub. Maps topic patterns to local subscribers (callback PIDs).","ref":"macula_pubsub_registry.html"},{"type":"function","title":"macula_pubsub_registry.get_subscription/3","doc":"Get specific subscription.","ref":"macula_pubsub_registry.html#get_subscription/3"},{"type":"function","title":"macula_pubsub_registry.list_patterns/1","doc":"List all unique patterns.","ref":"macula_pubsub_registry.html#list_patterns/1"},{"type":"function","title":"macula_pubsub_registry.match/2","doc":"Find subscriptions matching a topic.","ref":"macula_pubsub_registry.html#match/2"},{"type":"function","title":"macula_pubsub_registry.new/0","doc":"Create new empty registry.","ref":"macula_pubsub_registry.html#new/0"},{"type":"type","title":"macula_pubsub_registry.registry/0","doc":"","ref":"macula_pubsub_registry.html#t:registry/0"},{"type":"function","title":"macula_pubsub_registry.size/1","doc":"Get number of subscriptions.","ref":"macula_pubsub_registry.html#size/1"},{"type":"function","title":"macula_pubsub_registry.subscribe/4","doc":"Subscribe to a pattern. If subscription already exists (same subscriber_id + pattern), updates callback.","ref":"macula_pubsub_registry.html#subscribe/4"},{"type":"type","title":"macula_pubsub_registry.subscription/0","doc":"","ref":"macula_pubsub_registry.html#t:subscription/0"},{"type":"function","title":"macula_pubsub_registry.unsubscribe/3","doc":"Unsubscribe from a pattern.","ref":"macula_pubsub_registry.html#unsubscribe/3"},{"type":"module","title":"macula_pubsub_server","doc":"Pub/Sub GenServer - manages subscriptions and message delivery. Ties together registry, cache, discovery, and delivery layers.","ref":"macula_pubsub_server.html"},{"type":"function","title":"macula_pubsub_server.cache_stats/1","doc":"Get cache statistics.","ref":"macula_pubsub_server.html#cache_stats/1"},{"type":"function","title":"macula_pubsub_server.list_patterns/1","doc":"List all unique patterns.","ref":"macula_pubsub_server.html#list_patterns/1"},{"type":"function","title":"macula_pubsub_server.list_subscriptions/1","doc":"List all subscriptions.","ref":"macula_pubsub_server.html#list_subscriptions/1"},{"type":"type","title":"macula_pubsub_server.options/0","doc":"","ref":"macula_pubsub_server.html#t:options/0"},{"type":"function","title":"macula_pubsub_server.publish/2","doc":"Publish message to all matching subscribers.","ref":"macula_pubsub_server.html#publish/2"},{"type":"function","title":"macula_pubsub_server.start_link/0","doc":"Start server with default options.","ref":"macula_pubsub_server.html#start_link/0"},{"type":"function","title":"macula_pubsub_server.start_link/1","doc":"Start server with options.","ref":"macula_pubsub_server.html#start_link/1"},{"type":"function","title":"macula_pubsub_server.stop/1","doc":"Stop server.","ref":"macula_pubsub_server.html#stop/1"},{"type":"function","title":"macula_pubsub_server.subscribe/4","doc":"Subscribe to a pattern.","ref":"macula_pubsub_server.html#subscribe/4"},{"type":"function","title":"macula_pubsub_server.subscription_count/1","doc":"Get subscription count.","ref":"macula_pubsub_server.html#subscription_count/1"},{"type":"function","title":"macula_pubsub_server.unsubscribe/3","doc":"Unsubscribe from a pattern.","ref":"macula_pubsub_server.html#unsubscribe/3"},{"type":"module","title":"macula_pubsub_topic","doc":"Topic utilities for pub/sub system. Handles topic validation, pattern matching, and normalization. Supports MQTT-style wildcards: * (single-level) and # (multi-level).","ref":"macula_pubsub_topic.html"},{"type":"function","title":"macula_pubsub_topic.matches/2","doc":"Check if topic matches pattern. Patterns can contain: - * matches exactly one segment - # matches zero or more segments","ref":"macula_pubsub_topic.html#matches/2"},{"type":"function","title":"macula_pubsub_topic.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_pubsub_topic.html#namespace/1"},{"type":"function","title":"macula_pubsub_topic.normalize/1","doc":"Normalize topic (lowercase, trim, remove double dots).","ref":"macula_pubsub_topic.html#normalize/1"},{"type":"type","title":"macula_pubsub_topic.pattern/0","doc":"","ref":"macula_pubsub_topic.html#t:pattern/0"},{"type":"function","title":"macula_pubsub_topic.segment_count/1","doc":"Count number of segments in topic.","ref":"macula_pubsub_topic.html#segment_count/1"},{"type":"type","title":"macula_pubsub_topic.topic/0","doc":"","ref":"macula_pubsub_topic.html#t:topic/0"},{"type":"function","title":"macula_pubsub_topic.validate/1","doc":"Validate topic syntax. Valid topics: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen, wildcards - No leading or trailing dots","ref":"macula_pubsub_topic.html#validate/1"},{"type":"module","title":"macula_quic","doc":"Main API module for Macula QUIC transport. Provides a simplified wrapper around the quicer library.","ref":"macula_quic.html"},{"type":"function","title":"macula_quic.accept/2","doc":"Accept an incoming connection on a listener. After accepting, the connection needs handshake to complete.","ref":"macula_quic.html#accept/2"},{"type":"function","title":"macula_quic.accept_stream/2","doc":"Accept an incoming stream on a connection.","ref":"macula_quic.html#accept_stream/2"},{"type":"function","title":"macula_quic.close/1","doc":"Close a listener, connection, or stream.","ref":"macula_quic.html#close/1"},{"type":"function","title":"macula_quic.connect/4","doc":"Connect to a QUIC server. Options: {alpn, [Protocol]} - List of ALPN protocols {verify, none | verify_peer} - Certificate verification mode","ref":"macula_quic.html#connect/4"},{"type":"function","title":"macula_quic.listen/2","doc":"Start a QUIC listener on the specified port. Options: {cert, CertFile} - Path to PEM certificate file {key, KeyFile} - Path to PEM private key file {alpn, [Protocol]} - List of ALPN protocols (e.g., [\"macula\"]) {peer_unidi_stream_count, N} - Max unidirectional streams","ref":"macula_quic.html#listen/2"},{"type":"function","title":"macula_quic.open_stream/1","doc":"Open a new bidirectional stream on a connection.","ref":"macula_quic.html#open_stream/1"},{"type":"function","title":"macula_quic.recv/2","doc":"Receive data from a stream (blocking).","ref":"macula_quic.html#recv/2"},{"type":"function","title":"macula_quic.send/2","doc":"Send data on a stream.","ref":"macula_quic.html#send/2"},{"type":"module","title":"macula_quic_cert","doc":"Macula QUIC certificate utilities. Provides functions for generating and validating self-signed certificates for QUIC connections via OpenSSL command-line tool.","ref":"macula_quic_cert.html"},{"type":"function","title":"macula_quic_cert.generate_self_signed/0","doc":"Generate a self-signed certificate and key in a temporary directory. Returns {ok, CertFile, KeyFile} with paths to generated files. The files are created in /tmp/macula_certs_PID for test isolation.","ref":"macula_quic_cert.html#generate_self_signed/0"},{"type":"function","title":"macula_quic_cert.generate_self_signed/1","doc":"Generate a self-signed certificate and key in the given directory. Returns {ok, {CertFile, KeyFile}} with paths to generated files.","ref":"macula_quic_cert.html#generate_self_signed/1"},{"type":"function","title":"macula_quic_cert.generate_self_signed/2","doc":"Generate a self-signed certificate with custom options. Options: subject - Certificate subject (default: \"/CN=macula.local\") validity_days - Validity period in days (default: 365)","ref":"macula_quic_cert.html#generate_self_signed/2"},{"type":"function","title":"macula_quic_cert.validate_files/2","doc":"Validate that both certificate and key files exist and are readable.","ref":"macula_quic_cert.html#validate_files/2"},{"type":"module","title":"macula_realm","doc":"Realm management and validation. Realms provide logical isolation boundaries in the mesh. Realm names follow reverse DNS notation (e.g., \"org.example.mesh\").","ref":"macula_realm.html"},{"type":"function","title":"macula_realm.equals/2","doc":"Check if two realm names are equal.","ref":"macula_realm.html#equals/2"},{"type":"function","title":"macula_realm.from_binary/1","doc":"Decode realm name from binary.","ref":"macula_realm.html#from_binary/1"},{"type":"function","title":"macula_realm.id/1","doc":"Generate deterministic realm ID from name. Uses SHA-256 hash for 256-bit realm IDs.","ref":"macula_realm.html#id/1"},{"type":"function","title":"macula_realm.namespace/1","doc":"Extract namespace (top-level domain) from realm name. Example: \"org.example.mesh\" -> \"org\"","ref":"macula_realm.html#namespace/1"},{"type":"function","title":"macula_realm.normalize/1","doc":"Normalize realm name (lowercase, trim).","ref":"macula_realm.html#normalize/1"},{"type":"type","title":"macula_realm.realm_id/0","doc":"32-byte SHA-256 hash","ref":"macula_realm.html#t:realm_id/0"},{"type":"type","title":"macula_realm.realm_name/0","doc":"","ref":"macula_realm.html#t:realm_name/0"},{"type":"function","title":"macula_realm.to_binary/1","doc":"Encode realm name to binary.","ref":"macula_realm.html#to_binary/1"},{"type":"function","title":"macula_realm.validate/1","doc":"Validate realm name format. Rules: - Reverse DNS notation (org.example.mesh) - Lowercase alphanumeric, dots, hyphens, underscores - No leading/trailing dots - No consecutive dots","ref":"macula_realm.html#validate/1"},{"type":"module","title":"macula_routing_bucket","doc":"K-bucket for Kademlia routing table. Stores up to k nodes with LRU eviction policy.","ref":"macula_routing_bucket.html"},{"type":"function","title":"macula_routing_bucket.add_node/2","doc":"Add a node to the bucket. If node exists, move to tail (most recent). If bucket full, return {error, bucket_full}.","ref":"macula_routing_bucket.html#add_node/2"},{"type":"type","title":"macula_routing_bucket.bucket/0","doc":"","ref":"macula_routing_bucket.html#t:bucket/0"},{"type":"function","title":"macula_routing_bucket.capacity/1","doc":"Get bucket capacity.","ref":"macula_routing_bucket.html#capacity/1"},{"type":"function","title":"macula_routing_bucket.find_closest/3","doc":"Find n closest nodes to target (sorted by XOR distance).","ref":"macula_routing_bucket.html#find_closest/3"},{"type":"function","title":"macula_routing_bucket.find_node/2","doc":"Find a node by ID.","ref":"macula_routing_bucket.html#find_node/2"},{"type":"function","title":"macula_routing_bucket.get_nodes/1","doc":"Get all nodes in the bucket (ordered: oldest first).","ref":"macula_routing_bucket.html#get_nodes/1"},{"type":"function","title":"macula_routing_bucket.has_node/2","doc":"Check if bucket contains node.","ref":"macula_routing_bucket.html#has_node/2"},{"type":"function","title":"macula_routing_bucket.new/1","doc":"Create a new bucket with capacity k.","ref":"macula_routing_bucket.html#new/1"},{"type":"type","title":"macula_routing_bucket.node_info/0","doc":"","ref":"macula_routing_bucket.html#t:node_info/0"},{"type":"function","title":"macula_routing_bucket.remove_node/2","doc":"Remove a node from the bucket.","ref":"macula_routing_bucket.html#remove_node/2"},{"type":"function","title":"macula_routing_bucket.size/1","doc":"Get number of nodes in bucket.","ref":"macula_routing_bucket.html#size/1"},{"type":"function","title":"macula_routing_bucket.update_timestamp/2","doc":"Update node's last_seen timestamp (moves to tail).","ref":"macula_routing_bucket.html#update_timestamp/2"},{"type":"module","title":"macula_routing_dht","doc":"Core DHT algorithms for Kademlia routing. Implements iterative lookup, store, and find operations. Pure functions - no GenServer, designed to be called by macula_routing_server.","ref":"macula_routing_dht.html"},{"type":"function","title":"macula_routing_dht.find_value/4","doc":"Find value in DHT. Returns {ok, Value} if found, {nodes, [NodeInfo]} if not found.","ref":"macula_routing_dht.html#find_value/4"},{"type":"function","title":"macula_routing_dht.iterative_find_node/4","doc":"Iterative lookup to find k closest nodes to target. Uses alpha concurrent queries (default: 3).","ref":"macula_routing_dht.html#iterative_find_node/4"},{"type":"type","title":"macula_routing_dht.query_fn/0","doc":"","ref":"macula_routing_dht.html#t:query_fn/0"},{"type":"function","title":"macula_routing_dht.select_alpha/3","doc":"Select up to alpha unqueried nodes from closest set.","ref":"macula_routing_dht.html#select_alpha/3"},{"type":"type","title":"macula_routing_dht.store_fn/0","doc":"","ref":"macula_routing_dht.html#t:store_fn/0"},{"type":"function","title":"macula_routing_dht.store_value/6","doc":"Store value at k closest nodes to key.","ref":"macula_routing_dht.html#store_value/6"},{"type":"function","title":"macula_routing_dht.update_closest/4","doc":"Update closest set with new nodes, maintaining k closest and removing duplicates.","ref":"macula_routing_dht.html#update_closest/4"},{"type":"module","title":"macula_routing_nodeid","doc":"Node ID utilities for Kademlia DHT. 256-bit node identifiers with XOR distance metric.","ref":"macula_routing_nodeid.html"},{"type":"function","title":"macula_routing_nodeid.bucket_index/2","doc":"Calculate bucket index for a node relative to local node. Returns leading zero count of XOR distance (0..255). Special case: distance 0 (same node) returns 256.","ref":"macula_routing_nodeid.html#bucket_index/2"},{"type":"function","title":"macula_routing_nodeid.closer_to/3","doc":"Check if NodeA is closer to Target than NodeB.","ref":"macula_routing_nodeid.html#closer_to/3"},{"type":"function","title":"macula_routing_nodeid.compare/3","doc":"Compare distances of NodeA and NodeB to Target. Returns: less (A closer), equal (same distance), greater (B closer).","ref":"macula_routing_nodeid.html#compare/3"},{"type":"function","title":"macula_routing_nodeid.distance/2","doc":"Calculate XOR distance between two node IDs.","ref":"macula_routing_nodeid.html#distance/2"},{"type":"function","title":"macula_routing_nodeid.from_binary/1","doc":"Create node ID from binary (validates size).","ref":"macula_routing_nodeid.html#from_binary/1"},{"type":"function","title":"macula_routing_nodeid.from_hex/1","doc":"Parse node ID from hex string.","ref":"macula_routing_nodeid.html#from_hex/1"},{"type":"function","title":"macula_routing_nodeid.generate/0","doc":"Generate a random 256-bit node ID.","ref":"macula_routing_nodeid.html#generate/0"},{"type":"function","title":"macula_routing_nodeid.leading_zeros/1","doc":"Count leading zero bits in binary.","ref":"macula_routing_nodeid.html#leading_zeros/1"},{"type":"type","title":"macula_routing_nodeid.node_id/0","doc":"32 bytes (256 bits)","ref":"macula_routing_nodeid.html#t:node_id/0"},{"type":"function","title":"macula_routing_nodeid.to_hex/1","doc":"Convert node ID to hex string.","ref":"macula_routing_nodeid.html#to_hex/1"},{"type":"module","title":"macula_routing_protocol","doc":"DHT protocol message encoding/decoding. Maps DHT operations to/from message format.","ref":"macula_routing_protocol.html"},{"type":"function","title":"macula_routing_protocol.decode_find_node/1","doc":"Decode FIND_NODE request.","ref":"macula_routing_protocol.html#decode_find_node/1"},{"type":"function","title":"macula_routing_protocol.decode_find_node_reply/1","doc":"Decode FIND_NODE reply.","ref":"macula_routing_protocol.html#decode_find_node_reply/1"},{"type":"function","title":"macula_routing_protocol.decode_find_value/1","doc":"Decode FIND_VALUE request.","ref":"macula_routing_protocol.html#decode_find_value/1"},{"type":"function","title":"macula_routing_protocol.decode_find_value_reply/1","doc":"Decode FIND_VALUE reply.","ref":"macula_routing_protocol.html#decode_find_value_reply/1"},{"type":"function","title":"macula_routing_protocol.decode_node_info/1","doc":"Decode node info.","ref":"macula_routing_protocol.html#decode_node_info/1"},{"type":"function","title":"macula_routing_protocol.decode_store/1","doc":"Decode STORE request.","ref":"macula_routing_protocol.html#decode_store/1"},{"type":"function","title":"macula_routing_protocol.encode_find_node/1","doc":"Encode FIND_NODE request.","ref":"macula_routing_protocol.html#encode_find_node/1"},{"type":"function","title":"macula_routing_protocol.encode_find_node_reply/1","doc":"Encode FIND_NODE reply.","ref":"macula_routing_protocol.html#encode_find_node_reply/1"},{"type":"function","title":"macula_routing_protocol.encode_find_value/1","doc":"Encode FIND_VALUE request.","ref":"macula_routing_protocol.html#encode_find_value/1"},{"type":"function","title":"macula_routing_protocol.encode_find_value_reply/1","doc":"Encode FIND_VALUE reply.","ref":"macula_routing_protocol.html#encode_find_value_reply/1"},{"type":"function","title":"macula_routing_protocol.encode_node_info/1","doc":"Encode node info (for transmission).","ref":"macula_routing_protocol.html#encode_node_info/1"},{"type":"function","title":"macula_routing_protocol.encode_store/2","doc":"Encode STORE request.","ref":"macula_routing_protocol.html#encode_store/2"},{"type":"function","title":"macula_routing_protocol.is_find_node/1","doc":"Check if message is FIND_NODE.","ref":"macula_routing_protocol.html#is_find_node/1"},{"type":"function","title":"macula_routing_protocol.is_find_value/1","doc":"Check if message is FIND_VALUE.","ref":"macula_routing_protocol.html#is_find_value/1"},{"type":"function","title":"macula_routing_protocol.is_store/1","doc":"Check if message is STORE.","ref":"macula_routing_protocol.html#is_store/1"},{"type":"type","title":"macula_routing_protocol.message/0","doc":"","ref":"macula_routing_protocol.html#t:message/0"},{"type":"module","title":"macula_routing_server","doc":"GenServer managing Kademlia DHT routing table and operations. Integrates all routing components: table, DHT algorithms, protocol.","ref":"macula_routing_server.html"},{"type":"function","title":"macula_routing_server.add_node/2","doc":"Add node to routing table.","ref":"macula_routing_server.html#add_node/2"},{"type":"function","title":"macula_routing_server.find_closest/3","doc":"Find k closest nodes to target.","ref":"macula_routing_server.html#find_closest/3"},{"type":"function","title":"macula_routing_server.get_local/2","doc":"Get value from local storage.","ref":"macula_routing_server.html#get_local/2"},{"type":"function","title":"macula_routing_server.get_routing_table/1","doc":"Get routing table snapshot.","ref":"macula_routing_server.html#get_routing_table/1"},{"type":"function","title":"macula_routing_server.handle_message/2","doc":"Handle incoming DHT message and return reply.","ref":"macula_routing_server.html#handle_message/2"},{"type":"function","title":"macula_routing_server.size/1","doc":"Get number of nodes in routing table.","ref":"macula_routing_server.html#size/1"},{"type":"function","title":"macula_routing_server.start_link/2","doc":"Start routing server.","ref":"macula_routing_server.html#start_link/2"},{"type":"function","title":"macula_routing_server.store_local/3","doc":"Store value locally.","ref":"macula_routing_server.html#store_local/3"},{"type":"module","title":"macula_routing_table","doc":"Routing table for Kademlia DHT. Manages 256 k-buckets organized by XOR distance.","ref":"macula_routing_table.html"},{"type":"function","title":"macula_routing_table.add_node/2","doc":"Add a node to the routing table. Calculates bucket index and adds to appropriate bucket.","ref":"macula_routing_table.html#add_node/2"},{"type":"function","title":"macula_routing_table.bucket_size/2","doc":"Get size of a specific bucket.","ref":"macula_routing_table.html#bucket_size/2"},{"type":"function","title":"macula_routing_table.find_closest/3","doc":"Find k closest nodes to target.","ref":"macula_routing_table.html#find_closest/3"},{"type":"function","title":"macula_routing_table.get_all_nodes/1","doc":"Get all nodes from all buckets.","ref":"macula_routing_table.html#get_all_nodes/1"},{"type":"function","title":"macula_routing_table.get_bucket/2","doc":"Get bucket by index.","ref":"macula_routing_table.html#get_bucket/2"},{"type":"function","title":"macula_routing_table.k/1","doc":"Get k (bucket capacity).","ref":"macula_routing_table.html#k/1"},{"type":"function","title":"macula_routing_table.local_node_id/1","doc":"Get local node ID.","ref":"macula_routing_table.html#local_node_id/1"},{"type":"function","title":"macula_routing_table.new/2","doc":"Create a new routing table.","ref":"macula_routing_table.html#new/2"},{"type":"function","title":"macula_routing_table.remove_node/2","doc":"Remove a node from the routing table.","ref":"macula_routing_table.html#remove_node/2"},{"type":"type","title":"macula_routing_table.routing_table/0","doc":"","ref":"macula_routing_table.html#t:routing_table/0"},{"type":"function","title":"macula_routing_table.size/1","doc":"Get total number of nodes in routing table.","ref":"macula_routing_table.html#size/1"},{"type":"function","title":"macula_routing_table.update_timestamp/2","doc":"Update timestamp for a node (moves to tail in its bucket).","ref":"macula_routing_table.html#update_timestamp/2"},{"type":"module","title":"macula_rpc_cache","doc":"LRU cache for RPC procedure results. Caches results of idempotent procedures to avoid repeated execution. Wraps macula_cache with RPC-specific logic and TTL handling.","ref":"macula_rpc_cache.html"},{"type":"type","title":"macula_rpc_cache.cache/0","doc":"","ref":"macula_rpc_cache.html#t:cache/0"},{"type":"function","title":"macula_rpc_cache.clear/1","doc":"Clear all entries.","ref":"macula_rpc_cache.html#clear/1"},{"type":"function","title":"macula_rpc_cache.get/3","doc":"Get entry from cache. Returns {ok, Result, UpdatedCache} or not_found. The updated cache has the entry moved to front (LRU). Automatically removes expired entries.","ref":"macula_rpc_cache.html#get/3"},{"type":"function","title":"macula_rpc_cache.invalidate/3","doc":"Invalidate (remove) entry.","ref":"macula_rpc_cache.html#invalidate/3"},{"type":"function","title":"macula_rpc_cache.is_expired/3","doc":"Check if entry is expired.","ref":"macula_rpc_cache.html#is_expired/3"},{"type":"function","title":"macula_rpc_cache.make_key/2","doc":"Make cache key from URI and args. Uses hash of URI and args for consistent key generation.","ref":"macula_rpc_cache.html#make_key/2"},{"type":"function","title":"macula_rpc_cache.max_size/1","doc":"Get max size.","ref":"macula_rpc_cache.html#max_size/1"},{"type":"function","title":"macula_rpc_cache.new/1","doc":"Create new cache with max size.","ref":"macula_rpc_cache.html#new/1"},{"type":"function","title":"macula_rpc_cache.put/5","doc":"Put entry in cache.","ref":"macula_rpc_cache.html#put/5"},{"type":"function","title":"macula_rpc_cache.put_with_timestamp/6","doc":"Put entry with custom timestamp (for testing).","ref":"macula_rpc_cache.html#put_with_timestamp/6"},{"type":"function","title":"macula_rpc_cache.size/1","doc":"Get number of entries.","ref":"macula_rpc_cache.html#size/1"},{"type":"module","title":"macula_rpc_discovery","doc":"DHT integration for finding RPC service providers. Uses Kademlia DHT to publish and discover RPC registrations. Wraps macula_discovery with RPC-specific types.","ref":"macula_rpc_discovery.html"},{"type":"type","title":"macula_rpc_discovery.address/0","doc":"","ref":"macula_rpc_discovery.html#t:address/0"},{"type":"function","title":"macula_rpc_discovery.announce/5","doc":"Announce local registration to DHT.","ref":"macula_rpc_discovery.html#announce/5"},{"type":"type","title":"macula_rpc_discovery.dht_lookup_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_lookup_fun/0"},{"type":"type","title":"macula_rpc_discovery.dht_publish_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_publish_fun/0"},{"type":"type","title":"macula_rpc_discovery.dht_unpublish_fun/0","doc":"","ref":"macula_rpc_discovery.html#t:dht_unpublish_fun/0"},{"type":"function","title":"macula_rpc_discovery.filter_available/2","doc":"Filter providers to only available ones (based on last_seen TTL).","ref":"macula_rpc_discovery.html#filter_available/2"},{"type":"function","title":"macula_rpc_discovery.find_providers/2","doc":"Find service providers for a URI via DHT.","ref":"macula_rpc_discovery.html#find_providers/2"},{"type":"function","title":"macula_rpc_discovery.find_with_cache/3","doc":"Find providers with cache (default TTL: 300 seconds).","ref":"macula_rpc_discovery.html#find_with_cache/3"},{"type":"function","title":"macula_rpc_discovery.find_with_cache/4","doc":"Find providers with cache and custom TTL.","ref":"macula_rpc_discovery.html#find_with_cache/4"},{"type":"type","title":"macula_rpc_discovery.node_id/0","doc":"","ref":"macula_rpc_discovery.html#t:node_id/0"},{"type":"type","title":"macula_rpc_discovery.provider_info/0","doc":"","ref":"macula_rpc_discovery.html#t:provider_info/0"},{"type":"function","title":"macula_rpc_discovery.unannounce/3","doc":"Remove local registration from DHT.","ref":"macula_rpc_discovery.html#unannounce/3"},{"type":"type","title":"macula_rpc_discovery.uri/0","doc":"","ref":"macula_rpc_discovery.html#t:uri/0"},{"type":"module","title":"macula_rpc_executor","doc":"RPC call execution with timeout handling. Executes local handlers and remote calls via QUIC.","ref":"macula_rpc_executor.html"},{"type":"type","title":"macula_rpc_executor.address/0","doc":"","ref":"macula_rpc_executor.html#t:address/0"},{"type":"function","title":"macula_rpc_executor.execute_local/3","doc":"Execute local handler with timeout.","ref":"macula_rpc_executor.html#execute_local/3"},{"type":"function","title":"macula_rpc_executor.execute_remote/5","doc":"Execute remote call via QUIC with timeout.","ref":"macula_rpc_executor.html#execute_remote/5"},{"type":"function","title":"macula_rpc_executor.generate_call_id/0","doc":"Generate unique call ID (16-byte UUID).","ref":"macula_rpc_executor.html#generate_call_id/0"},{"type":"type","title":"macula_rpc_executor.handler_fn/0","doc":"","ref":"macula_rpc_executor.html#t:handler_fn/0"},{"type":"type","title":"macula_rpc_executor.provider_info/0","doc":"","ref":"macula_rpc_executor.html#t:provider_info/0"},{"type":"type","title":"macula_rpc_executor.send_fun/0","doc":"","ref":"macula_rpc_executor.html#t:send_fun/0"},{"type":"module","title":"macula_rpc_names","doc":"Name validation and utilities for RPC procedures. Uses reverse DNS notation: org.domain.service.procedure","ref":"macula_rpc_names.html"},{"type":"function","title":"macula_rpc_names.matches/2","doc":"Check if name matches pattern. For now, only exact matching (no wildcards). Future: Could add wildcard patterns if needed.","ref":"macula_rpc_names.html#matches/2"},{"type":"type","title":"macula_rpc_names.name/0","doc":"","ref":"macula_rpc_names.html#t:name/0"},{"type":"function","title":"macula_rpc_names.namespace/1","doc":"Extract namespace (first segment).","ref":"macula_rpc_names.html#namespace/1"},{"type":"function","title":"macula_rpc_names.normalize/1","doc":"Normalize name (lowercase, trim, remove double dots).","ref":"macula_rpc_names.html#normalize/1"},{"type":"function","title":"macula_rpc_names.segment_count/1","doc":"Count number of segments in name.","ref":"macula_rpc_names.html#segment_count/1"},{"type":"function","title":"macula_rpc_names.validate/1","doc":"Validate RPC procedure name syntax. Valid names: - Non-empty - Segments separated by dots - Segments contain alphanumeric, underscore, hyphen - No leading or trailing dots - No double dots - No wildcards allowed (unlike topics)","ref":"macula_rpc_names.html#validate/1"},{"type":"module","title":"macula_rpc_registry","doc":"Local RPC procedure registration registry. Maps URIs to handler functions. Supports multiple handlers per URI (for load balancing).","ref":"macula_rpc_registry.html"},{"type":"function","title":"macula_rpc_registry.find/2","doc":"Find all registrations for a URI.","ref":"macula_rpc_registry.html#find/2"},{"type":"function","title":"macula_rpc_registry.find_handlers/2","doc":"Find all handlers for a URI.","ref":"macula_rpc_registry.html#find_handlers/2"},{"type":"type","title":"macula_rpc_registry.handler_fn/0","doc":"","ref":"macula_rpc_registry.html#t:handler_fn/0"},{"type":"type","title":"macula_rpc_registry.invocation_strategy/0","doc":"","ref":"macula_rpc_registry.html#t:invocation_strategy/0"},{"type":"function","title":"macula_rpc_registry.list_registrations/1","doc":"List all registrations.","ref":"macula_rpc_registry.html#list_registrations/1"},{"type":"function","title":"macula_rpc_registry.list_uris/1","doc":"List all unique URIs in registry.","ref":"macula_rpc_registry.html#list_uris/1"},{"type":"function","title":"macula_rpc_registry.new/0","doc":"Create new empty registry with default strategy (round_robin).","ref":"macula_rpc_registry.html#new/0"},{"type":"function","title":"macula_rpc_registry.new/1","doc":"Create new empty registry with custom strategy.","ref":"macula_rpc_registry.html#new/1"},{"type":"function","title":"macula_rpc_registry.register/4","doc":"Register a procedure handler. Allows multiple handlers for the same URI (for load balancing).","ref":"macula_rpc_registry.html#register/4"},{"type":"type","title":"macula_rpc_registry.registration/0","doc":"","ref":"macula_rpc_registry.html#t:registration/0"},{"type":"type","title":"macula_rpc_registry.registry/0","doc":"","ref":"macula_rpc_registry.html#t:registry/0"},{"type":"function","title":"macula_rpc_registry.size/1","doc":"Get total number of registrations.","ref":"macula_rpc_registry.html#size/1"},{"type":"function","title":"macula_rpc_registry.unregister/3","doc":"Unregister a specific procedure handler. Only removes the exact handler function.","ref":"macula_rpc_registry.html#unregister/3"},{"type":"module","title":"macula_rpc_router","doc":"RPC call routing strategies. Selects which provider to use for a call (local or remote).","ref":"macula_rpc_router.html"},{"type":"function","title":"macula_rpc_router.new_state/1","doc":"Create new router state.","ref":"macula_rpc_router.html#new_state/1"},{"type":"type","title":"macula_rpc_router.provider_info/0","doc":"","ref":"macula_rpc_router.html#t:provider_info/0"},{"type":"type","title":"macula_rpc_router.registration/0","doc":"","ref":"macula_rpc_router.html#t:registration/0"},{"type":"type","title":"macula_rpc_router.router_state/0","doc":"","ref":"macula_rpc_router.html#t:router_state/0"},{"type":"function","title":"macula_rpc_router.select_local/1","doc":"Select local handler (returns first one).","ref":"macula_rpc_router.html#select_local/1"},{"type":"function","title":"macula_rpc_router.select_provider/3","doc":"Select provider using stateless strategy. For local_first, random, and closest strategies.","ref":"macula_rpc_router.html#select_provider/3"},{"type":"function","title":"macula_rpc_router.select_provider_closest/3","doc":"Select provider using closest strategy (requires local node ID).","ref":"macula_rpc_router.html#select_provider_closest/3"},{"type":"function","title":"macula_rpc_router.select_provider_stateful/3","doc":"Select provider using stateful strategy (for round_robin).","ref":"macula_rpc_router.html#select_provider_stateful/3"},{"type":"function","title":"macula_rpc_router.select_remote_random/1","doc":"Select random remote provider.","ref":"macula_rpc_router.html#select_remote_random/1"},{"type":"type","title":"macula_rpc_router.strategy/0","doc":"","ref":"macula_rpc_router.html#t:strategy/0"},{"type":"module","title":"macula_rpc_server","doc":"RPC server managing registrations and calls. GenServer that integrates registry, cache, discovery, router, and executor.","ref":"macula_rpc_server.html"},{"type":"function","title":"macula_rpc_server.call/4","doc":"Synchronous call to procedure.","ref":"macula_rpc_server.html#call/4"},{"type":"type","title":"macula_rpc_server.config/0","doc":"","ref":"macula_rpc_server.html#t:config/0"},{"type":"function","title":"macula_rpc_server.handle_call/3","doc":"Handle synchronous calls.","ref":"macula_rpc_server.html#handle_call/3"},{"type":"function","title":"macula_rpc_server.handle_cast/2","doc":"Handle asynchronous casts (none implemented).","ref":"macula_rpc_server.html#handle_cast/2"},{"type":"function","title":"macula_rpc_server.handle_info/2","doc":"Handle info messages (none expected).","ref":"macula_rpc_server.html#handle_info/2"},{"type":"function","title":"macula_rpc_server.init/1","doc":"Initialize server state.","ref":"macula_rpc_server.html#init/1"},{"type":"function","title":"macula_rpc_server.list_registrations/1","doc":"List local registrations.","ref":"macula_rpc_server.html#list_registrations/1"},{"type":"function","title":"macula_rpc_server.register/4","doc":"Register procedure.","ref":"macula_rpc_server.html#register/4"},{"type":"function","title":"macula_rpc_server.start_link/2","doc":"Start RPC server.","ref":"macula_rpc_server.html#start_link/2"},{"type":"type","title":"macula_rpc_server.state/0","doc":"","ref":"macula_rpc_server.html#t:state/0"},{"type":"function","title":"macula_rpc_server.stop/1","doc":"Stop RPC server.","ref":"macula_rpc_server.html#stop/1"},{"type":"function","title":"macula_rpc_server.terminate/2","doc":"Cleanup on termination.","ref":"macula_rpc_server.html#terminate/2"},{"type":"function","title":"macula_rpc_server.unregister/3","doc":"Unregister procedure.","ref":"macula_rpc_server.html#unregister/3"},{"type":"module","title":"macula_sup","doc":"macula top level supervisor.","ref":"macula_sup.html"},{"type":"function","title":"macula_sup.init/1","doc":"","ref":"macula_sup.html#init/1"},{"type":"function","title":"macula_sup.start_link/0","doc":"","ref":"macula_sup.html#start_link/0"},{"type":"module","title":"macula_time","doc":"Time utilities for Macula. Provides functions for timestamps, durations, and timeouts.","ref":"macula_time.html"},{"type":"function","title":"macula_time.duration_ms/2","doc":"Calculate duration in milliseconds between two timestamps.","ref":"macula_time.html#duration_ms/2"},{"type":"function","title":"macula_time.format_duration_ms/1","doc":"Format duration in milliseconds to human-readable string.","ref":"macula_time.html#format_duration_ms/1"},{"type":"function","title":"macula_time.format_timestamp/1","doc":"Format timestamp to ISO 8601 string.","ref":"macula_time.html#format_timestamp/1"},{"type":"function","title":"macula_time.is_expired/2","doc":"Check if timeout has expired.","ref":"macula_time.html#is_expired/2"},{"type":"function","title":"macula_time.minutes_to_ms/1","doc":"Convert minutes to milliseconds.","ref":"macula_time.html#minutes_to_ms/1"},{"type":"function","title":"macula_time.ms_to_seconds/1","doc":"Convert milliseconds to seconds (truncates).","ref":"macula_time.html#ms_to_seconds/1"},{"type":"function","title":"macula_time.seconds_to_ms/1","doc":"Convert seconds to milliseconds.","ref":"macula_time.html#seconds_to_ms/1"},{"type":"function","title":"macula_time.time_remaining/2","doc":"Calculate remaining time before timeout (in milliseconds). Returns 0 if already expired.","ref":"macula_time.html#time_remaining/2"},{"type":"function","title":"macula_time.timestamp/0","doc":"Get current timestamp in milliseconds since epoch.","ref":"macula_time.html#timestamp/0"},{"type":"function","title":"macula_time.timestamp_microseconds/0","doc":"Get current timestamp in microseconds since epoch.","ref":"macula_time.html#timestamp_microseconds/0"},{"type":"module","title":"macula_uri","doc":"Macula URI parsing and construction. Format: macula://realm/node_id Example: macula://org.example.mesh/0123456789abcdef...","ref":"macula_uri.html"},{"type":"function","title":"macula_uri.equals/2","doc":"Check if two URIs are equal.","ref":"macula_uri.html#equals/2"},{"type":"function","title":"macula_uri.get_node_id/1","doc":"Extract node ID from URI.","ref":"macula_uri.html#get_node_id/1"},{"type":"function","title":"macula_uri.get_realm/1","doc":"Extract realm from URI.","ref":"macula_uri.html#get_realm/1"},{"type":"function","title":"macula_uri.is_valid/1","doc":"Check if URI is valid.","ref":"macula_uri.html#is_valid/1"},{"type":"function","title":"macula_uri.new/2","doc":"Construct Macula URI from realm and node ID.","ref":"macula_uri.html#new/2"},{"type":"type","title":"macula_uri.node_id/0","doc":"","ref":"macula_uri.html#t:node_id/0"},{"type":"function","title":"macula_uri.parse/1","doc":"Parse Macula URI to extract realm and node ID.","ref":"macula_uri.html#parse/1"},{"type":"type","title":"macula_uri.realm/0","doc":"","ref":"macula_uri.html#t:realm/0"},{"type":"type","title":"macula_uri.uri/0","doc":"","ref":"macula_uri.html#t:uri/0"},{"type":"extras","title":"Overview","doc":"# Macula HTTP/3 Mesh\n\n**A distributed mesh networking platform for the BEAM, built on HTTP/3/QUIC**\n\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](LICENSE)\n[![Erlang/OTP](https://img.shields.io/badge/Erlang%2FOTP-26+-brightgreen)](https://www.erlang.org)\n\n---","ref":"readme.html"},{"type":"extras","title":"Vision - Overview","doc":"Macula is a unique, standards-based distributed networking layer for Erlang/Elixir applications that:\n- Uses **HTTP/3 (QUIC)** for NAT-friendly, firewall-friendly transport\n- Forms **self-organizing mesh topologies** at the edge\n- Provides **pub/sub and RPC primitives**\n- Scales to **thousands of nodes**\n- Supports **multi-tenancy and realm isolation**\n- Delivers the **\"Wow! How do they do it?\"** factor\n\n---","ref":"readme.html#vision"},{"type":"extras","title":"Quick Start - Overview","doc":"```bash\n# Clone the repository\ngit clone https://github.com/macula-io/macula.git\ncd macula\n\n# Fetch dependencies\nrebar3 get-deps\n\n# Compile\nrebar3 compile\n\n# Run tests\nrebar3 eunit\n\n# Start a shell with Macula loaded\nrebar3 shell\n```\n\nSee [Quick Start Guide](quick-start) for detailed instructions.\n\n---","ref":"readme.html#quick-start"},{"type":"extras","title":"Architecture - Overview","doc":"Macula is organized as an Erlang umbrella application with 12 core libraries.\n\nSee [Project Structure](project-structure) for complete details.\n\n---","ref":"readme.html#architecture"},{"type":"extras","title":"Documentation - Overview","doc":" **Start Here**: [Documentation Root](architecture)","ref":"readme.html#documentation"},{"type":"extras","title":"Essential Reading - Overview","doc":"- [Quick Start Guide](quick-start) - Get running in 15 minutes\n- [Hello World Tutorial](hello-world) - Build a distributed chat app\n- [Technical Roadmap](roadmap) - 20-week implementation plan\n\nSee [Documentation Status](documentation-status) for full inventory.\n\n---","ref":"readme.html#essential-reading"},{"type":"extras","title":"Development Status - Overview","doc":"**Current Phase**: Foundation (Weeks 1-4)\n\n**Completion**:\n-  Architecture design complete\n-  Project structure initialized (12 core libraries)\n-  Documentation comprehensive (34% complete, 6/21 docs)\n-  Build system configured (rebar3 + QUIC + mDNS)\n-  All dependencies compiling successfully\n-  Core libraries implementation in progress\n\n**Dependencies**:\n- QUIC transport: quicer (wraps Microsoft MsQuic)\n- mDNS discovery: shortishly/mdns (via _checkouts, see MDNS_SETUP.md)\n- Process registry: gproc\n- Environment config: shortishly/envy (via _checkouts)\n\n---","ref":"readme.html#development-status"},{"type":"extras","title":"Contributing - Overview","doc":"We welcome contributions! See [Contributing Guide](contributing).\n\n---","ref":"readme.html#contributing"},{"type":"extras","title":"License - Overview","doc":"Macula is licensed under the Apache License 2.0. See [LICENSE](LICENSE) for details.\n\n---\n\n**Built with  by the Macula team**","ref":"readme.html#license"},{"type":"extras","title":"License","doc":"MIT License\n\nCopyright (c) 2025 macula.io\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","ref":"license.html"},{"type":"extras","title":"Project Structure","doc":"# Macula HTTP/3 Mesh - Project Structure and Libraries\n\n**Actual Erlang/Elixir projects and libraries to build**\n\n**Created**: 2025-01-08\n**Status**: Planning Document\n\n---","ref":"macula_project_structure.html"},{"type":"extras","title":"Overview - Project Structure","doc":"This document outlines the actual Erlang/Elixir libraries, applications, and projects that need to be created to implement the Macula HTTP/3 Mesh platform.\n\n---","ref":"macula_project_structure.html#overview"},{"type":"extras","title":"Repository Organization Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#repository-organization-strategy"},{"type":"extras","title":"Option A: Monorepo (Recommended for Initial Development) - Project Structure","doc":"```\nmacula/\n apps/\n    macula_core/           # Core protocols and types\n    macula_quic/           # QUIC transport layer\n    macula_protocol/       # Wire protocol (framing, encoding)\n    macula_membership/     # SWIM membership\n    macula_routing/        # Kademlia DHT routing\n    macula_topology/       # Mesh topology management\n    macula_pubsub/         # Pub/sub implementation\n    macula_rpc/            # RPC implementation\n    macula_gateway/        # Cross-realm gateway\n    macula_discovery/      # Node discovery\n    macula_security/       # Auth, ACLs, certificates\n    macula/                # Main application (umbrella)\n rebar.config               # Rebar3 umbrella config\n mix.exs                    # Mix umbrella config (if supporting Elixir)\n README.md\n```\n\n**Benefits**:\n- Easy cross-library development\n- Shared dependencies\n- Single release\n- Atomic commits across components\n- Simplified CI/CD","ref":"macula_project_structure.html#option-a-monorepo-recommended-for-initial-development"},{"type":"extras","title":"Option B: Multi-repo (For Maturity/Modularity) - Project Structure","doc":"Separate repositories for each library (similar to Erlang/OTP structure).\n\n**Benefits**:\n- Independent versioning\n- Smaller, focused repos\n- Can use different libraries independently\n- Clear boundaries\n\n**Recommendation**: Start with **Option A (monorepo)**, split later if needed.\n\n---","ref":"macula_project_structure.html#option-b-multi-repo-for-maturity-modularity"},{"type":"extras","title":"Core Libraries (Required for MVP) - Project Structure","doc":"","ref":"macula_project_structure.html#core-libraries-required-for-mvp"},{"type":"extras","title":"1. macula_core - Project Structure","doc":"**Purpose**: Core types, protocols, and shared utilities.\n\n**Modules**:\n```erlang\n%% Core types\nmacula_types.erl           - Common type definitions\nmacula_node.erl            - Node identity and metadata\nmacula_realm.erl           - Realm management\nmacula_topic.erl           - Topic parsing and validation\n\n%% Utilities\nmacula_time.erl            - Time utilities\nmacula_id.erl              - ID generation (SHA-256 node IDs)\nmacula_uri.erl             - Macula URI parsing (macula://realm/node)\n```\n\n**Dependencies**: None (pure Erlang)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_core, [\n    {description, \"Macula core types and protocols\"},\n    {vsn, \"0.1.0\"},\n    {modules, []},\n    {registered, []},\n    {applications, [kernel, stdlib]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#1-macula_core"},{"type":"extras","title":"2. macula_quic - Project Structure","doc":"**Purpose**: QUIC transport layer (wrapper around quicer).\n\n**Modules**:\n```erlang\nmacula_quic_listener.erl   - QUIC listener (accept connections)\nmacula_quic_client.erl     - QUIC client (initiate connections)\nmacula_quic_connection.erl - GenServer per QUIC connection\nmacula_quic_stream.erl     - Stream management\nmacula_quic_config.erl     - QUIC configuration (TLS, ALPN, etc.)\n```\n\n**Dependencies**:\n- `quicer` (NIF for MsQuic)\n\n**Key Features**:\n- Connection pooling\n- Stream multiplexing\n- 0-RTT support\n- Connection migration\n- Backpressure handling\n\n**Rebar3 Config**:\n```erlang\n{application, macula_quic, [\n    {description, \"Macula QUIC transport layer\"},\n    {vsn, \"0.1.0\"},\n    {modules, []},\n    {registered, []},\n    {applications, [kernel, stdlib, macula_core, quicer]},\n    {mod, {macula_quic_app, []}}\n]}.\n\n{deps, [\n    {quicer, {git, \"https://github.com/emqx/quic.git\", {branch, \"main\"}}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#2-macula_quic"},{"type":"extras","title":"3. macula_protocol - Project Structure","doc":"**Purpose**: Wire protocol (message framing, encoding/decoding).\n\n**Modules**:\n```erlang\nmacula_protocol.erl        - Main protocol API\nmacula_frame.erl           - Frame encoding/decoding\nmacula_message.erl         - Message types and validation\nmacula_codec.erl           - Binary serialization (Erlang term format or MessagePack)\n```\n\n**Message Types**:\n```erlang\n-define(MSG_HANDSHAKE, 16#01).\n-define(MSG_HANDSHAKE_ACK, 16#02).\n-define(MSG_HEARTBEAT, 16#03).\n-define(MSG_PING, 16#04).\n-define(MSG_PONG, 16#05).\n-define(MSG_PUBLISH, 16#10).\n-define(MSG_SUBSCRIBE, 16#11).\n-define(MSG_UNSUBSCRIBE, 16#12).\n-define(MSG_EVENT, 16#13).\n-define(MSG_RPC_CALL, 16#20).\n-define(MSG_RPC_RESULT, 16#21).\n-define(MSG_RPC_ERROR, 16#22).\n-define(MSG_ERROR, 16#F0).\n-define(MSG_CLOSE, 16#FF).\n```\n\n**Dependencies**:\n- `macula_core`\n\n**Optional Dependencies**:\n- `msgpack` (if using MessagePack instead of Erlang term format)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_protocol, [\n    {description, \"Macula wire protocol\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#3-macula_protocol"},{"type":"extras","title":"4. macula_membership - Project Structure","doc":"**Purpose**: SWIM-based membership and failure detection.\n\n**Modules**:\n```erlang\nmacula_membership.erl      - Main membership API\nmacula_swim.erl            - SWIM protocol GenServer\nmacula_swim_detector.erl   - Failure detector\nmacula_swim_gossip.erl     - Gossip dissemination\nmacula_member.erl          - Member record and state\n```\n\n**Features**:\n- Membership list management\n- Direct ping / indirect ping\n- Suspicion mechanism\n- Incarnation numbers\n- Realm-scoped membership\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_quic`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_membership, [\n    {description, \"Macula SWIM membership\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol, macula_quic]},\n    {mod, {macula_membership_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#4-macula_membership"},{"type":"extras","title":"5. macula_routing - Project Structure","doc":"**Purpose**: Kademlia DHT for routing.\n\n**Modules**:\n```erlang\nmacula_routing.erl         - Routing API\nmacula_kademlia.erl        - Kademlia DHT GenServer\nmacula_k_bucket.erl        - K-bucket management\nmacula_node_lookup.erl     - Node lookup (iterative)\nmacula_topic_registry.erl  - Topic  Nodes mapping (for pub/sub)\nmacula_rpc_registry.erl    - RPC name  Node mapping\n```\n\n**Features**:\n- 256 k-buckets (for 256-bit node IDs)\n- XOR distance metric\n- Iterative lookups\n- Bucket refresh\n- Realm partitioning\n\n**Dependencies**:\n- `macula_core`\n- `macula_membership`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_routing, [\n    {description, \"Macula Kademlia DHT routing\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_membership]},\n    {mod, {macula_routing_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#5-macula_routing"},{"type":"extras","title":"6. macula_topology - Project Structure","doc":"**Purpose**: Mesh topology management (k-regular graph).\n\n**Modules**:\n```erlang\nmacula_topology.erl        - Topology management\nmacula_k_regular.erl       - k-regular graph algorithm\nmacula_connection_pool.erl - Connection pool supervisor\nmacula_connection.erl      - GenServer per peer connection\n```\n\n**Features**:\n- k-regular graph topology\n- Connection lifecycle (connect, disconnect, reconnect)\n- Exponential backoff for reconnections\n- Topology visualization\n\n**Dependencies**:\n- `macula_core`\n- `macula_quic`\n- `macula_membership`\n- `macula_routing`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_topology, [\n    {description, \"Macula mesh topology management\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_quic,\n                    macula_membership, macula_routing]},\n    {mod, {macula_topology_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#6-macula_topology"},{"type":"extras","title":"7. macula_pubsub - Project Structure","doc":"**Purpose**: Publish/subscribe messaging.\n\n**Modules**:\n```erlang\nmacula_pubsub.erl          - Pub/sub API\nmacula_topic_tree.erl      - Topic subscription tree (pattern matching)\nmacula_subscription.erl    - Subscription management\nmacula_publisher.erl       - Publishing logic\nmacula_event_router.erl    - Event routing to subscribers\n```\n\n**Features**:\n- Topic pattern matching (exact, prefix, wildcard)\n- Local and remote subscriptions\n- Subscription announcements (via DHT)\n- Event delivery guarantees (at-most-once, at-least-once)\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_routing`\n- `macula_topology`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_pubsub, [\n    {description, \"Macula pub/sub messaging\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_routing, macula_topology]},\n    {mod, {macula_pubsub_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#7-macula_pubsub"},{"type":"extras","title":"8. macula_rpc - Project Structure","doc":"**Purpose**: Remote procedure call (RPC) implementation.\n\n**Modules**:\n```erlang\nmacula_rpc.erl             - RPC API (call, register, unregister)\nmacula_rpc_server.erl      - RPC request handler\nmacula_rpc_client.erl      - RPC call client\nmacula_rpc_registry.erl    - Local RPC endpoint registry\n```\n\n**Features**:\n- Synchronous RPC (with timeout)\n- Asynchronous RPC (cast)\n- RPC endpoint registration (name  handler function)\n- Endpoint discovery via DHT\n- Load balancing (if multiple nodes register same RPC)\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_routing`\n- `macula_topology`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_rpc, [\n    {description, \"Macula RPC\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_routing, macula_topology]},\n    {mod, {macula_rpc_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#8-macula_rpc"},{"type":"extras","title":"9. macula_discovery - Project Structure","doc":"**Purpose**: Node discovery (DNS-SD, mDNS, static, cloud).\n\n**Modules**:\n```erlang\nmacula_discovery.erl       - Discovery coordinator\nmacula_discovery_static.erl - Static bootstrap nodes\nmacula_discovery_mdns.erl  - mDNS (Multicast DNS)\nmacula_discovery_dns.erl   - DNS SRV records\nmacula_discovery_consul.erl - Consul service discovery\nmacula_discovery_k8s.erl   - Kubernetes endpoints\n```\n\n**Features**:\n- Multiple discovery methods (configurable)\n- Continuous discovery (periodic re-discovery)\n- Bootstrap node list\n- Realm-aware discovery\n\n**Dependencies**:\n- `macula_core`\n- `mdns` (for mDNS support)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_discovery, [\n    {description, \"Macula node discovery\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core]},\n    {mod, {macula_discovery_app, []}}\n]}.\n\n{deps, [\n    {mdns, {git, \"https://github.com/benoitc/erlang-mdns.git\", {branch, \"master\"}}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#9-macula_discovery"},{"type":"extras","title":"10. macula_security - Project Structure","doc":"**Purpose**: Security (TLS certificates, ACLs, audit logging).\n\n**Modules**:\n```erlang\nmacula_security.erl        - Security API\nmacula_cert.erl            - Certificate generation and validation\nmacula_acl.erl             - Access control lists\nmacula_audit.erl           - Audit logging\nmacula_crypto.erl          - Message signing/verification\n```\n\n**Features**:\n- Certificate generation (self-signed, CA-signed)\n- Certificate validation (realm extraction from SAN)\n- ACL enforcement (topic/RPC access control)\n- Audit log (security events)\n- Optional message signing\n\n**Dependencies**:\n- `macula_core`\n- `public_key` (Erlang stdlib)\n- `ssl` (Erlang stdlib)\n\n**Rebar3 Config**:\n```erlang\n{application, macula_security, [\n    {description, \"Macula security\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, public_key, ssl, macula_core]},\n    {mod, {macula_security_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#10-macula_security"},{"type":"extras","title":"11. macula_gateway - Project Structure","doc":"**Purpose**: Cross-realm gateway functionality.\n\n**Modules**:\n```erlang\nmacula_gateway.erl         - Gateway API\nmacula_gateway_server.erl  - Gateway GenServer\nmacula_policy.erl          - Policy engine (topic filtering, rate limiting)\nmacula_translation.erl     - Topic translation\nmacula_rate_limiter.erl    - Rate limiting per realm pair\n```\n\n**Features**:\n- Multi-realm support\n- Policy-based message filtering\n- Topic translation\n- Rate limiting\n- Audit logging of cross-realm traffic\n\n**Dependencies**:\n- `macula_core`\n- `macula_protocol`\n- `macula_pubsub`\n- `macula_rpc`\n- `macula_security`\n\n**Rebar3 Config**:\n```erlang\n{application, macula_gateway, [\n    {description, \"Macula cross-realm gateway\"},\n    {vsn, \"0.1.0\"},\n    {applications, [kernel, stdlib, macula_core, macula_protocol,\n                    macula_pubsub, macula_rpc, macula_security]},\n    {mod, {macula_gateway_app, []}}\n]}.\n```\n\n---","ref":"macula_project_structure.html#11-macula_gateway"},{"type":"extras","title":"12. macula (Main Application) - Project Structure","doc":"**Purpose**: Umbrella application that ties everything together.\n\n**Modules**:\n```erlang\nmacula.erl                 - Main API\nmacula_app.erl             - Application callback\nmacula_sup.erl             - Top-level supervisor\nmacula_config.erl          - Configuration management\n```\n\n**Supervision Tree**:\n```erlang\nmacula_sup (one_for_one)\n macula_discovery_sup\n macula_quic_sup\n macula_membership_sup\n macula_routing_sup\n macula_topology_sup\n macula_pubsub_sup\n macula_rpc_sup\n macula_security_sup\n macula_gateway_sup (optional, if gateway mode)\n```\n\n**Dependencies**: All macula_* libraries\n\n**Rebar3 Config**:\n```erlang\n{application, macula, [\n    {description, \"Macula HTTP/3 Mesh Platform\"},\n    {vsn, \"0.1.0\"},\n    {applications, [\n        kernel, stdlib,\n        macula_core,\n        macula_quic,\n        macula_protocol,\n        macula_membership,\n        macula_routing,\n        macula_topology,\n        macula_pubsub,\n        macula_rpc,\n        macula_discovery,\n        macula_security,\n        macula_gateway\n    ]},\n    {mod, {macula_app, []}},\n    {env, [\n        {realm, <<\"org.example.mesh\">>},\n        {listen_port, 4433},\n        {discovery, [{methods, [static, mdns]}]},\n        {topology, [{type, k_regular}, {k, 2}]}\n    ]}\n]}.\n```\n\n---","ref":"macula_project_structure.html#12-macula-main-application"},{"type":"extras","title":"Supporting Tools and Utilities - Project Structure","doc":"","ref":"macula_project_structure.html#supporting-tools-and-utilities"},{"type":"extras","title":"13. macula_cli - Project Structure","doc":"**Purpose**: Command-line tool for Macula operations.\n\n**Features**:\n- Start/stop nodes\n- Join mesh\n- View topology\n- Send test messages\n- Query membership\n- Inspect routing table\n\n**Implementation**: Escript\n\n**Rebar3 Config**:\n```erlang\n{escript_name, macula}.\n{escript_emu_args, \"%%! -escript main macula_cli\\n\"}.\n```\n\n**Usage**:\n```bash\nmacula start --realm org.example.mesh --port 4433\nmacula join 192.168.1.100:4433\nmacula topology\nmacula publish topic.name '{\"data\": \"hello\"}'\nmacula stats\n```\n\n---","ref":"macula_project_structure.html#13-macula_cli"},{"type":"extras","title":"14. macula_observer - Project Structure","doc":"**Purpose**: Real-time mesh visualization and monitoring.\n\n**Features**:\n- Visual mesh topology (graphviz-style)\n- Live message flow\n- Membership state\n- Connection status\n- Metrics dashboard\n\n**Implementation**: Phoenix LiveView application (if using Elixir)\n\n**Alternative**: Standalone Erlang application with web UI (Cowboy + WebSocket)\n\n---","ref":"macula_project_structure.html#14-macula_observer"},{"type":"extras","title":"15. macula_loadtest - Project Structure","doc":"**Purpose**: Load testing and benchmarking tool.\n\n**Features**:\n- Spawn N virtual nodes\n- Pub/sub throughput testing\n- RPC latency testing\n- Failure injection\n- Report generation\n\n**Implementation**: Standalone Erlang application using Tsung or custom framework\n\n---","ref":"macula_project_structure.html#15-macula_loadtest"},{"type":"extras","title":"Optional/Future Libraries - Project Structure","doc":"","ref":"macula_project_structure.html#optional-future-libraries"},{"type":"extras","title":"16. macula_wamp_compat - Project Structure","doc":"**Purpose**: WAMP compatibility layer (bridge WAMP clients to Macula).\n\n**Modules**:\n- WAMP protocol adapter\n- WebSocket server\n- Message translation (WAMP  Macula)\n\n**Use Case**: Migrate from Bondy/WAMP to Macula gradually\n\n---","ref":"macula_project_structure.html#16-macula_wamp_compat"},{"type":"extras","title":"17. macula_http_bridge - Project Structure","doc":"**Purpose**: HTTP/REST gateway for Macula (publish via HTTP POST).\n\n**Modules**:\n- Cowboy HTTP handler\n- REST API (publish, call, subscribe via SSE)\n\n**Use Case**: Non-BEAM clients accessing Macula\n\n---","ref":"macula_project_structure.html#17-macula_http_bridge"},{"type":"extras","title":"18. macula_kafka_connector - Project Structure","doc":"**Purpose**: Kafka bridge (publish Macula events to Kafka, consume Kafka events).\n\n**Dependencies**: `brod` (Kafka client)\n\n---","ref":"macula_project_structure.html#18-macula_kafka_connector"},{"type":"extras","title":"19. macula_postgres_connector - Project Structure","doc":"**Purpose**: PostgreSQL integration (CDC, event sourcing).\n\n**Dependencies**: `epgsql` or `postgrex`\n\n---","ref":"macula_project_structure.html#19-macula_postgres_connector"},{"type":"extras","title":"20. macula_metrics - Project Structure","doc":"**Purpose**: Metrics and observability (Prometheus, OpenTelemetry).\n\n**Modules**:\n- Prometheus exporter\n- OpenTelemetry integration\n- StatsD reporter\n\n**Dependencies**:\n- `prometheus` or `prometheus_ex`\n- `opentelemetry` and `opentelemetry_exporter`\n\n---","ref":"macula_project_structure.html#20-macula_metrics"},{"type":"extras","title":"Development Roadmap - Project Structure","doc":"","ref":"macula_project_structure.html#development-roadmap"},{"type":"extras","title":"Phase 1: Foundation (Weeks 1-4) - Project Structure","doc":"**Goal**: Get basic QUIC transport and protocol working.\n\n**Libraries to build**:\n1. `macula_core` - Types and utilities\n2. `macula_quic` - QUIC wrapper\n3. `macula_protocol` - Wire protocol\n\n**Deliverable**: Two nodes can connect and exchange handshake messages.\n\n---","ref":"macula_project_structure.html#phase-1-foundation-weeks-1-4"},{"type":"extras","title":"Phase 2: Mesh Topology (Weeks 5-8) - Project Structure","doc":"**Goal**: Self-organizing mesh network.\n\n**Libraries to build**:\n4. `macula_membership` - SWIM\n5. `macula_routing` - Kademlia DHT\n6. `macula_topology` - k-regular graph\n7. `macula_discovery` - Node discovery\n\n**Deliverable**: N nodes form a mesh and detect failures.\n\n---","ref":"macula_project_structure.html#phase-2-mesh-topology-weeks-5-8"},{"type":"extras","title":"Phase 3: Messaging (Weeks 9-12) - Project Structure","doc":"**Goal**: Pub/sub and RPC working across mesh.\n\n**Libraries to build**:\n8. `macula_pubsub` - Pub/sub\n9. `macula_rpc` - RPC\n\n**Deliverable**: Applications can publish/subscribe and make RPC calls.\n\n---","ref":"macula_project_structure.html#phase-3-messaging-weeks-9-12"},{"type":"extras","title":"Phase 4: Security and Gateways (Weeks 13-16) - Project Structure","doc":"**Goal**: Production-ready security and multi-tenancy.\n\n**Libraries to build**:\n10. `macula_security` - Certificates, ACLs, audit\n11. `macula_gateway` - Cross-realm gateway\n\n**Deliverable**: Secure mesh with realm isolation.\n\n---","ref":"macula_project_structure.html#phase-4-security-and-gateways-weeks-13-16"},{"type":"extras","title":"Phase 5: Tooling and Monitoring (Weeks 17-20) - Project Structure","doc":"**Goal**: Developer experience and operations tooling.\n\n**Tools to build**:\n13. `macula_cli` - Command-line tool\n14. `macula_observer` - Visualization\n15. `macula_loadtest` - Benchmarking\n20. `macula_metrics` - Observability\n\n**Deliverable**: Production-ready platform with tooling.\n\n---","ref":"macula_project_structure.html#phase-5-tooling-and-monitoring-weeks-17-20"},{"type":"extras","title":"Testing Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#testing-strategy"},{"type":"extras","title":"Unit Tests - Project Structure","doc":"Each library has its own test suite:\n```\napps/macula_core/test/\napps/macula_quic/test/\napps/macula_protocol/test/\n...\n```\n\n**Framework**: EUnit (Erlang) or ExUnit (Elixir)\n\n**Run**:\n```bash\nrebar3 eunit\n# or\nmix test\n```\n\n---","ref":"macula_project_structure.html#unit-tests"},{"type":"extras","title":"Integration Tests - Project Structure","doc":"Multi-node integration tests:\n```\ntest/integration/\n mesh_formation_test.erl\n pubsub_test.erl\n rpc_test.erl\n failure_recovery_test.erl\n gateway_test.erl\n```\n\n**Framework**: Common Test (Erlang)\n\n**Run**:\n```bash\nrebar3 ct\n```\n\n---","ref":"macula_project_structure.html#integration-tests"},{"type":"extras","title":"Property-Based Tests - Project Structure","doc":"Use PropEr (Erlang) or StreamData (Elixir):\n```\napps/macula_routing/test/prop_kademlia.erl\napps/macula_membership/test/prop_swim.erl\n```\n\n**Run**:\n```bash\nrebar3 proper\n```\n\n---","ref":"macula_project_structure.html#property-based-tests"},{"type":"extras","title":"Load Tests - Project Structure","doc":"Separate load testing suite:\n```\nloadtest/\n pubsub_throughput.erl\n rpc_latency.erl\n mesh_scale.erl (1000+ nodes)\n failure_injection.erl\n```\n\n**Framework**: Tsung or custom\n\n---","ref":"macula_project_structure.html#load-tests"},{"type":"extras","title":"Continuous Integration - Project Structure","doc":"","ref":"macula_project_structure.html#continuous-integration"},{"type":"extras","title":"GitHub Actions Workflow - Project Structure","doc":"```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: erlef/setup-beam@v1\n        with:\n          otp-version: '26.2'\n          rebar3-version: '3.22'\n      - run: rebar3 compile\n      - run: rebar3 eunit\n      - run: rebar3 ct\n      - run: rebar3 dialyzer\n\n  integration:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: erlef/setup-beam@v1\n      - run: rebar3 as test release\n      - run: ./test/integration/run_all.sh\n```\n\n---","ref":"macula_project_structure.html#github-actions-workflow"},{"type":"extras","title":"Release Strategy - Project Structure","doc":"","ref":"macula_project_structure.html#release-strategy"},{"type":"extras","title":"Rebar3 Release - Project Structure","doc":"```erlang\n%% rebar.config\n{relx, [\n    {release, {macula, \"0.1.0\"}, [\n        macula,\n        sasl\n    ]},\n\n    {mode, prod},\n    {include_erts, true},\n    {extended_start_script, true},\n\n    {overlay, [\n        {copy, \"config/sys.config.example\", \"etc/sys.config\"},\n        {copy, \"config/vm.args.example\", \"etc/vm.args\"}\n    ]}\n]}.\n```\n\n**Build**:\n```bash\nrebar3 release\n```\n\n**Result**: `_build/default/rel/macula/`\n\n---","ref":"macula_project_structure.html#rebar3-release"},{"type":"extras","title":"Docker Image - Project Structure","doc":"```dockerfile\nFROM erlang:26-alpine AS builder\n\nWORKDIR /build\nCOPY . .\nRUN rebar3 as prod release\n\nFROM alpine:latest\n\nRUN apk add --no-cache openssl ncurses-libs libstdc++\n\nCOPY --from=builder /build/_build/prod/rel/macula /opt/macula\n\nEXPOSE 4433/udp\n\nCMD [\"/opt/macula/bin/macula\", \"foreground\"]\n```\n\n**Build**:\n```bash\ndocker build -t macula:latest .\n```\n\n---","ref":"macula_project_structure.html#docker-image"},{"type":"extras","title":"Repository Initialization - Project Structure","doc":"","ref":"macula_project_structure.html#repository-initialization"},{"type":"extras","title":"Create Umbrella Application - Project Structure","doc":"```bash\n# Erlang (Rebar3)\nrebar3 new umbrella macula\ncd macula\n\n# Create apps\nrebar3 new lib apps/macula_core\nrebar3 new lib apps/macula_quic\nrebar3 new lib apps/macula_protocol\n# ... etc\n\n# Compile\nrebar3 compile\n\n# Test\nrebar3 eunit\n\n# Release\nrebar3 release\n```","ref":"macula_project_structure.html#create-umbrella-application"},{"type":"extras","title":"OR Elixir (Mix) - Project Structure","doc":"```bash\n# Elixir (Mix)\nmix new macula --umbrella\ncd macula\n\n# Create apps\ncd apps\nmix new macula_core\nmix new macula_quic\nmix new macula_protocol\n# ... etc\n\ncd ..\n\n# Compile\nmix compile\n\n# Test\nmix test\n\n# Release\nmix release\n```\n\n---","ref":"macula_project_structure.html#or-elixir-mix"},{"type":"extras","title":"Summary - Project Structure","doc":"**Core Libraries** (12):\n1.  `macula_core` - Core types and utilities\n2.  `macula_quic` - QUIC transport\n3.  `macula_protocol` - Wire protocol\n4.  `macula_membership` - SWIM membership\n5.  `macula_routing` - Kademlia DHT\n6.  `macula_topology` - Mesh topology\n7.  `macula_pubsub` - Pub/sub\n8.  `macula_rpc` - RPC\n9.  `macula_discovery` - Node discovery\n10.  `macula_security` - Security\n11.  `macula_gateway` - Cross-realm gateway\n12.  `macula` - Main application\n\n**Tools** (3):\n13.  `macula_cli` - CLI tool\n14.  `macula_observer` - Visualization\n15.  `macula_loadtest` - Load testing\n\n**Optional** (5):\n16.  `macula_wamp_compat` - WAMP bridge\n17.  `macula_http_bridge` - HTTP gateway\n18.  `macula_kafka_connector` - Kafka integration\n19.  `macula_postgres_connector` - PostgreSQL integration\n20.  `macula_metrics` - Metrics/observability\n\n**Total**: 20 libraries/applications\n\n---\n\n**Next Step**: Initialize the repository structure and start with Phase 1 (Foundation).\n\n---\n\n**Last Updated**: 2025-01-08\n**Maintainers**: [To be assigned]","ref":"macula_project_structure.html#summary"},{"type":"extras","title":"Architecture","doc":"# Macula HTTP/3 Mesh - Documentation Root\n\n**A distributed mesh networking platform for BEAM, built on HTTP/3/QUIC**\n\n---","ref":"macula_http3_mesh_root.html"},{"type":"extras","title":"Vision - Architecture","doc":"Build a unique, standards-based distributed networking layer for Erlang/Elixir applications that:\n- Uses HTTP/3 (QUIC) for NAT-friendly, firewall-friendly transport\n- Forms self-organizing mesh topologies at the edge\n- Provides pub/sub and RPC primitives\n- Scales to thousands of nodes\n- Supports multi-tenancy and realm isolation\n- Delivers \"Wow! How do they do it?\" factor\n\n**Target Use Cases**:\n- Edge-first IoT networks\n- Decentralized energy trading platforms\n- Multi-tenant SaaS applications\n- Partner data exchange networks\n- Hybrid cloud-edge systems\n\n---","ref":"macula_http3_mesh_root.html#vision"},{"type":"extras","title":"Documentation Index - Architecture","doc":"","ref":"macula_http3_mesh_root.html#documentation-index"},{"type":"extras","title":"Core Architecture Documents - Architecture","doc":"#### 1. [Technical Roadmap](macula_http3_mesh_roadmap.md)  **START HERE**\n**20-week implementation plan with detailed technical specifications**\n\n**Contents**:\n- Understanding QUIC and HTTP/3 (protocol deep dive)\n- QUIC/HTTP/3 libraries for BEAM (comparison matrix)\n- Complete 5-layer architecture\n- Phase-by-phase implementation (Weeks 1-20)\n- Code examples for each phase\n- Success criteria and benchmarks\n- Technical deep dives (QUIC vs TCP, SWIM gossip, Kademlia DHT)\n\n**Who should read this**: Engineers implementing the platform, technical leads evaluating feasibility\n\n**Key decisions documented**:\n- QUIC library choice: **quicer** (Erlang NIF wrapper for MsQuic)\n- Topology: **k-regular graph** with SWIM gossip\n- Routing: **Kademlia DHT** (O(log N) lookups)\n- NAT traversal: **STUN/ICE + UDP hole punching**\n\n---\n\n#### 2. [C4 Architecture Diagrams](macula_http3_mesh_c4_diagrams.md)\n**Multi-level architecture visualization using C4 model**\n\n**Contents**:\n- **Level 1 - System Context**: Ecosystem view (developers, nodes, infrastructure)\n- **Level 2 - Container**: Technology stack, BEAM VM internals\n- **Level 3 - Component**: Mesh Services and Protocol Layer components\n- **Level 4 - Code**: Detailed `macula_connection` GenServer implementation\n- **Supplementary - Deployment**: Physical deployment scenarios\n\n**Who should read this**: Architects, new team members, stakeholders wanting visual overview\n\n**Diagram formats**: ASCII (easy to view in terminal, version control friendly)\n\n---\n\n#### 3. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md)\n**Multi-tenancy, realms, and cross-realm communication**\n\n**Contents**:\n- Realm concept and namespacing\n- Identity layer (node-level realm membership)\n- Topic namespacing and validation\n- Routing table partitioning by realm\n- Three cross-realm communication models:\n  - **Model A: Gateway Nodes** (recommended)\n  - **Model B: Federation Protocol**\n  - **Model C: Strict Isolation**\n- Protocol-level realm support\n- SWIM membership per realm\n- Pub/sub with realm scoping\n- Certificate-based security\n- Use cases (SaaS, energy markets, IoT, partners)\n- Implementation roadmap (Weeks 21-27)\n\n**Who should read this**: SaaS platform engineers, security architects, multi-tenant deployment teams\n\n**Key features**:\n- Isolation by default\n- Policy-based gateways for controlled data sharing\n- Certificate validation with realm in SAN\n- ACL enforcement\n- Audit logging\n\n---","ref":"macula_http3_mesh_root.html#core-architecture-documents"},{"type":"extras","title":"Quick Start Guides - Architecture","doc":"#### 4. [Quick Start Guide](macula_http3_mesh_quick_start.md)   **TODO**\n**Get a 3-node mesh running in 15 minutes**\n\n**Planned contents**:\n- Prerequisites (Erlang/OTP 26+, quicer installation)\n- Download and build Macula\n- Start first node\n- Start and join second node\n- Start and join third node\n- Send first pub/sub message\n- Make first RPC call\n- Verify mesh topology\n- Common troubleshooting\n\n**Target audience**: Developers wanting hands-on experience\n\n---\n\n#### 5. [Hello World Tutorial](macula_http3_mesh_hello_world.md)   **TODO**\n**Build your first Macula application**\n\n**Planned contents**:\n- Create new Elixir/Mix project\n- Add Macula dependency\n- Configure node identity and realm\n- Implement simple pub/sub chat application\n- Deploy across multiple nodes\n- Add RPC endpoint (echo service)\n- Monitor with Observer\n\n**Target audience**: Application developers new to Macula\n\n---","ref":"macula_http3_mesh_root.html#quick-start-guides"},{"type":"extras","title":"API and Protocol Specifications - Architecture","doc":"#### 6. [Wire Protocol Specification](macula_http3_mesh_protocol_spec.md)   **TODO**\n**Complete wire protocol documentation**\n\n**Planned contents**:\n- Packet format and framing\n- Message types (handshake, heartbeat, send, pub, sub, rpc, etc.)\n- Encoding/decoding rules (Erlang term format)\n- Handshake protocol flow\n- Stream multiplexing\n- Error handling\n- Protocol versioning\n- Compatibility matrix\n\n**Target audience**: Protocol implementers, interoperability teams\n\n---\n\n#### 7. [API Reference](macula_http3_mesh_api_reference.md)   **TODO**\n**Complete Erlang/Elixir API documentation**\n\n**Planned contents**:\n- `macula:start/1` - Start node\n- `macula:connect/2` - Connect to peer\n- `macula:publish/2,3` - Publish message\n- `macula:subscribe/1,2` - Subscribe to topic\n- `macula:call/3,4` - RPC call\n- `macula:register/2` - Register RPC endpoint\n- Gateway APIs\n- Policy configuration APIs\n- Metrics and monitoring APIs\n\n**Target audience**: Application developers\n\n---","ref":"macula_http3_mesh_root.html#api-and-protocol-specifications"},{"type":"extras","title":"Advanced Topics - Architecture","doc":"#### 8. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md)   **TODO**\n**How Macula works behind NATs and firewalls**\n\n**Planned contents**:\n- NAT types and challenges (full cone, symmetric, etc.)\n- STUN protocol for public IP discovery\n- ICE protocol for connectivity establishment\n- UDP hole punching techniques\n- TURN relay fallback\n- Connection migration on IP change\n- Mobile/cellular network considerations\n- Enterprise firewall traversal\n\n**Target audience**: Network engineers, DevOps, deployment teams\n\n---\n\n#### 9. [Security Model](macula_http3_mesh_security.md)   **TODO**\n**Comprehensive security architecture**\n\n**Planned contents**:\n- Threat model\n- TLS 1.3 integration with QUIC\n- Certificate-based node authentication\n- Realm isolation via certificates\n- ACL enforcement\n- Message signing and verification\n- Audit logging\n- Denial-of-service protection\n- Rate limiting\n- Security best practices\n- Penetration testing results\n\n**Target audience**: Security teams, compliance officers, architects\n\n---\n\n#### 10. [Performance Tuning Guide](macula_http3_mesh_performance.md)   **TODO**\n**Optimize for throughput and latency**\n\n**Planned contents**:\n- Benchmarking methodology\n- OS-level tuning (UDP buffers, file descriptors)\n- BEAM VM tuning (schedulers, memory)\n- QUIC connection parameters\n- Stream multiplexing configuration\n- Routing table optimization\n- SWIM protocol tuning\n- Gateway throughput optimization\n- Monitoring and profiling tools\n- Load testing scenarios\n\n**Target audience**: Performance engineers, SREs\n\n---\n\n#### 11. [Observability Guide](macula_http3_mesh_observability.md)   **TODO**\n**Monitor, trace, and debug Macula networks**\n\n**Planned contents**:\n- Prometheus metrics (all available metrics)\n- Grafana dashboards (pre-built templates)\n- OpenTelemetry tracing integration\n- Log aggregation (structured logging)\n- Mesh topology visualization\n- Real-time message flow visualization\n- Health checks and alerts\n- Debugging tools (observer, recon, etc.)\n- Common issues and diagnostics\n\n**Target audience**: SREs, DevOps, operations teams\n\n---\n\n#### 12. [Deployment Patterns](macula_http3_mesh_deployment_patterns.md)   **TODO**\n**Production deployment architectures**\n\n**Planned contents**:\n- Single-region mesh\n- Multi-region with gateways\n- Hybrid cloud-edge\n- Kubernetes deployment (Helm charts)\n- Docker Compose examples\n- Bare metal / VM deployment\n- DNS/discovery configuration\n- Load balancing strategies\n- High availability patterns\n- Disaster recovery\n- Migration strategies (zero-downtime updates)\n\n**Target audience**: DevOps, platform engineers, architects\n\n---\n\n#### 13. [Gateway Operations Manual](macula_http3_mesh_gateway_ops.md)   **TODO**\n**Deploy and operate gateway nodes**\n\n**Planned contents**:\n- Gateway node requirements\n- Policy configuration (YAML/JSON schemas)\n- Topic translation setup\n- Rate limiting configuration\n- Audit log management\n- Certificate management for gateways\n- High availability setup (active-active)\n- Monitoring gateway health\n- Troubleshooting cross-realm issues\n- Performance optimization\n- Security hardening\n\n**Target audience**: Gateway operators, platform admins\n\n---","ref":"macula_http3_mesh_root.html#advanced-topics"},{"type":"extras","title":"Comparisons and Design Decisions - Architecture","doc":"#### 14. [Comparison with WAMP/Bondy](macula_http3_mesh_vs_wamp.md)   **TODO**\n**Why build Macula when WAMP exists?**\n\n**Planned contents**:\n- WAMP strengths and weaknesses\n- Why WAMP over WebSocket doesn't work well for edge\n- NAT traversal comparison\n- Bondy clustering (Partisan) vs Macula mesh\n- Protocol overhead comparison\n- Latency and throughput benchmarks\n- When to use WAMP/Bondy vs Macula\n- Migration path from WAMP to Macula\n- Interoperability (WAMP compatibility layer)\n\n**Target audience**: Teams familiar with WAMP, decision makers\n\n---\n\n#### 15. [Comparison with libp2p](macula_http3_mesh_vs_libp2p.md)   **TODO**\n**Macula vs libp2p (IPFS networking stack)**\n\n**Planned contents**:\n- libp2p architecture overview\n- BEAM libp2p implementations (ex_libp2p)\n- Why not use libp2p?\n  - Complexity\n  - Maturity in BEAM ecosystem\n  - Distributed Erlang incompatibility\n- Protocol comparison (QUIC, GossipSub, Kademlia)\n- Use case fit analysis\n- Performance comparison\n\n**Target audience**: P2P networking engineers, architects\n\n---\n\n#### 16. [Design Decision Log](macula_http3_mesh_decisions.md)   **TODO**\n**Why we made the choices we did**\n\n**Planned contents**:\n- ADR 001: Why QUIC instead of TCP?\n- ADR 002: Why quicer (MsQuic) instead of pure Erlang?\n- ADR 003: Why Kademlia instead of Chord/Pastry?\n- ADR 004: Why SWIM instead of Raft for membership?\n- ADR 005: Why k-regular graph instead of full mesh?\n- ADR 006: Why gateway pattern for cross-realm?\n- ADR 007: Why certificate-based auth instead of API keys?\n- ADR 008: Why UDP hole punching instead of TURN-only?\n\n**Format**: Architecture Decision Records (ADRs)\n\n**Target audience**: Architects, long-term maintainers\n\n---","ref":"macula_http3_mesh_root.html#comparisons-and-design-decisions"},{"type":"extras","title":"Reference Materials - Architecture","doc":"#### 17. [Glossary](macula_http3_mesh_glossary.md)   **TODO**\n**Terms and definitions**\n\n**Planned contents**:\n- QUIC, HTTP/3, UDP, DTLS, TLS 1.3\n- Mesh, topology, k-regular graph\n- SWIM, gossip, failure detection\n- Kademlia, DHT, XOR distance\n- Realm, tenant, gateway\n- Pub/sub, RPC, stream\n- NAT, STUN, ICE, TURN, hole punching\n- Connection migration, 0-RTT\n- ACL, policy, audit\n\n**Target audience**: Everyone (reference)\n\n---\n\n#### 18. [FAQ](macula_http3_mesh_faq.md)   **TODO**\n**Frequently asked questions**\n\n**Planned contents**:\n- What is Macula?\n- Why HTTP/3 instead of traditional distributed Erlang?\n- Can it work behind NAT?\n- How many nodes can it scale to?\n- What's the latency overhead?\n- Is it production-ready?\n- How does it compare to X? (where X = WAMP, libp2p, Partisan, gRPC, etc.)\n- Can I use it with Phoenix/LiveView?\n- Does it work in Kubernetes?\n- What license is it?\n\n**Target audience**: Everyone (first questions)\n\n---\n\n#### 19. [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md)   **TODO**\n**Common issues and solutions**\n\n**Planned contents**:\n- Nodes can't discover each other\n- Connection timeout / handshake failure\n- NAT traversal failures\n- Certificate validation errors\n- SWIM membership flapping\n- Routing table inconsistencies\n- Gateway policy denials\n- Performance issues (high latency, low throughput)\n- Memory leaks\n- Crash dumps analysis\n\n**Format**: Problem  Diagnosis  Solution\n\n**Target audience**: Operations, support teams\n\n---","ref":"macula_http3_mesh_root.html#reference-materials"},{"type":"extras","title":"Contributing and Community - Architecture","doc":"#### 20. [Contributing Guide](macula_http3_mesh_contributing.md)   **TODO**\n**How to contribute to Macula**\n\n**Planned contents**:\n- Code of conduct\n- Development setup\n- Testing requirements (unit, integration, property-based)\n- Code style guide (Erlang/Elixir conventions)\n- Documentation requirements\n- Pull request process\n- Release process\n- Community channels (Discord, mailing list, etc.)\n- Roadmap and feature requests\n\n**Target audience**: Contributors, open source community\n\n---","ref":"macula_http3_mesh_root.html#contributing-and-community"},{"type":"extras","title":"Document Status - Architecture","doc":"| Document | Status | Priority | Target Week |\n|----------|--------|----------|-------------|\n| Technical Roadmap |  Complete | P0 | Week 0 |\n| C4 Diagrams |  Complete | P0 | Week 0 |\n| Isolation Mechanisms |  Complete | P0 | Week 0 |\n| Quick Start Guide |  TODO | P1 | Week 4 |\n| Hello World Tutorial |  TODO | P1 | Week 4 |\n| Wire Protocol Spec |  TODO | P1 | Week 8 |\n| API Reference |  TODO | P1 | Week 12 |\n| NAT Traversal Deep Dive |  TODO | P2 | Week 12 |\n| Security Model |  TODO | P1 | Week 16 |\n| Performance Tuning |  TODO | P2 | Week 20 |\n| Observability Guide |  TODO | P2 | Week 20 |\n| Deployment Patterns |  TODO | P1 | Week 20 |\n| Gateway Operations |  TODO | P2 | Week 24 |\n| Comparison with WAMP |  TODO | P2 | Week 8 |\n| Comparison with libp2p |  TODO | P3 | Week 12 |\n| Design Decision Log |  TODO | P2 | Ongoing |\n| Glossary |  TODO | P2 | Week 4 |\n| FAQ |  TODO | P1 | Week 4 |\n| Troubleshooting Guide |  TODO | P2 | Week 20 |\n| Contributing Guide |  TODO | P2 | Week 4 |\n\n**Priority Levels**:\n- **P0**: Must have before any code (architecture)\n- **P1**: Required for MVP release\n- **P2**: Important for production use\n- **P3**: Nice to have\n\n---","ref":"macula_http3_mesh_root.html#document-status"},{"type":"extras","title":"Reading Paths - Architecture","doc":"","ref":"macula_http3_mesh_root.html#reading-paths"},{"type":"extras","title":"For Evaluators (Decision Makers) - Architecture","doc":"1. This document (overview)\n2. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Sections: Vision, Architecture Overview, Timeline\n3. [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) - Level 1 and Level 2\n4. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Use Cases section\n\n**Time**: ~1 hour\n\n---","ref":"macula_http3_mesh_root.html#for-evaluators-decision-makers"},{"type":"extras","title":"For Architects (System Design) - Architecture","doc":"1. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Complete read\n2. [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) - All levels\n3. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Complete read\n4. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md)  TODO\n5. [Security Model](macula_http3_mesh_security.md)  TODO\n6. [Design Decision Log](macula_http3_mesh_decisions.md)  TODO\n\n**Time**: ~4 hours\n\n---","ref":"macula_http3_mesh_root.html#for-architects-system-design"},{"type":"extras","title":"For Implementers (Engineers) - Architecture","doc":"1. [Technical Roadmap](macula_http3_mesh_roadmap.md) - Focus on code examples\n2. [Wire Protocol Spec](macula_http3_mesh_protocol_spec.md)  TODO\n3. [API Reference](macula_http3_mesh_api_reference.md)  TODO\n4. [Quick Start Guide](macula_http3_mesh_quick_start.md)  TODO\n5. [Hello World Tutorial](macula_http3_mesh_hello_world.md)  TODO\n\n**Time**: ~3 hours + hands-on\n\n---","ref":"macula_http3_mesh_root.html#for-implementers-engineers"},{"type":"extras","title":"For Operators (DevOps/SRE) - Architecture","doc":"1. [Quick Start Guide](macula_http3_mesh_quick_start.md)  TODO\n2. [Deployment Patterns](macula_http3_mesh_deployment_patterns.md)  TODO\n3. [Observability Guide](macula_http3_mesh_observability.md)  TODO\n4. [Performance Tuning](macula_http3_mesh_performance.md)  TODO\n5. [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md)  TODO\n6. [Gateway Operations](macula_http3_mesh_gateway_ops.md)  TODO\n\n**Time**: ~2 hours + practice\n\n---","ref":"macula_http3_mesh_root.html#for-operators-devops-sre"},{"type":"extras","title":"For Security Teams - Architecture","doc":"1. [Security Model](macula_http3_mesh_security.md)  TODO\n2. [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) - Security sections\n3. [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md)  TODO\n4. [Gateway Operations](macula_http3_mesh_gateway_ops.md)  TODO - Security hardening\n\n**Time**: ~3 hours\n\n---","ref":"macula_http3_mesh_root.html#for-security-teams"},{"type":"extras","title":"Additional Topics to Document - Architecture","doc":"Based on the comprehensive nature of this project, here are **additional topics** that should be documented:","ref":"macula_http3_mesh_root.html#additional-topics-to-document"},{"type":"extras","title":"21. Testing Strategy  - Architecture","doc":"**Comprehensive testing approach**\n\n**Contents**:\n- Unit testing (EUnit, ExUnit)\n- Property-based testing (PropEr, StreamData)\n- Integration testing (multi-node scenarios)\n- Chaos engineering (partition testing, node crashes)\n- Load testing (Tsung, k6)\n- Security testing (penetration testing)\n- Fuzz testing (protocol fuzzing)\n- Continuous integration setup\n\n---","ref":"macula_http3_mesh_root.html#21-testing-strategy"},{"type":"extras","title":"22. Migration Guide  - Architecture","doc":"**Moving from other systems to Macula**\n\n**Contents**:\n- Migrating from WAMP/Bondy\n- Migrating from distributed Erlang\n- Migrating from RabbitMQ/Kafka\n- Migrating from gRPC\n- Co-existence strategies (gradual migration)\n- Data migration patterns\n- Rollback procedures\n\n---","ref":"macula_http3_mesh_root.html#22-migration-guide"},{"type":"extras","title":"23. Scaling Patterns  - Architecture","doc":"**How to scale from 10 to 10,000 nodes**\n\n**Contents**:\n- Topology evolution (full mesh  k-regular  hierarchical)\n- Region sharding\n- DHT bucket optimization\n- SWIM tuning for large networks\n- Gateway scaling (horizontal)\n- Database scaling (if persistence layer added)\n- Cost analysis at scale\n\n---","ref":"macula_http3_mesh_root.html#23-scaling-patterns"},{"type":"extras","title":"24. Protocol Evolution  - Architecture","doc":"**Versioning and backward compatibility**\n\n**Contents**:\n- Protocol version negotiation\n- Backward compatibility guarantees\n- Deprecation policy\n- Feature flags\n- Upgrade paths (rolling upgrades)\n- Breaking changes process\n\n---","ref":"macula_http3_mesh_root.html#24-protocol-evolution"},{"type":"extras","title":"25. Mobile and Browser Support  - Architecture","doc":"**Extending Macula to constrained environments**\n\n**Contents**:\n- WebAssembly BEAM (lumen, AtomVM)\n- Browser WebTransport (QUIC in browsers)\n- React Native integration\n- Mobile battery optimization\n- Offline-first patterns\n- Connection resumption on network change\n\n---","ref":"macula_http3_mesh_root.html#25-mobile-and-browser-support"},{"type":"extras","title":"26. Plugin Architecture  - Architecture","doc":"**Extend Macula with custom behaviors**\n\n**Contents**:\n- Hook system for message interception\n- Custom discovery plugins (Consul, etcd)\n- Custom transport plugins (WebRTC, Bluetooth)\n- Custom routing strategies\n- Custom serialization formats\n- Plugin development guide\n\n---","ref":"macula_http3_mesh_root.html#26-plugin-architecture"},{"type":"extras","title":"27. Cost Analysis  - Architecture","doc":"**TCO comparison vs alternatives**\n\n**Contents**:\n- Infrastructure costs (vs cloud load balancers)\n- Bandwidth costs (UDP vs TCP, compression)\n- Operational costs (automation, monitoring)\n- Development costs (time to market)\n- Licensing costs (vs commercial solutions)\n- ROI calculator\n\n---","ref":"macula_http3_mesh_root.html#27-cost-analysis"},{"type":"extras","title":"28. Regulatory Compliance  - Architecture","doc":"**GDPR, HIPAA, SOC2 considerations**\n\n**Contents**:\n- Data residency (realm isolation for regions)\n- Right to be forgotten (message expiry)\n- Audit logging requirements\n- Encryption at rest/in transit\n- Access controls\n- Compliance checklists\n\n---","ref":"macula_http3_mesh_root.html#28-regulatory-compliance"},{"type":"extras","title":"29. Interoperability  - Architecture","doc":"**Connect Macula to other systems**\n\n**Contents**:\n- WAMP compatibility layer (adapter)\n- gRPC bridge\n- REST/GraphQL gateway\n- MQTT bridge (for IoT)\n- Kafka/RabbitMQ connectors\n- Database change data capture (CDC)\n\n---","ref":"macula_http3_mesh_root.html#29-interoperability"},{"type":"extras","title":"30. Case Studies  - Architecture","doc":"**Real-world deployments (when available)**\n\n**Contents**:\n- Example Platform energy trading platform\n- Industrial IoT deployment\n- Multi-tenant SaaS platform\n- Gaming backend\n- Financial data mesh\n- Lessons learned, metrics, testimonials\n\n---","ref":"macula_http3_mesh_root.html#30-case-studies"},{"type":"extras","title":"Contributing to Documentation - Architecture","doc":"Documentation is as important as code! To contribute:\n\n1. **Choose a TODO document** from the status table above\n2. **Follow the template** provided in the document outline\n3. **Include code examples** (working, tested code)\n4. **Add diagrams** (ASCII art for version control friendliness)\n5. **Get review** from at least one core team member\n6. **Update this index** when document is complete\n\n**Documentation Standards**:\n- Use Markdown (.md)\n- ASCII diagrams (box drawing characters: )\n- Code examples must be syntactically correct\n- Include both Erlang and Elixir examples where applicable\n- Cross-reference related documents\n- Keep language clear and concise (avoid jargon, or define it)\n\n---","ref":"macula_http3_mesh_root.html#contributing-to-documentation"},{"type":"extras","title":"License - Architecture","doc":"[To be determined - likely Apache 2.0 or MIT]\n\n---","ref":"macula_http3_mesh_root.html#license"},{"type":"extras","title":"Contact and Community - Architecture","doc":"- **GitHub**: [macula-io/macula](https://github.com/macula-io/macula)  TODO\n- **Discord**: [Join our Discord](https://discord.gg/macula)  TODO\n- **Mailing List**: macula-dev@googlegroups.com  TODO\n- **Twitter**: [@MaculaMesh](https://twitter.com/MaculaMesh)  TODO\n\n---\n\n**Last Updated**: 2025-01-08\n**Maintainers**: Macula Core Team\n**Status**: Living Document (updated as project evolves)","ref":"macula_http3_mesh_root.html#contact-and-community"},{"type":"extras","title":"Quick Start","doc":"# Macula HTTP/3 Mesh - Quick Start Guide\n\n**Get a 3-node mesh running in 15 minutes**\n\n---","ref":"macula_http3_mesh_quick_start.html"},{"type":"extras","title":"Prerequisites - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#prerequisites"},{"type":"extras","title":"Required Software - Quick Start","doc":"1. **Erlang/OTP 26.0 or later**\n   ```bash\n   # Check version\n   erl -eval 'erlang:display(erlang:system_info(otp_release)), halt().' -noshell\n   ```\n\n   Install from:\n   - Ubuntu/Debian: `sudo apt-get install erlang`\n   - macOS: `brew install erlang`\n   - From source: https://www.erlang.org/downloads\n\n2. **Elixir 1.15 or later** (optional, for Elixir examples)\n   ```bash\n   # Check version\n   elixir --version\n   ```\n\n   Install from:\n   - Ubuntu/Debian: `sudo apt-get install elixir`\n   - macOS: `brew install elixir`\n   - From source: https://elixir-lang.org/install.html\n\n3. **Git**\n   ```bash\n   git --version\n   ```\n\n4. **C Compiler** (for building quicer NIF)\n   - Ubuntu/Debian: `sudo apt-get install build-essential cmake`\n   - macOS: `xcode-select --install`","ref":"macula_http3_mesh_quick_start.html#required-software"},{"type":"extras","title":"System Requirements - Quick Start","doc":"- **OS**: Linux (Ubuntu 20.04+), macOS 11+, or Windows WSL2\n- **RAM**: 512 MB minimum per node (2 GB recommended for development)\n- **Network**: UDP port access (default: 4433)\n- **Disk**: 100 MB for Macula + dependencies\n\n---","ref":"macula_http3_mesh_quick_start.html#system-requirements"},{"type":"extras","title":"Step 1: Download and Build Macula - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-1-download-and-build-macula"},{"type":"extras","title":"Clone the Repository - Quick Start","doc":"```bash\ncd ~/projects\ngit clone https://github.com/macula-io/macula.git\ncd macula\n```","ref":"macula_http3_mesh_quick_start.html#clone-the-repository"},{"type":"extras","title":"Install Dependencies - Quick Start","doc":"```bash\n# For Erlang (Rebar3)\nrebar3 get-deps\n\n# For Elixir (Mix)\nmix deps.get\n```","ref":"macula_http3_mesh_quick_start.html#install-dependencies"},{"type":"extras","title":"Build quicer (QUIC Library) - Quick Start","doc":"The `quicer` library includes native code and may take a few minutes to compile:\n\n```bash\n# Rebar3\nrebar3 compile\n\n# Mix\nmix compile\n```\n\n**Expected output**:\n```\n===> Fetching quicer (from {git,\"https://github.com/emqx/quic.git\",...})\n===> Compiling quicer\n     ...\n     [100%] Built target msquic\n===> Compiled quicer\n```","ref":"macula_http3_mesh_quick_start.html#build-quicer-quic-library"},{"type":"extras","title":"Verify Installation - Quick Start","doc":"```bash\n# Erlang\nrebar3 shell\n> macula:version().\n{ok, \"0.1.0\"}\n\n# Elixir\niex -S mix\niex> Macula.version()\n{:ok, \"0.1.0\"}\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#verify-installation"},{"type":"extras","title":"Step 2: Start Node 1 (Bootstrap Node) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-2-start-node-1-bootstrap-node"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node1.config`:\n\n```erlang\n%% config/node1.config\n[\n {macula, [\n   {node_id, <<\"node1\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4433},\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery\n   {discovery, [\n     {methods, [static]},  % Use static bootstrap for this example\n     {static_nodes, []}    % First node has no bootstrap peers\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}  % Each node connects to 2 peers\n   ]},\n\n   %% TLS/Certificates (auto-generate for demo)\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file"},{"type":"extras","title":"Start Node 1 - Quick Start","doc":"```bash\n# Erlang\nerl -config config/node1 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node1@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node1.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node1\n[info] Listening on 0.0.0.0:4433 (UDP)\n[info] Node ID: a3f5b2e1c4d8a7f9...\n[info] Realm: org.example.mesh\n[info] Topology: k_regular (k=2)\n[info] Discovery: static\n[info] Ready to accept connections\n```\n\n**Keep this terminal open** - Node 1 is now running.\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-1"},{"type":"extras","title":"Step 3: Start Node 2 (Join the Mesh) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-3-start-node-2-join-the-mesh"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node2.config`:\n\n```erlang\n%% config/node2.config\n[\n {macula, [\n   {node_id, <<\"node2\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4434},  % Different port\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery - bootstrap from Node 1\n   {discovery, [\n     {methods, [static]},\n     {static_nodes, [\n       {\"127.0.0.1\", 4433}  % Node 1's address\n     ]}\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n\n   %% TLS/Certificates\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file-1"},{"type":"extras","title":"Start Node 2 (in new terminal) - Quick Start","doc":"```bash\n# Open new terminal\ncd ~/projects/macula\n\n# Erlang\nerl -config config/node2 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node2@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node2.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node2\n[info] Listening on 0.0.0.0:4434 (UDP)\n[info] Node ID: b7c3d8e2f5a9b4c1...\n[info] Realm: org.example.mesh\n[info] Connecting to bootstrap node 127.0.0.1:4433...\n[info] Connected to node1 (a3f5b2e1c4d8a7f9...)\n[info] SWIM membership: 2 nodes alive\n[info] Mesh topology established\n```\n\n**In Node 1's terminal**, you should see:\n```\n[info] New connection from 127.0.0.1:xxxxx\n[info] Handshake complete: node2 (b7c3d8e2f5a9b4c1...)\n[info] SWIM membership: 2 nodes alive\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-2-in-new-terminal"},{"type":"extras","title":"Step 4: Start Node 3 (Expand the Mesh) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-4-start-node-3-expand-the-mesh"},{"type":"extras","title":"Create Configuration File - Quick Start","doc":"Create `config/node3.config`:\n\n```erlang\n%% config/node3.config\n[\n {macula, [\n   {node_id, <<\"node3\">>},\n   {realm, <<\"org.example.mesh\">>},\n   {listen_port, 4435},\n   {listen_address, \"0.0.0.0\"},\n\n   %% Discovery - can bootstrap from either node\n   {discovery, [\n     {methods, [static]},\n     {static_nodes, [\n       {\"127.0.0.1\", 4433},  % Node 1\n       {\"127.0.0.1\", 4434}   % Node 2\n     ]}\n   ]},\n\n   %% Topology\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n\n   %% TLS/Certificates\n   {cert_mode, auto_generate},\n\n   %% Logging\n   {log_level, info}\n ]}\n].\n```","ref":"macula_http3_mesh_quick_start.html#create-configuration-file-2"},{"type":"extras","title":"Start Node 3 (in new terminal) - Quick Start","doc":"```bash\n# Open new terminal\ncd ~/projects/macula\n\n# Erlang\nerl -config config/node3 -pa _build/default/lib/*/ebin -eval 'application:ensure_all_started(macula).'\n\n# Elixir\niex --name node3@127.0.0.1 --cookie macula_demo -S mix run -e 'Application.ensure_all_started(:macula)' -- --config config/node3.config\n```\n\n**Expected output**:\n```\n[info] Macula node started: node3\n[info] Listening on 0.0.0.0:4435 (UDP)\n[info] Node ID: c8d4e9f3a6b2c7d1...\n[info] Realm: org.example.mesh\n[info] Connecting to bootstrap nodes...\n[info] Connected to node1 (a3f5b2e1c4d8a7f9...)\n[info] Connected to node2 (b7c3d8e2f5a9b4c1...)\n[info] SWIM membership: 3 nodes alive\n[info] Mesh topology: k_regular (k=2)\n[info] Routing table: 3 nodes\n```\n\n**Congratulations!** You now have a 3-node mesh network running.\n\n---","ref":"macula_http3_mesh_quick_start.html#start-node-3-in-new-terminal"},{"type":"extras","title":"Step 5: Verify Mesh Topology - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-5-verify-mesh-topology"},{"type":"extras","title":"Check Membership (on any node) - Quick Start","doc":"In any node's console:\n\n```erlang\n% Erlang\nmacula_membership:get_members().\n\n% Expected output:\n[\n  #{node_id => <<\"a3f5b2e1...\">>, state => alive, ...},\n  #{node_id => <<\"b7c3d8e2...\">>, state => alive, ...},\n  #{node_id => <<\"c8d4e9f3...\">>, state => alive, ...}\n]\n```\n\n```elixir\n# Elixir\nMacula.Membership.get_members()\n\n# Expected output:\n[\n  %{node_id: \"a3f5b2e1...\", state: :alive, ...},\n  %{node_id: \"b7c3d8e2...\", state: :alive, ...},\n  %{node_id: \"c8d4e9f3...\", state: :alive, ...}\n]\n```","ref":"macula_http3_mesh_quick_start.html#check-membership-on-any-node"},{"type":"extras","title":"Check Connections - Quick Start","doc":"```erlang\n% Erlang\nmacula_topology:get_connections().\n\n% Expected output:\n[\n  #{peer_id => <<\"b7c3d8e2...\">>, state => active, rtt_ms => 1.2},\n  #{peer_id => <<\"c8d4e9f3...\">>, state => active, rtt_ms => 1.5}\n]\n```","ref":"macula_http3_mesh_quick_start.html#check-connections"},{"type":"extras","title":"Visualize Topology (ASCII Art) - Quick Start","doc":"```erlang\n% Erlang\nmacula_topology:print_topology().\n```\n\n**Expected output**:\n```\nMesh Topology (k-regular, k=2)\n==============================\n\nnode1 (a3f5...)  node2 (b7c3...)\n                       \n   node3 (c8d4...)\n                       \n                        node1\n\n3 nodes, 3 connections\nAverage RTT: 1.3ms\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#visualize-topology-ascii-art"},{"type":"extras","title":"Step 6: Send Your First Message (Pub/Sub) - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-6-send-your-first-message-pub-sub"},{"type":"extras","title":"Subscribe to a Topic (on Node 3) - Quick Start","doc":"In Node 3's console:\n\n```erlang\n% Erlang\nSubscriber = spawn(fun() ->\n  receive\n    {event, Topic, Msg} ->\n      io:format(\"Received on ~s: ~p~n\", [Topic, Msg])\n  end\nend).\n\nmacula_pubsub:subscribe(<<\"hello.world\">>, Subscriber).\n```\n\n```elixir\n# Elixir\npid = spawn(fn ->\n  receive do\n    {:event, topic, msg} ->\n      IO.puts(\"Received on #{topic}: #{inspect(msg)}\")\n  end\nend)\n\nMacula.PubSub.subscribe(\"hello.world\", pid)\n```\n\n**Expected output**:\n```\n[info] Subscribed to org.example.mesh.hello.world\nok\n```","ref":"macula_http3_mesh_quick_start.html#subscribe-to-a-topic-on-node-3"},{"type":"extras","title":"Publish a Message (on Node 1) - Quick Start","doc":"In Node 1's console:\n\n```erlang\n% Erlang\nmacula_pubsub:publish(<<\"hello.world\">>, #{\n  message => <<\"Hello from Node 1!\">>,\n  timestamp => erlang:system_time(millisecond)\n}).\n```\n\n```elixir\n# Elixir\nMacula.PubSub.publish(\"hello.world\", %{\n  message: \"Hello from Node 1!\",\n  timestamp: System.system_time(:millisecond)\n})\n```\n\n**Expected output on Node 1**:\n```\n[info] Published to org.example.mesh.hello.world\nok\n```\n\n**Expected output on Node 3** (subscriber):\n```\nReceived on org.example.mesh.hello.world: #{\n  message => <<\"Hello from Node 1!\">>,\n  timestamp => 1704723456789,\n  publisher => <<\"a3f5b2e1...\">>\n}\n```\n\n**Message flow**: Node 1  QUIC/HTTP3  Node 3 (may route via Node 2 depending on topology)\n\n---","ref":"macula_http3_mesh_quick_start.html#publish-a-message-on-node-1"},{"type":"extras","title":"Step 7: Make Your First RPC Call - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-7-make-your-first-rpc-call"},{"type":"extras","title":"Register RPC Endpoint (on Node 2) - Quick Start","doc":"In Node 2's console:\n\n```erlang\n% Erlang\nEchoHandler = fun(Args) ->\n  {ok, #{echo => Args, node => node()}}\nend.\n\nmacula_rpc:register(<<\"echo_service\">>, EchoHandler).\n```\n\n```elixir\n# Elixir\necho_handler = fn args ->\n  {:ok, %{echo: args, node: Node.self()}}\nend\n\nMacula.RPC.register(\"echo_service\", echo_handler)\n```\n\n**Expected output**:\n```\n[info] Registered RPC endpoint: org.example.mesh.echo_service\nok\n```","ref":"macula_http3_mesh_quick_start.html#register-rpc-endpoint-on-node-2"},{"type":"extras","title":"Call RPC (from Node 1) - Quick Start","doc":"In Node 1's console:\n\n```erlang\n% Erlang\nmacula_rpc:call(<<\"echo_service\">>, #{\n  test => <<\"Hello RPC!\">>,\n  value => 42\n}, 5000).  % 5 second timeout\n```\n\n```elixir\n# Elixir\nMacula.RPC.call(\"echo_service\", %{\n  test: \"Hello RPC!\",\n  value: 42\n}, 5000)\n```\n\n**Expected output on Node 1**:\n```\n{ok, #{\n  echo => #{test => <<\"Hello RPC!\">>, value => 42},\n  node => 'node2@127.0.0.1'\n}}\n```\n\n**Expected output on Node 2** (handler):\n```\n[info] RPC call received: echo_service\n[info] Args: #{test => <<\"Hello RPC!\">>, value => 42}\n```\n\n**RPC flow**: Node 1  finds registration via DHT  routes to Node 2  executes handler  returns result\n\n---","ref":"macula_http3_mesh_quick_start.html#call-rpc-from-node-1"},{"type":"extras","title":"Step 8: Test Fault Tolerance - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#step-8-test-fault-tolerance"},{"type":"extras","title":"Stop Node 2 - Quick Start","doc":"In Node 2's terminal, press `Ctrl+C` twice to stop the node.\n\n**Expected output on Node 1 and Node 3**:\n```\n[warning] Connection lost to node2 (b7c3d8e2...)\n[info] SWIM detected failure: node2\n[info] SWIM membership: 2 nodes alive, 1 suspect\n[info] Topology reconfiguring...\n[info] New connection established: node1  node3\n[info] SWIM membership: 2 nodes alive\n```","ref":"macula_http3_mesh_quick_start.html#stop-node-2"},{"type":"extras","title":"Verify Mesh Adapted - Quick Start","doc":"On Node 1 or Node 3:\n\n```erlang\n% Erlang\nmacula_topology:get_connections().\n\n% Expected output (now only 1 connection):\n[\n  #{peer_id => <<\"c8d4e9f3...\">>, state => active, rtt_ms => 1.1}\n]\n```\n\nThe mesh **automatically adapts** - Node 1 and Node 3 now connect directly.","ref":"macula_http3_mesh_quick_start.html#verify-mesh-adapted"},{"type":"extras","title":"Restart Node 2 - Quick Start","doc":"Restart Node 2 (using the same command from Step 3).\n\n**Expected output**:\n```\n[info] Macula node started: node2\n[info] Reconnecting to mesh...\n[info] SWIM membership: 3 nodes alive\n[info] Topology restored\n```\n\nThe mesh **self-heals** automatically.\n\n---","ref":"macula_http3_mesh_quick_start.html#restart-node-2"},{"type":"extras","title":"Common Operations - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#common-operations"},{"type":"extras","title":"List All Nodes in Mesh - Quick Start","doc":"```erlang\n% Erlang\nmacula_membership:list_nodes().\n```\n\n```elixir\n# Elixir\nMacula.Membership.list_nodes()\n```","ref":"macula_http3_mesh_quick_start.html#list-all-nodes-in-mesh"},{"type":"extras","title":"Get Node Statistics - Quick Start","doc":"```erlang\n% Erlang\nmacula:stats().\n\n% Output:\n#{\n  messages_sent => 1543,\n  messages_received => 1687,\n  bytes_sent => 245678,\n  bytes_received => 267890,\n  active_connections => 2,\n  routing_table_size => 3,\n  uptime_seconds => 3600\n}\n```","ref":"macula_http3_mesh_quick_start.html#get-node-statistics"},{"type":"extras","title":"Subscribe with Pattern Matching - Quick Start","doc":"```erlang\n% Erlang - Subscribe to all topics starting with \"sensor.\"\nmacula_pubsub:subscribe(<<\"sensor.*\">>, Pid, #{match => prefix}).\n\n% Matches: sensor.temperature, sensor.humidity, etc.\n```","ref":"macula_http3_mesh_quick_start.html#subscribe-with-pattern-matching"},{"type":"extras","title":"Publish with Options - Quick Start","doc":"```erlang\n% Erlang - Publish with acknowledgment\nmacula_pubsub:publish(<<\"important.event\">>, Data, #{\n  acknowledge => true,  % Wait for delivery confirmation\n  retain => true        % Store for late subscribers\n}).\n```\n\n---","ref":"macula_http3_mesh_quick_start.html#publish-with-options"},{"type":"extras","title":"Troubleshooting - Quick Start","doc":"","ref":"macula_http3_mesh_quick_start.html#troubleshooting"},{"type":"extras","title":"Problem: \"Port already in use\" - Quick Start","doc":"**Error**:\n```\n{error, eaddrinuse}\n```\n\n**Solution**: Change the `listen_port` in your config file to an unused port (e.g., 4436, 4437).\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-port-already-in-use"},{"type":"extras","title":"Problem: Nodes can't discover each other - Quick Start","doc":"**Symptoms**: Node 2 or 3 logs show \"Connection timeout\" or \"No route to bootstrap node\"\n\n**Checks**:\n1. **Firewall**: Ensure UDP port 4433-4435 are not blocked\n   ```bash\n   # Ubuntu/Debian\n   sudo ufw allow 4433:4435/udp\n\n   # macOS\n   # Check System Preferences  Security & Privacy  Firewall\n   ```\n\n2. **Correct IP address**: If running on different machines, replace `127.0.0.1` with actual IP\n   ```bash\n   # Find your IP\n   ip addr show  # Linux\n   ifconfig      # macOS\n   ```\n\n3. **Same realm**: All nodes must have the same `realm` in config\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-nodes-can-t-discover-each-other"},{"type":"extras","title":"Problem: \"Certificate validation failed\" - Quick Start","doc":"**Error**:\n```\n{error, {tls_alert, \"certificate unknown\"}}\n```\n\n**Cause**: Certificate mismatch (usually in manual cert mode)\n\n**Solution**: Use `{cert_mode, auto_generate}` for development, or ensure all nodes trust the same CA.\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-certificate-validation-failed"},{"type":"extras","title":"Problem: High latency or packet loss - Quick Start","doc":"**Check network conditions**:\n```erlang\n% Erlang\nmacula_connection:ping(<<\"node2_id\">>).\n\n% Output:\n{ok, 1.2}  % RTT in milliseconds\n```\n\nIf RTT > 100ms on localhost, check:\n- System load (CPU usage)\n- Other applications using network\n- Docker/VM networking overhead\n\n---","ref":"macula_http3_mesh_quick_start.html#problem-high-latency-or-packet-loss"},{"type":"extras","title":"Next Steps - Quick Start","doc":"Congratulations! You've successfully:\n-  Built Macula from source\n-  Started a 3-node mesh network\n-  Verified mesh topology\n-  Sent pub/sub messages across the mesh\n-  Made RPC calls between nodes\n-  Tested fault tolerance and self-healing","ref":"macula_http3_mesh_quick_start.html#next-steps"},{"type":"extras","title":"Learn More - Quick Start","doc":"- **[Hello World Tutorial](macula_http3_mesh_hello_world.md)** - Build a complete application\n- **[API Reference](macula_http3_mesh_api_reference.md)** - Complete API documentation\n- **[Deployment Patterns](macula_http3_mesh_deployment_patterns.md)** - Production deployments\n- **[Performance Tuning](macula_http3_mesh_performance.md)** - Optimize for your use case","ref":"macula_http3_mesh_quick_start.html#learn-more"},{"type":"extras","title":"Try More Advanced Features - Quick Start","doc":"1. **Realm isolation**: Start nodes in different realms and use gateways\n2. **NAT traversal**: Run nodes on different networks (home, cloud, mobile)\n3. **Large mesh**: Scale to 10+ nodes and observe routing behavior\n4. **Persistence**: Add event sourcing with persistent subscriptions\n5. **Monitoring**: Set up Prometheus metrics and Grafana dashboards","ref":"macula_http3_mesh_quick_start.html#try-more-advanced-features"},{"type":"extras","title":"Join the Community - Quick Start","doc":"- **GitHub**: https://github.com/macula-io/macula\n- **Discord**: https://discord.gg/macula\n- **Docs**: https://docs.macula.io\n\n---\n\n**Happy meshing!** ","ref":"macula_http3_mesh_quick_start.html#join-the-community"},{"type":"extras","title":"Hello World","doc":"# Macula HTTP/3 Mesh - Hello World Tutorial\n\n**Build your first distributed application on Macula**\n\n---","ref":"macula_http3_mesh_hello_world.html"},{"type":"extras","title":"What We'll Build - Hello World","doc":"A **distributed chat application** where:\n- Multiple nodes can join a chat room\n- Users can send messages that appear on all nodes\n- Messages are routed via the Macula mesh (pub/sub)\n- Users can query \"who's online\" (RPC call)\n- Graceful handling of nodes joining/leaving\n\n**Time to complete**: 30 minutes\n\n**Prerequisites**:\n- Completed [Quick Start Guide](macula_http3_mesh_quick_start.md)\n- Basic Erlang or Elixir knowledge\n- Macula installed and working\n\n---","ref":"macula_http3_mesh_hello_world.html#what-we-ll-build"},{"type":"extras","title":"Project Structure - Hello World","doc":"We'll create a new Mix (Elixir) or Rebar3 (Erlang) project:\n\n```\nmacula_chat/\n config/\n    config.exs          # Application configuration\n lib/\n    macula_chat.ex      # Application entry point\n    chat_room.ex        # Chat room GenServer\n    chat_client.ex      # User client\n mix.exs                 # Project definition\n README.md\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#project-structure"},{"type":"extras","title":"Step 1: Create New Project - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-1-create-new-project"},{"type":"extras","title":"Using Mix (Elixir) - Hello World","doc":"```bash\nmix new macula_chat --sup\ncd macula_chat\n```","ref":"macula_http3_mesh_hello_world.html#using-mix-elixir"},{"type":"extras","title":"Using Rebar3 (Erlang) - Hello World","doc":"```bash\nrebar3 new app macula_chat\ncd macula_chat\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#using-rebar3-erlang"},{"type":"extras","title":"Step 2: Add Macula Dependency - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-2-add-macula-dependency"},{"type":"extras","title":"Mix (Elixir) - Hello World","doc":"Edit `mix.exs`:\n\n```elixir\ndefmodule MaculaChat.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      app: :macula_chat,\n      version: \"0.1.0\",\n      elixir: \"~> 1.15\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps()\n    ]\n  end\n\n  def application do\n    [\n      extra_applications: [:logger],\n      mod: {MaculaChat.Application, []}\n    ]\n  end\n\n  defp deps do\n    [\n      {:macula, git: \"https://github.com/macula-io/macula.git\", branch: \"main\"}\n    ]\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#mix-elixir"},{"type":"extras","title":"Rebar3 (Erlang) - Hello World","doc":"Edit `rebar.config`:\n\n```erlang\n{erl_opts, [debug_info]}.\n\n{deps, [\n    {macula, {git, \"https://github.com/macula-io/macula.git\", {branch, \"main\"}}}\n]}.\n\n{shell, [\n    {apps, [macula_chat]}\n]}.\n```","ref":"macula_http3_mesh_hello_world.html#rebar3-erlang"},{"type":"extras","title":"Install Dependencies - Hello World","doc":"```bash\n# Mix\nmix deps.get\n\n# Rebar3\nrebar3 get-deps\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#install-dependencies"},{"type":"extras","title":"Step 3: Configure Macula - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-3-configure-macula"},{"type":"extras","title":"Mix Configuration - Hello World","doc":"Create `config/config.exs`:\n\n```elixir\nimport Config\n\nconfig :macula,\n  realm: \"io.macula.chat\",\n  listen_port: System.get_env(\"MACULA_PORT\", \"4433\") |> String.to_integer(),\n  discovery: [\n    methods: [:static, :mdns],\n    static_nodes: []  # Add bootstrap nodes via env var\n  ],\n  topology: [\n    type: :k_regular,\n    k: 2\n  ],\n  cert_mode: :auto_generate,\n  log_level: :info\n\n# Chat-specific config\nconfig :macula_chat,\n  username: System.get_env(\"CHAT_USER\", \"Anonymous\"),\n  room: System.get_env(\"CHAT_ROOM\", \"general\")\n```","ref":"macula_http3_mesh_hello_world.html#mix-configuration"},{"type":"extras","title":"Rebar3 Configuration - Hello World","doc":"Create `config/sys.config`:\n\n```erlang\n[\n {macula, [\n   {realm, <<\"io.macula.chat\">>},\n   {listen_port, 4433},\n   {discovery, [\n     {methods, [static, mdns]},\n     {static_nodes, []}\n   ]},\n   {topology, [\n     {type, k_regular},\n     {k, 2}\n   ]},\n   {cert_mode, auto_generate},\n   {log_level, info}\n ]},\n\n {macula_chat, [\n   {username, <<\"Anonymous\">>},\n   {room, <<\"general\">>}\n ]}\n].\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#rebar3-configuration"},{"type":"extras","title":"Step 4: Implement Chat Room - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-4-implement-chat-room"},{"type":"extras","title":"Elixir Implementation - Hello World","doc":"Create `lib/chat_room.ex`:\n\n```elixir\ndefmodule MaculaChat.ChatRoom do\n  @moduledoc \"\"\"\n  Chat room GenServer that handles:\n  - Subscribing to chat messages\n  - Publishing messages to the room\n  - Tracking online users\n  \"\"\"\n\n  use GenServer\n  require Logger\n\n  @topic_prefix \"io.macula.chat.room\"","ref":"macula_http3_mesh_hello_world.html#elixir-implementation"},{"type":"extras","title":"Client API - Hello World","doc":"def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @doc \"Send a message to the chat room\"\n  def send_message(message) do\n    GenServer.cast(__MODULE__, {:send_message, message})\n  end\n\n  @doc \"Get list of online users (RPC)\"\n  def get_online_users do\n    GenServer.call(__MODULE__, :get_online_users)\n  end\n\n  @doc \"Join a chat room\"\n  def join_room(room_name) do\n    GenServer.call(__MODULE__, {:join_room, room_name})\n  end","ref":"macula_http3_mesh_hello_world.html#client-api"},{"type":"extras","title":"Server Callbacks - Hello World","doc":"def init(opts) do\n    username = Keyword.get(opts, :username, \"Anonymous\")\n    room = Keyword.get(opts, :room, \"general\")\n\n    state = %{\n      username: username,\n      room: room,\n      topic: \"#{@topic_prefix}.#{room}\",\n      presence_topic: \"#{@topic_prefix}.#{room}.presence\",\n      online_users: %{}\n    }\n\n    # Subscribe to room messages\n    :ok = Macula.PubSub.subscribe(state.topic, self())\n\n    # Subscribe to presence (join/leave notifications)\n    :ok = Macula.PubSub.subscribe(state.presence_topic, self())\n\n    # Register RPC endpoint for \"who's online\"\n    rpc_name = \"chat.#{room}.users\"\n    :ok = Macula.RPC.register(rpc_name, fn _ ->\n      {:ok, Map.keys(state.online_users)}\n    end)\n\n    # Announce presence\n    announce_join(state)\n\n    # Schedule periodic presence heartbeat\n    schedule_heartbeat()\n\n    Logger.info(\"Joined chat room: #{room} as #{username}\")\n\n    {:ok, state}\n  end\n\n  def handle_call(:get_online_users, _from, state) do\n    users = Map.keys(state.online_users)\n    {:reply, {:ok, users}, state}\n  end\n\n  def handle_call({:join_room, new_room}, _from, state) do\n    # Unsubscribe from old room\n    Macula.PubSub.unsubscribe(state.topic, self())\n    Macula.PubSub.unsubscribe(state.presence_topic, self())\n\n    # Announce leave\n    announce_leave(state)\n\n    # Update state\n    new_state = %{state |\n      room: new_room,\n      topic: \"#{@topic_prefix}.#{new_room}\",\n      presence_topic: \"#{@topic_prefix}.#{new_room}.presence\",\n      online_users: %{}\n    }\n\n    # Subscribe to new room\n    :ok = Macula.PubSub.subscribe(new_state.topic, self())\n    :ok = Macula.PubSub.subscribe(new_state.presence_topic, self())\n\n    # Announce join\n    announce_join(new_state)\n\n    Logger.info(\"Switched to chat room: #{new_room}\")\n\n    {:reply, :ok, new_state}\n  end\n\n  def handle_cast({:send_message, message}, state) do\n    # Publish message to room\n    payload = %{\n      username: state.username,\n      message: message,\n      timestamp: System.system_time(:millisecond),\n      node_id: Macula.node_id()\n    }\n\n    :ok = Macula.PubSub.publish(state.topic, payload)\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :message} = event}, state) do\n    # Received chat message\n    username = event.username\n    message = event.message\n    timestamp = event.timestamp\n\n    # Format timestamp\n    {:ok, dt} = DateTime.from_unix(timestamp, :millisecond)\n    time_str = Calendar.strftime(dt, \"%H:%M:%S\")\n\n    # Print to console\n    IO.puts(\"[#{time_str}] <#{username}> #{message}\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :join} = event}, state) do\n    # User joined\n    username = event.username\n    node_id = event.node_id\n\n    state = put_in(state.online_users[username], node_id)\n\n    Logger.info(\"#{username} joined the room\")\n    IO.puts(\"*** #{username} joined the room\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :leave} = event}, state) do\n    # User left\n    username = event.username\n\n    {_node_id, state} = pop_in(state.online_users[username])\n\n    Logger.info(\"#{username} left the room\")\n    IO.puts(\"*** #{username} left the room\")\n\n    {:noreply, state}\n  end\n\n  def handle_info({:event, _topic, %{type: :heartbeat} = event}, state) do\n    # Presence heartbeat\n    username = event.username\n    node_id = event.node_id\n\n    state = put_in(state.online_users[username], node_id)\n\n    {:noreply, state}\n  end\n\n  def handle_info(:send_heartbeat, state) do\n    announce_heartbeat(state)\n    schedule_heartbeat()\n    {:noreply, state}\n  end","ref":"macula_http3_mesh_hello_world.html#server-callbacks"},{"type":"extras","title":"Private Functions - Hello World","doc":"defp announce_join(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :join,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp announce_leave(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :leave,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp announce_heartbeat(state) do\n    Macula.PubSub.publish(state.presence_topic, %{\n      type: :heartbeat,\n      username: state.username,\n      node_id: Macula.node_id(),\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n\n  defp schedule_heartbeat do\n    Process.send_after(self(), :send_heartbeat, 30_000)  # Every 30 seconds\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#private-functions"},{"type":"extras","title":"Erlang Implementation - Hello World","doc":"Create `src/chat_room.erl`:\n\n```erlang\n-module(chat_room).\n-behaviour(gen_server).\n\n-export([start_link/1, send_message/1, get_online_users/0, join_room/1]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-define(TOPIC_PREFIX, <<\"io.macula.chat.room\">>).\n\n%% Client API\n\nstart_link(Opts) ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, Opts, []).\n\nsend_message(Message) ->\n    gen_server:cast(?MODULE, {send_message, Message}).\n\nget_online_users() ->\n    gen_server:call(?MODULE, get_online_users).\n\njoin_room(RoomName) ->\n    gen_server:call(?MODULE, {join_room, RoomName}).\n\n%% Server Callbacks\n\ninit(Opts) ->\n    Username = proplists:get_value(username, Opts, <<\"Anonymous\">>),\n    Room = proplists:get_value(room, Opts, <<\"general\">>),\n\n    Topic = <<?TOPIC_PREFIX/binary, \".\", Room/binary>>,\n    PresenceTopic = < >,\n\n    State = #{\n        username => Username,\n        room => Room,\n        topic => Topic,\n        presence_topic => PresenceTopic,\n        online_users => #{}\n    },\n\n    %% Subscribe to room messages\n    ok = macula_pubsub:subscribe(Topic, self()),\n    ok = macula_pubsub:subscribe(PresenceTopic, self()),\n\n    %% Register RPC endpoint\n    RpcName = <<\"chat.\", Room/binary, \".users\">>,\n    ok = macula_rpc:register(RpcName, fun(_Args) ->\n        {ok, maps:keys(maps:get(online_users, State))}\n    end),\n\n    %% Announce presence\n    announce_join(State),\n\n    %% Schedule heartbeat\n    schedule_heartbeat(),\n\n    logger:info(\"Joined chat room: ~s as ~s\", [Room, Username]),\n\n    {ok, State}.\n\nhandle_call(get_online_users, _From, State) ->\n    Users = maps:keys(maps:get(online_users, State)),\n    {reply, {ok, Users}, State};\n\nhandle_call({join_room, NewRoom}, _From, State) ->\n    %% Unsubscribe from old room\n    macula_pubsub:unsubscribe(maps:get(topic, State), self()),\n    macula_pubsub:unsubscribe(maps:get(presence_topic, State), self()),\n\n    %% Announce leave\n    announce_leave(State),\n\n    %% Update state\n    NewTopic = <<?TOPIC_PREFIX/binary, \".\", NewRoom/binary>>,\n    NewPresenceTopic = < >,\n\n    NewState = State#{\n        room => NewRoom,\n        topic => NewTopic,\n        presence_topic => NewPresenceTopic,\n        online_users => #{}\n    },\n\n    %% Subscribe to new room\n    ok = macula_pubsub:subscribe(NewTopic, self()),\n    ok = macula_pubsub:subscribe(NewPresenceTopic, self()),\n\n    %% Announce join\n    announce_join(NewState),\n\n    logger:info(\"Switched to chat room: ~s\", [NewRoom]),\n\n    {reply, ok, NewState}.\n\nhandle_cast({send_message, Message}, State) ->\n    Payload = #{\n        type => message,\n        username => maps:get(username, State),\n        message => Message,\n        timestamp => erlang:system_time(millisecond),\n        node_id => macula:node_id()\n    },\n\n    ok = macula_pubsub:publish(maps:get(topic, State), Payload),\n\n    {noreply, State}.\n\nhandle_info({event, _Topic, #{type := message} = Event}, State) ->\n    Username = maps:get(username, Event),\n    Message = maps:get(message, Event),\n    Timestamp = maps:get(timestamp, Event),\n\n    %% Print to console\n    {{Y,M,D},{H,Min,S}} = calendar:system_time_to_universal_time(Timestamp, millisecond),\n    io:format(\"[~2..0B:~2..0B:~2..0B] <~s> ~s~n\", [H, Min, S, Username, Message]),\n\n    {noreply, State};\n\nhandle_info({event, _Topic, #{type := join} = Event}, State) ->\n    Username = maps:get(username, Event),\n    NodeId = maps:get(node_id, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:put(Username, NodeId, OnlineUsers),\n\n    io:format(\"*** ~s joined the room~n\", [Username]),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info({event, _Topic, #{type := leave} = Event}, State) ->\n    Username = maps:get(username, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:remove(Username, OnlineUsers),\n\n    io:format(\"*** ~s left the room~n\", [Username]),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info({event, _Topic, #{type := heartbeat} = Event}, State) ->\n    Username = maps:get(username, Event),\n    NodeId = maps:get(node_id, Event),\n\n    OnlineUsers = maps:get(online_users, State),\n    NewOnlineUsers = maps:put(Username, NodeId, OnlineUsers),\n\n    {noreply, State#{online_users => NewOnlineUsers}};\n\nhandle_info(send_heartbeat, State) ->\n    announce_heartbeat(State),\n    schedule_heartbeat(),\n    {noreply, State}.\n\n%% Private Functions\n\nannounce_join(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => join,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nannounce_leave(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => leave,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nannounce_heartbeat(State) ->\n    macula_pubsub:publish(maps:get(presence_topic, State), #{\n        type => heartbeat,\n        username => maps:get(username, State),\n        node_id => macula:node_id(),\n        timestamp => erlang:system_time(millisecond)\n    }).\n\nschedule_heartbeat() ->\n    erlang:send_after(30000, self(), send_heartbeat).\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang-implementation"},{"type":"extras","title":"Step 5: Update Application Supervisor - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-5-update-application-supervisor"},{"type":"extras","title":"Elixir - Hello World","doc":"Edit `lib/macula_chat/application.ex`:\n\n```elixir\ndefmodule MaculaChat.Application do\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    # Get config\n    username = Application.get_env(:macula_chat, :username, \"Anonymous\")\n    room = Application.get_env(:macula_chat, :room, \"general\")\n\n    children = [\n      # Start Macula mesh\n      {Macula, []},\n\n      # Start chat room\n      {MaculaChat.ChatRoom, [username: username, room: room]}\n    ]\n\n    opts = [strategy: :one_for_one, name: MaculaChat.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend\n```","ref":"macula_http3_mesh_hello_world.html#elixir"},{"type":"extras","title":"Erlang - Hello World","doc":"Edit `src/macula_chat_app.erl`:\n\n```erlang\n-module(macula_chat_app).\n-behaviour(application).\n\n-export([start/2, stop/1]).\n\nstart(_StartType, _StartArgs) ->\n    %% Get config\n    {ok, Username} = application:get_env(macula_chat, username),\n    {ok, Room} = application:get_env(macula_chat, room),\n\n    Children = [\n        %% Start Macula mesh\n        #{\n            id => macula,\n            start => {macula, start_link, []},\n            restart => permanent,\n            type => supervisor\n        },\n\n        %% Start chat room\n        #{\n            id => chat_room,\n            start => {chat_room, start_link, [[{username, Username}, {room, Room}]]},\n            restart => permanent,\n            type => worker\n        }\n    ],\n\n    SupFlags = #{strategy => one_for_one, intensity => 1, period => 5},\n\n    supervisor:start_link({local, macula_chat_sup}, ?MODULE, {SupFlags, Children}).\n\nstop(_State) ->\n    ok.\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang"},{"type":"extras","title":"Step 6: Create Interactive Client - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-6-create-interactive-client"},{"type":"extras","title":"Elixir - Hello World","doc":"Create `lib/chat_client.ex`:\n\n```elixir\ndefmodule MaculaChat.Client do\n  @moduledoc \"\"\"\n  Interactive chat client - run from IEx\n  \"\"\"\n\n  @doc \"Send a message to the chat room\"\n  def say(message) when is_binary(message) do\n    MaculaChat.ChatRoom.send_message(message)\n    :ok\n  end\n\n  @doc \"List who's online\"\n  def who do\n    {:ok, users} = MaculaChat.ChatRoom.get_online_users()\n    IO.puts(\"\\nOnline users (#{length(users)}):\")\n    Enum.each(users, fn user ->\n      IO.puts(\"  - #{user}\")\n    end)\n    :ok\n  end\n\n  @doc \"Switch to different room\"\n  def join(room_name) when is_binary(room_name) do\n    :ok = MaculaChat.ChatRoom.join_room(room_name)\n    IO.puts(\"Joined room: #{room_name}\")\n    :ok\n  end\n\n  @doc \"Show help\"\n  def help do\n    IO.puts(\"\"\"\n\n    Macula Chat Client Commands:\n    =============================\n\n    Chat.say(\"message\")     - Send a message\n    Chat.who()              - List online users\n    Chat.join(\"room\")       - Switch to different room\n    Chat.help()             - Show this help\n\n    Examples:\n      Chat.say(\"Hello world!\")\n      Chat.who()\n      Chat.join(\"random\")\n\n    \"\"\")\n    :ok\n  end\nend\n\n# Alias for convenience\nalias MaculaChat.Client, as: Chat\n```","ref":"macula_http3_mesh_hello_world.html#elixir-1"},{"type":"extras","title":"Erlang - Hello World","doc":"Create `src/chat_client.erl`:\n\n```erlang\n-module(chat_client).\n-export([say/1, who/0, join/1, help/0]).\n\nsay(Message) when is_binary(Message) ->\n    chat_room:send_message(Message),\n    ok.\n\nwho() ->\n    {ok, Users} = chat_room:get_online_users(),\n    io:format(\"~nOnline users (~p):~n\", [length(Users)]),\n    lists:foreach(fun(User) ->\n        io:format(\"  - ~s~n\", [User])\n    end, Users),\n    ok.\n\njoin(RoomName) when is_binary(RoomName) ->\n    ok = chat_room:join_room(RoomName),\n    io:format(\"Joined room: ~s~n\", [RoomName]),\n    ok.\n\nhelp() ->\n    io:format(\"~n~s~n\", [\n        \"Macula Chat Client Commands:\\n\"\n        \"=============================\\n\"\n        \"\\n\"\n        \"chat_client:say(<<\\\"message\\\">>)     - Send a message\\n\"\n        \"chat_client:who()                   - List online users\\n\"\n        \"chat_client:join(<<\\\"room\\\">>)        - Switch to different room\\n\"\n        \"chat_client:help()                  - Show this help\\n\"\n        \"\\n\"\n        \"Examples:\\n\"\n        \"  chat_client:say(<<\\\"Hello world!\\\">>).\\n\"\n        \"  chat_client:who().\\n\"\n        \"  chat_client:join(<<\\\"random\\\">>).\\n\"\n    ]),\n    ok.\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#erlang-1"},{"type":"extras","title":"Step 7: Run the Chat Application - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-7-run-the-chat-application"},{"type":"extras","title":"Terminal 1: User \"Alice\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Alice CHAT_ROOM=general MACULA_PORT=4433 iex -S mix\n\n# Erlang\nCHAT_USER=Alice CHAT_ROOM=general MACULA_PORT=4433 rebar3 shell\n\n# You should see:\n[info] Macula node started\n[info] Joined chat room: general as Alice\n```","ref":"macula_http3_mesh_hello_world.html#terminal-1-user-alice"},{"type":"extras","title":"Terminal 2: User \"Bob\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Bob CHAT_ROOM=general MACULA_PORT=4434 iex -S mix\n\n# Erlang\nCHAT_USER=Bob CHAT_ROOM=general MACULA_PORT=4434 rebar3 shell\n\n# Both terminals show:\n*** Bob joined the room\n```","ref":"macula_http3_mesh_hello_world.html#terminal-2-user-bob"},{"type":"extras","title":"Terminal 3: User \"Charlie\" - Hello World","doc":"```bash\n# Elixir\nCHAT_USER=Charlie CHAT_ROOM=general MACULA_PORT=4435 iex -S mix\n\n# Erlang\nCHAT_USER=Charlie CHAT_ROOM=general MACULA_PORT=4435 rebar3 shell\n\n# All terminals show:\n*** Charlie joined the room\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#terminal-3-user-charlie"},{"type":"extras","title":"Step 8: Chat! - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-8-chat"},{"type":"extras","title":"Send Messages - Hello World","doc":"**In Alice's terminal (Elixir)**:\n```elixir\nChat.say(\"Hello everyone!\")\n```\n\n**In Bob's terminal (Erlang)**:\n```erlang\nchat_client:say(<<\"Hey Alice!\">>).\n```\n\n**In Charlie's terminal**:\n```elixir\nChat.say(\"What's up?\")\n```\n\n**All terminals show**:\n```\n[12:34:56]   Hello everyone!\n[12:34:58]   Hey Alice!\n[12:35:01]   What's up?\n```","ref":"macula_http3_mesh_hello_world.html#send-messages"},{"type":"extras","title":"List Online Users - Hello World","doc":"**In any terminal (Elixir)**:\n```elixir\nChat.who()\n```\n\n**Output**:\n```\nOnline users (3):\n  - Alice\n  - Bob\n  - Charlie\n```","ref":"macula_http3_mesh_hello_world.html#list-online-users"},{"type":"extras","title":"Switch Rooms - Hello World","doc":"**In Charlie's terminal**:\n```elixir\nChat.join(\"random\")\n```\n\n**Alice and Bob's terminals show**:\n```\n*** Charlie left the room\n```\n\n**Charlie's terminal shows**:\n```\nJoined room: random\n```\n\nNow Charlie is in a different room and won't see messages in \"general\".\n\n---","ref":"macula_http3_mesh_hello_world.html#switch-rooms"},{"type":"extras","title":"Step 9: Test Fault Tolerance - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#step-9-test-fault-tolerance"},{"type":"extras","title":"Stop Bob's Node - Hello World","doc":"In Bob's terminal, press `Ctrl+C` twice.\n\n**Alice and Charlie's terminals show**:\n```\n*** Bob left the room\n```","ref":"macula_http3_mesh_hello_world.html#stop-bob-s-node"},{"type":"extras","title":"Restart Bob - Hello World","doc":"Restart Bob's node (same command as before).\n\n**All terminals show**:\n```\n*** Bob joined the room\n```\n\n**Messages continue flowing** - the mesh automatically reconnected Bob.\n\n---","ref":"macula_http3_mesh_hello_world.html#restart-bob"},{"type":"extras","title":"Understanding the Architecture - Hello World","doc":"","ref":"macula_http3_mesh_hello_world.html#understanding-the-architecture"},{"type":"extras","title":"Message Flow (Pub/Sub) - Hello World","doc":"```\nAlice's Node                   Macula Mesh                   Bob's Node\n                            \n Chat.say()   publish    Topic:     route  handle_info  \n                             io.macula.                 {:event,...} \n                             chat.room.                              \n                             general                    IO.puts()    \n                            \n```\n\n**How it works**:\n1. Alice calls `Chat.say(\"hello\")`\n2. ChatRoom GenServer calls `Macula.PubSub.publish(topic, %{message: \"hello\"})`\n3. Macula encodes the message and sends it via QUIC to subscribers\n4. Bob's ChatRoom GenServer receives `{:event, topic, payload}`\n5. Bob's node prints the message to console\n\n**No central server** - messages route peer-to-peer through the mesh!","ref":"macula_http3_mesh_hello_world.html#message-flow-pub-sub"},{"type":"extras","title":"RPC Flow (Who's Online) - Hello World","doc":"```\nAlice's Node                   Macula Mesh                   Bob's Node\n                            \n Chat.who()   RPC call    Routing    lookup  RPC Handler  \n                               Table                                 \n               result     (DHT)      return   return users \n                                                                     \n Print users                              \n\n```\n\n**How it works**:\n1. Alice calls `Chat.who()`\n2. ChatRoom calls `Macula.RPC.call(\"chat.general.users\", %{})`\n3. Macula looks up which node registered \"chat.general.users\" (could be any node)\n4. Macula routes RPC request to that node\n5. RPC handler executes and returns list of users\n6. Result routes back to Alice\n7. Alice prints the list\n\n**Distributed RPC** - any node can register an endpoint, any node can call it!\n\n---","ref":"macula_http3_mesh_hello_world.html#rpc-flow-who-s-online"},{"type":"extras","title":"Enhancements - Hello World","doc":"Try adding these features:","ref":"macula_http3_mesh_hello_world.html#enhancements"},{"type":"extras","title":"1. Private Messages (DMs) - Hello World","doc":"```elixir\n# In chat_room.ex\ndef send_dm(to_username, message) do\n  GenServer.cast(__MODULE__, {:send_dm, to_username, message})\nend\n\ndef handle_cast({:send_dm, to_username, message}, state) do\n  # Find target user's node via presence\n  case Map.get(state.online_users, to_username) do\n    nil ->\n      IO.puts(\"User #{to_username} not found\")\n\n    node_id ->\n      # Send directly to that node\n      topic = \"io.macula.chat.dm.#{node_id}\"\n      payload = %{\n        from: state.username,\n        to: to_username,\n        message: message,\n        timestamp: System.system_time(:millisecond)\n      }\n\n      Macula.PubSub.publish(topic, payload)\n  end\n\n  {:noreply, state}\nend\n```","ref":"macula_http3_mesh_hello_world.html#1-private-messages-dms"},{"type":"extras","title":"2. Message History (Last 10 Messages) - Hello World","doc":"```elixir\n# In chat_room.ex\ndef init(opts) do\n  # ... existing code ...\n\n  state = Map.put(state, :message_history, [])\n\n  # ... rest of init ...\nend\n\ndef handle_info({:event, _topic, %{type: :message} = event}, state) do\n  # ... existing code to print message ...\n\n  # Store in history\n  history = [event | state.message_history] |> Enum.take(10)\n  state = Map.put(state, :message_history, history)\n\n  {:noreply, state}\nend\n\ndef get_history do\n  GenServer.call(__MODULE__, :get_history)\nend\n\ndef handle_call(:get_history, _from, state) do\n  {:reply, {:ok, Enum.reverse(state.message_history)}, state}\nend\n```","ref":"macula_http3_mesh_hello_world.html#2-message-history-last-10-messages"},{"type":"extras","title":"3. Typing Indicator - Hello World","doc":"```elixir\n# In chat_client.ex\ndef typing do\n  # Publish ephemeral \"typing\" event\n  Macula.PubSub.publish(\"io.macula.chat.room.general.typing\", %{\n    username: MaculaChat.ChatRoom.get_username(),\n    timestamp: System.system_time(:millisecond)\n  })\nend\n```","ref":"macula_http3_mesh_hello_world.html#3-typing-indicator"},{"type":"extras","title":"4. File Sharing - Hello World","doc":"Use RPC to request file chunks:\n\n```elixir\ndef share_file(filename) do\n  # Read file and encode as base64\n  content = File.read!(filename) |> Base.encode64()\n\n  # Announce file availability\n  Macula.PubSub.publish(\"io.macula.chat.room.general.file\", %{\n    filename: Path.basename(filename),\n    size: byte_size(content),\n    owner: Macula.node_id()\n  })\n\n  # Register RPC endpoint to serve chunks\n  Macula.RPC.register(\"chat.file.#{filename}\", fn %{offset: offset, length: length} ->\n    chunk = binary_part(content, offset, length)\n    {:ok, %{chunk: chunk}}\n  end)\nend\n```\n\n---","ref":"macula_http3_mesh_hello_world.html#4-file-sharing"},{"type":"extras","title":"What You've Learned - Hello World","doc":"Congratulations! You've built a fully distributed chat application using Macula. You now understand:\n\n **Pub/Sub**: How to publish events and subscribe to topics across the mesh\n **RPC**: How to register callable endpoints and invoke them from any node\n **Mesh Topology**: How nodes discover each other and form a network\n **Fault Tolerance**: How the mesh adapts when nodes join/leave\n **Presence**: How to track who's online using heartbeats\n **BEAM OTP**: How to structure applications with GenServers and supervisors\n\n---","ref":"macula_http3_mesh_hello_world.html#what-you-ve-learned"},{"type":"extras","title":"Next Steps - Hello World","doc":"- **[API Reference](macula_http3_mesh_api_reference.md)** - Explore all Macula APIs\n- **[Deployment Patterns](macula_http3_mesh_deployment_patterns.md)** - Deploy to production\n- **[Performance Tuning](macula_http3_mesh_performance.md)** - Optimize for scale\n- **[Security Model](macula_http3_mesh_security.md)** - Secure your mesh\n- **Build something cool!** Share it with the community on Discord\n\n---\n\n**Happy coding!** ","ref":"macula_http3_mesh_hello_world.html#next-steps"},{"type":"extras","title":"Roadmap","doc":"# Macula HTTP/3 Mesh: Comprehensive Technical Roadmap","ref":"macula_http3_mesh_roadmap.html"},{"type":"extras","title":"Executive Summary - Roadmap","doc":"**Vision:** Macula enables distributed BEAM applications to form encrypted, self-healing mesh networks over HTTP/3, with zero infrastructure dependencies. Works behind NATs, scales to thousands of nodes, native distributed Erlang semantics - all over standard HTTPS.\n\n**The \"Wow\" Factor:**\n- Distributed Erlang over HTTP/3 (nobody else does this!)\n- Works through corporate firewalls (it's just HTTPS!)\n- Self-healing mesh topology (no central coordinator)\n- Built-in NAT traversal (QUIC magic)\n- Native BEAM implementation (minimal NIFs)\n\n**Timeline:** 20 weeks (5 months)\n\n**Outcome:** Production-ready mesh networking infrastructure for edge BEAM applications.\n\n---","ref":"macula_http3_mesh_roadmap.html#executive-summary"},{"type":"extras","title":"Table of Contents - Roadmap","doc":"1. [Understanding QUIC and HTTP/3](#understanding-quic-and-http3)\n2. [QUIC/HTTP/3 Libraries for BEAM](#quic-http3-libraries-for-beam)\n3. [Architecture Overview](#architecture-overview)\n4. [Detailed Roadmap](#detailed-roadmap)\n5. [Architecture Diagrams](#architecture-diagrams)\n6. [Technical Deep Dives](#technical-deep-dives)\n7. [Success Metrics](#success-metrics)\n\n---","ref":"macula_http3_mesh_roadmap.html#table-of-contents"},{"type":"extras","title":"Understanding QUIC and HTTP/3 - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#understanding-quic-and-http-3"},{"type":"extras","title":"What is QUIC? - Roadmap","doc":"**QUIC (Quick UDP Internet Connections)** is a modern transport protocol developed by Google and standardized by IETF as RFC 9000. It's designed to replace TCP for web traffic.\n\n#### Key Characteristics\n\n**1. UDP-Based Transport**\n```\nTraditional:  HTTP/2  TLS  TCP  IP\nModern:       HTTP/3  QUIC (includes TLS 1.3)  UDP  IP\n```\n\nQUIC runs over UDP instead of TCP, which provides several advantages:\n- Faster connection establishment (0-RTT and 1-RTT)\n- No head-of-line blocking across streams\n- Better performance on lossy networks\n- Easier NAT traversal (UDP is simpler than TCP for NAT)\n\n**2. Built-in Encryption**\n- TLS 1.3 is integrated into QUIC (not layered on top)\n- All packets are encrypted (except initial handshake metadata)\n- Forward secrecy by default\n- Connection migration (can change IP addresses mid-connection)\n\n**3. Multiplexed Streams**\n```\n\n QUIC Connection                     \n          \n   Stream 0    Stream 1    ...  \n   (Ordered)   (Ordered)        \n          \n                                     \n  Streams are independent!           \n  Loss in Stream 0 doesn't block     \n  Stream 1 (unlike TCP)              \n\n```\n\n**4. Connection Establishment**\n\nTraditional TCP + TLS:\n```\nClient  Server:  SYN                        (1 RTT)\nServer  Client:  SYN-ACK\nClient  Server:  ACK\nClient  Server:  ClientHello (TLS)          (2 RTT)\nServer  Client:  ServerHello + Certificate\nClient  Server:  Finished\nServer  Client:  Finished\nClient  Server:  HTTP Request               (3 RTT)\n                  Total: 3 Round Trips\n```\n\nQUIC (first connection):\n```\nClient  Server:  Initial (ClientHello)      (1 RTT)\nServer  Client:  Handshake (ServerHello)\nClient  Server:  HTTP Request               (1 RTT)\n                  Total: 1 Round Trip\n```\n\nQUIC (resumed connection):\n```\nClient  Server:  0-RTT Data + HTTP Request  (0 RTT!)\n                  Total: 0 Round Trips\n```\n\n**5. Loss Recovery**\n- Per-stream reliability (not per-connection like TCP)\n- More sophisticated than TCP (monotonically increasing packet numbers)\n- Better handling of spurious retransmissions\n- Pluggable congestion control\n\n**6. Connection Migration**\n```\nMobile device scenario:\nWiFi (IP: 192.168.1.100)  Cellular (IP: 10.20.30.40)\n\nTCP:  Connection breaks, must reconnect (new handshake)\nQUIC: Connection continues seamlessly (connection ID stays same)\n```","ref":"macula_http3_mesh_roadmap.html#what-is-quic"},{"type":"extras","title":"What is HTTP/3? - Roadmap","doc":"**HTTP/3** is the third major version of HTTP, using QUIC as its transport instead of TCP.\n\n#### HTTP Evolution\n\n```\nHTTP/1.1 (1997)\n  \n  - Text-based protocol\n  - One request per connection (or pipelining)\n  - Head-of-line blocking\n\nHTTP/2 (2015)\n  \n  - Binary framing\n  - Multiplexing over single TCP connection\n  - Header compression (HPACK)\n  - Still suffers from TCP head-of-line blocking\n\nHTTP/3 (2022)\n  \n  - Same semantics as HTTP/2\n  - QUIC transport (UDP-based)\n  - No head-of-line blocking\n  - 0-RTT connection resumption\n  - Better mobile performance\n```\n\n#### HTTP/3 Frame Types\n\nHTTP/3 uses similar frames to HTTP/2 but adapted for QUIC:\n\n```\nFrame Types:\n- DATA:        Application data (response body)\n- HEADERS:     HTTP headers (compressed with QPACK)\n- PRIORITY:    Stream priority hints\n- CANCEL_PUSH: Cancel server push\n- SETTINGS:    Connection parameters\n- PUSH_PROMISE: Server push announcement\n- GOAWAY:      Graceful shutdown\n- MAX_PUSH_ID: Limit server push\n```\n\n#### QPACK Header Compression\n\nHTTP/3 uses QPACK (QUIC-aware header compression) instead of HPACK:\n- Dynamic table updates on dedicated stream\n- Prevents head-of-line blocking from header compression\n- Better performance on lossy networks","ref":"macula_http3_mesh_roadmap.html#what-is-http-3"},{"type":"extras","title":"Why QUIC/HTTP/3 for Macula Mesh? - Roadmap","doc":"#### 1. **NAT Traversal**\nUDP is much easier to punch through NATs than TCP:\n- Simpler state machines in NAT devices\n- Easier simultaneous open\n- Better compatibility with STUN/TURN\n\n#### 2. **Multiplexing Without Head-of-Line Blocking**\nPerfect for distributed Erlang:\n```\nProcess A  Stream 0:  send(...)  [packet lost!]  retransmit\nProcess B  Stream 1:  send(...)  delivered immediately!\n\nWith TCP: Process B would be blocked waiting for Process A's retransmit\nWith QUIC: Process B's stream is independent\n```\n\n#### 3. **Connection Migration**\nEdge devices often change networks:\n```\nIoT device switches from WiFi to cellular:\n  - TCP: Connection lost, full reconnect\n  - QUIC: Seamless migration, no interruption\n```\n\n#### 4. **Firewall Friendly**\n- Uses port 443 (standard HTTPS)\n- Looks like HTTPS to middleboxes\n- No special firewall rules needed\n\n#### 5. **0-RTT Resumption**\nReconnecting nodes don't waste time:\n```\nNode rejoins mesh after brief disconnect:\n  - TCP + TLS: 3 RTT to re-establish\n  - QUIC 0-RTT: Immediate data transmission\n```\n\n#### 6. **Built-in Encryption**\n- TLS 1.3 integrated (not optional)\n- Perfect forward secrecy\n- No configuration needed","ref":"macula_http3_mesh_roadmap.html#why-quic-http-3-for-macula-mesh"},{"type":"extras","title":"QUIC Protocol Details - Roadmap","doc":"#### Connection ID\n\nQUIC uses Connection IDs instead of 4-tuple (src IP, src port, dst IP, dst port):\n\n```\n\n QUIC Packet                         \n\n Header:                             \n  - Connection ID: 0x1a2b3c4d...       Identifies connection\n  - Packet Number: 42                \n  - Flags: ...                       \n\n Encrypted Payload                   \n\n\nBenefits:\n- Connection survives IP address changes\n- Load balancers can route without decryption\n- NAT rebinding doesn't break connection\n```\n\n#### Stream Management\n\nQUIC streams are lightweight:\n\n```erlang\n% Each Erlang process can have its own stream\nspawn(fun() ->\n    {ok, StreamId} = quic:open_stream(Conn),\n    quic:send(StreamId, Data),\n    receive\n        {stream_data, StreamId, Response} -> handle(Response)\n    end,\n    quic:close_stream(StreamId)\nend).\n\n% Streams are cheap! Can create thousands\n% No overhead like TCP sockets\n```\n\n#### Congestion Control\n\nQUIC implements multiple congestion control algorithms:\n\n- **Reno**: Traditional TCP-like\n- **Cubic**: Linux default (aggressive)\n- **BBR**: Google's Bottleneck Bandwidth and RTT\n- **Custom**: Can implement your own!\n\nFor Macula Mesh:\n```erlang\n% Could implement edge-optimized congestion control\n-module(macula_congestion).\n\nestimate_bandwidth(Samples) ->\n    % Use local measurements instead of RTT\n    % Better for edge networks with variable latency\n    ...\n```\n\n#### Flow Control\n\nQUIC has flow control at two levels:\n\n1. **Stream-level**: Each stream has credit\n2. **Connection-level**: Overall connection credit\n\n```\n\n Connection Credit: 1 MB             \n\n Stream 0:  256 KB credit            \n Stream 1:  512 KB credit            \n Stream 2:  256 KB credit            \n\n\nPrevents any single stream from starving the connection\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#quic-protocol-details"},{"type":"extras","title":"QUIC/HTTP/3 Libraries for BEAM - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#quic-http-3-libraries-for-beam"},{"type":"extras","title":"1. quicer (Recommended) - Roadmap","doc":"**Repository:** https://github.com/emqx/quic\n**License:** Apache 2.0\n**Maintainer:** EMQX Team (Erlang Solutions)\n**Language:** Erlang + C (NIF wrapper)\n**Backend:** Microsoft MsQuic\n\n#### Overview\n\n`quicer` is an Erlang NIF binding for Microsoft's MsQuic library. MsQuic is a production-grade QUIC implementation used by Windows, Azure, and various Microsoft services.\n\n#### Architecture\n\n```\n\n Erlang Application                  \n\n quicer (Erlang API)                 \n  - quicer:listen/2                  \n  - quicer:connect/3                 \n  - quicer:send/2                    \n  - quicer:recv/2                    \n\n quicer NIF (C)                      \n  - Erlang  MsQuic bridge          \n  - Resource management              \n  - Callback handling                \n\n MsQuic (C)                          \n  - RFC 9000 QUIC implementation     \n  - TLS 1.3 integration              \n  - Platform-specific optimizations  \n\n OS Network Stack (UDP)              \n\n```\n\n#### Features\n\n **Supported:**\n- QUIC v1 (RFC 9000)\n- TLS 1.3\n- 0-RTT connection resumption\n- Connection migration\n- Multiple streams per connection\n- Flow control and congestion control\n- Both client and server modes\n\n **Limitations:**\n- NIF dependency (requires C compilation)\n- Tied to MsQuic release cycle\n- Platform-specific quirks\n\n#### API Examples\n\n```erlang\n%% Server\nstart_server() ->\n    %% Load certificate\n    {ok, Cert} = file:read_file(\"server.crt\"),\n    {ok, Key} = file:read_file(\"server.key\"),\n\n    %% Listen options\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula/1.0\"],\n        peer_unidi_stream_count => 10,\n        peer_bidi_stream_count => 10\n    },\n\n    %% Start listener\n    {ok, Listener} = quicer:listen(\"0.0.0.0\", 4433, ListenOpts),\n\n    %% Accept loop\n    accept_loop(Listener).\n\naccept_loop(Listener) ->\n    {ok, Conn} = quicer:accept(Listener, [], 5000),\n    {ok, Conn} = quicer:handshake(Conn),\n\n    %% Spawn handler\n    spawn(fun() -> handle_connection(Conn) end),\n\n    %% Continue accepting\n    accept_loop(Listener).\n\nhandle_connection(Conn) ->\n    %% Accept stream\n    {ok, Stream} = quicer:accept_stream(Conn, []),\n\n    %% Receive data\n    {ok, Data} = quicer:recv(Stream, 0),\n\n    %% Process and respond\n    Response = process(Data),\n    ok = quicer:send(Stream, Response),\n\n    %% Close stream\n    quicer:close_stream(Stream).\n\n%% Client\nstart_client() ->\n    %% Connect options\n    ConnOpts = #{\n        alpn => [\"macula/1.0\"],\n        verify => verify_peer,\n        cacertfile => \"ca.crt\"\n    },\n\n    %% Connect\n    {ok, Conn} = quicer:connect(\"server.example.com\", 4433, ConnOpts, 5000),\n\n    %% Open stream\n    StreamOpts = #{active => false},\n    {ok, Stream} = quicer:start_stream(Conn, StreamOpts),\n\n    %% Send data\n    ok = quicer:send(Stream, <<\"Hello, QUIC!\">>),\n\n    %% Receive response\n    {ok, Response} = quicer:recv(Stream, 0),\n    io:format(\"Received: ~p~n\", [Response]),\n\n    %% Close\n    quicer:close_stream(Stream),\n    quicer:close_connection(Conn).\n```\n\n#### Production Usage\n\n**EMQX:** Used in EMQX 5.0+ for MQTT over QUIC\n- Handles millions of concurrent connections\n- Production-tested at scale\n- Good performance characteristics\n\n**RabbitMQ:** Experimental QUIC support via quicer\n- AMQP 1.0 over QUIC transport\n- Still in development\n\n#### Pros & Cons\n\n**Pros:**\n-  Battle-tested (MsQuic used in Windows, Azure)\n-  Actively maintained\n-  Good documentation\n-  Performance optimized\n-  Cross-platform (Linux, macOS, Windows)\n-  Production-ready (used in EMQX)\n\n**Cons:**\n-  NIF dependency (requires compilation)\n-  Tied to MsQuic (external C library)\n-  Breaking changes between MsQuic versions\n-  Limited control over low-level behavior\n\n**Verdict:**  **Best choice for Macula Mesh**","ref":"macula_http3_mesh_roadmap.html#1-quicer-recommended"},{"type":"extras","title":"2. xquic (Alternative) - Roadmap","doc":"**Repository:** https://github.com/alibaba/xquic\n**License:** Apache 2.0\n**Maintainer:** Alibaba Cloud\n**Language:** C + Erlang bindings\n**Backend:** xquic (Alibaba's QUIC)\n\n#### Overview\n\nxquic is Alibaba's in-house QUIC implementation, used in their edge CDN and cloud services.\n\n#### Features\n\n- QUIC v1 + IETF draft-29\n- HTTP/3 support\n- QUIC multipath extension\n- BBR congestion control\n- High performance (optimized for Alibaba scale)\n\n#### Erlang Bindings\n\nErlang bindings exist but are less mature than quicer:\n- https://github.com/emqx/xquic-erl (community maintained)\n\n#### Pros & Cons\n\n**Pros:**\n-  Very high performance\n-  Multipath QUIC support\n-  Used at Alibaba scale\n\n**Cons:**\n-  Less mature Erlang bindings\n-  Documentation mostly in Chinese\n-  Smaller community\n-  Not as widely tested outside Alibaba\n\n**Verdict:**  **Good but less accessible**","ref":"macula_http3_mesh_roadmap.html#2-xquic-alternative"},{"type":"extras","title":"3. quinn (Rust, via Rustler) - Roadmap","doc":"**Repository:** https://github.com/quinn-rs/quinn\n**License:** Apache 2.0 / MIT\n**Language:** Rust\n**Bindings:** Could use Rustler for Erlang\n\n#### Overview\n\nquinn is a pure Rust QUIC implementation, considered one of the best non-C QUIC libraries.\n\n#### Hypothetical Erlang Integration\n\n```\n\n Erlang Application                  \n\n quinn_nif (Rustler)                 \n  - Erlang  Rust bridge            \n\n quinn (Rust)                        \n  - Pure Rust QUIC implementation    \n\n tokio (Rust async runtime)          \n\n```\n\n#### Pros & Cons\n\n**Pros:**\n-  Pure Rust (memory safe)\n-  Excellent performance\n-  Active development\n-  Clean API\n\n**Cons:**\n-  No official Erlang bindings\n-  Would need to build Rustler wrapper\n-  Rust async runtime complexity\n-  Additional development effort\n\n**Verdict:**  **Interesting but requires work**","ref":"macula_http3_mesh_roadmap.html#3-quinn-rust-via-rustler"},{"type":"extras","title":"4. Pure Erlang QUIC (Hypothetical) - Roadmap","doc":"**Status:** Doesn't exist\n**Effort:** 6-12 months of development\n\n#### Why Pure Erlang?\n\n**Pros:**\n-  No NIFs (easier deployment)\n-  Full control over implementation\n-  Could optimize for BEAM semantics\n-  Easier debugging\n\n**Cons:**\n-  Huge development effort\n-  Likely slower than C/Rust\n-  Hard to match performance of tuned C libs\n-  Cryptography still needs NIFs\n\n#### Feasibility Analysis\n\n```\nComponents needed:\n1. UDP socket handling          (gen_udp)\n2. TLS 1.3 implementation       (ssl app, but need low-level access)\n3. Packet parsing              (binary pattern matching)\n4. Connection state machine    (gen_statem)\n5. Stream multiplexing         (processes)\n6. Flow control                (credits/backpressure)\n7. Congestion control          (algorithms in Erlang)\n8. Loss detection              (timers + state)\n9. 0-RTT resumption            (needs crypto primitives)\n\nEstimated effort: 3-6 person-months for basic implementation\n                 12+ person-months for production-ready\n```\n\n**Verdict:**  **Not practical for Phase 1**","ref":"macula_http3_mesh_roadmap.html#4-pure-erlang-quic-hypothetical"},{"type":"extras","title":"Library Comparison Matrix - Roadmap","doc":"| Feature                  | quicer | xquic | quinn | Pure Erlang |\n|--------------------------|--------|-------|-------|-------------|\n| **Maturity**            |  |  |  |  |\n| **Erlang Integration**  |  |  |  |  |\n| **Performance**         |  |  |  |  |\n| **Documentation**       |  |  |  | N/A |\n| **Production Ready**    |  |  |  |  |\n| **Cross-platform**      |  |  |  |  |\n| **NIF Required**        | Yes | Yes | Yes | No |\n| **Development Effort**  | Low | Medium | High | Very High |\n| **Community Support**   | Strong | Moderate | Strong | N/A |","ref":"macula_http3_mesh_roadmap.html#library-comparison-matrix"},{"type":"extras","title":"Recommendation: quicer - Roadmap","doc":"For Macula Mesh Phase 1, **quicer is the clear choice**:\n\n1. **Production-ready**: Used in EMQX with millions of connections\n2. **Well-documented**: Good examples and API docs\n3. **Actively maintained**: Regular updates, responsive maintainers\n4. **Erlang-native**: Designed for BEAM from the ground up\n5. **MsQuic backend**: Battle-tested in Microsoft services\n\n**Migration Path:**\n- Phase 1: Use quicer (proven, fast path to PoC)\n- Phase 2: Optimize (profile, tune, maybe contribute improvements)\n- Phase 3: Evaluate alternatives (if needed, could switch to pure Erlang or Rust)\n\n---","ref":"macula_http3_mesh_roadmap.html#recommendation-quicer"},{"type":"extras","title":"Architecture Overview - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#architecture-overview"},{"type":"extras","title":"High-Level Architecture - Roadmap","doc":"```\n\n                    Macula Mesh Network                  \n                                                         \n                         \n   Node A  Node B  Node C            \n                                                 \n                         \n                                                     \n                       \n                                                       \n                  HTTP/3 (QUIC)                         \n              (Encrypted, Multiplexed)                  \n\n```","ref":"macula_http3_mesh_roadmap.html#high-level-architecture"},{"type":"extras","title":"Layered Architecture - Roadmap","doc":"```\n\n Layer 5: Application                                    \n   Elixir/Erlang Applications                          \n   Standard distributed Erlang API                     \n   spawn/2, send/2, monitor/2, etc.                   \n\n               (transparent to application)\n\n Layer 4: WAMP Protocol (Optional Compatibility)        \n   publish(Topic, Data)                                \n   subscribe(Topic, Handler)                           \n   call(Procedure, Args)                               \n   register(Procedure, Handler)                        \n\n              \n\n Layer 3: Mesh Routing                                  \n   Node discovery (bootstrap, mDNS, DHT)               \n   Membership management (SWIM gossip)                 \n   Topology management (k-regular graph)               \n   Message routing (DHT-based, O(log n) hops)         \n\n              \n\n Layer 2: Macula Distribution Protocol                  \n   Message framing (wire protocol)                     \n   Handshake and authentication                        \n   Process messaging (SEND, LINK, MONITOR, etc.)      \n   Stream multiplexing (process  stream mapping)     \n\n              \n\n Layer 1: QUIC Transport (HTTP/3)                       \n   quicer (Erlang NIF)                                 \n   MsQuic (C library)                                  \n   UDP sockets                                         \n   TLS 1.3 encryption                                  \n   NAT traversal (STUN/ICE)                           \n\n```","ref":"macula_http3_mesh_roadmap.html#layered-architecture"},{"type":"extras","title":"Component Architecture - Roadmap","doc":"```\n\n Macula Node (Erlang/OTP Application)                   \n\n                                                         \n    \n   Supervision Tree                                   \n                                                      \n    macula_sup (top-level supervisor)                \n       macula_connection_sup (connections)         \n       macula_membership (SWIM gossip)             \n       macula_topology (neighbor management)       \n       macula_routing (DHT routing)                \n       macula_discovery (node discovery)           \n       macula_pubsub (pub/sub registry)            \n       macula_dist (distribution driver)           \n    \n                                                         \n    \n   Connection Pool (one per remote node)              \n                                                      \n    connection_1 (QUIC, 5 streams active)            \n    connection_2 (QUIC, 3 streams active)            \n    connection_3 (QUIC, 8 streams active)            \n    \n                                                         \n    \n   ETS Tables (shared state)                          \n                                                      \n    - membership_table (alive nodes)                  \n    - routing_table (DHT entries)                     \n    - stream_registry (stream_id  pid)              \n    - subscription_registry (topic  [pids])         \n    \n\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#component-architecture"},{"type":"extras","title":"Detailed Roadmap - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#detailed-roadmap"},{"type":"extras","title":"Phase 1: Foundation (Weeks 1-4) - Roadmap","doc":"**Goal:** Prove HTTP/3 Can Carry Erlang Distribution Traffic\n\n#### Week 1-2: QUIC Transport Layer\n\n**Objectives:**\n1. Set up quicer dependency\n2. Create basic QUIC server/client\n3. Implement bidirectional streaming\n4. Build connection management\n\n**Deliverables:**\n\n```erlang\n%% File: macula_quic_echo.erl\n%% Simple QUIC echo server/client to validate transport\n\n-module(macula_quic_echo).\n-export([start_server/1, start_client/2]).\n\nstart_server(Port) ->\n    %% Generate self-signed cert for testing\n    {Cert, Key} = macula_cert:generate_self_signed(\"localhost\"),\n\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula/1.0\"],\n        idle_timeout_ms => 10000,\n        peer_unidi_stream_count => 10,\n        peer_bidi_stream_count => 100\n    },\n\n    {ok, Listener} = quicer:listen(Port, ListenOpts),\n    io:format(\"QUIC server listening on port ~p~n\", [Port]),\n\n    accept_loop(Listener).\n\naccept_loop(Listener) ->\n    case quicer:accept(Listener, [], infinity) of\n        {ok, Conn} ->\n            %% Complete handshake\n            {ok, Conn} = quicer:handshake(Conn),\n\n            %% Get peer info\n            {ok, PeerAddr} = quicer:getopt(Conn, peer_addr),\n            io:format(\"Accepted connection from ~p~n\", [PeerAddr]),\n\n            %% Spawn connection handler\n            spawn_link(fun() -> handle_connection(Conn) end),\n\n            %% Continue accepting\n            accept_loop(Listener);\n        {error, Reason} ->\n            io:format(\"Accept error: ~p~n\", [Reason]),\n            timer:sleep(1000),\n            accept_loop(Listener)\n    end.\n\nhandle_connection(Conn) ->\n    %% Accept streams\n    stream_accept_loop(Conn).\n\nstream_accept_loop(Conn) ->\n    case quicer:accept_stream(Conn, []) of\n        {ok, Stream} ->\n            %% Spawn stream handler\n            spawn_link(fun() -> echo_stream(Stream) end),\n            stream_accept_loop(Conn);\n        {error, closed} ->\n            io:format(\"Connection closed~n\");\n        {error, Reason} ->\n            io:format(\"Stream accept error: ~p~n\", [Reason])\n    end.\n\necho_stream(Stream) ->\n    case quicer:recv(Stream, 0) of\n        {ok, Data} ->\n            io:format(\"Received: ~p~n\", [Data]),\n            quicer:send(Stream, Data),\n            echo_stream(Stream);\n        {error, closed} ->\n            quicer:close_stream(Stream);\n        {error, Reason} ->\n            io:format(\"Recv error: ~p~n\", [Reason]),\n            quicer:close_stream(Stream)\n    end.\n\nstart_client(Host, Port) ->\n    ConnOpts = #{\n        alpn => [\"macula/1.0\"],\n        verify => verify_none  %% For testing only!\n    },\n\n    io:format(\"Connecting to ~s:~p~n\", [Host, Port]),\n    {ok, Conn} = quicer:connect(Host, Port, ConnOpts, 5000),\n\n    %% Open stream\n    {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n\n    %% Send message\n    Message = <<\"Hello, QUIC!\">>,\n    ok = quicer:send(Stream, Message),\n    io:format(\"Sent: ~p~n\", [Message]),\n\n    %% Receive echo\n    {ok, Echo} = quicer:recv(Stream, 0),\n    io:format(\"Received echo: ~p~n\", [Echo]),\n\n    %% Close\n    quicer:close_stream(Stream),\n    quicer:close_connection(Conn).\n```\n\n**Testing:**\n```bash\n# Terminal 1: Start server\n$ erl -pa _build/default/lib/*/ebin\n1> macula_quic_echo:start_server(4433).\n\n# Terminal 2: Connect client\n$ erl -pa _build/default/lib/*/ebin\n1> macula_quic_echo:start_client(\"localhost\", 4433).\n```\n\n**Success Criteria:**\n-  Server accepts QUIC connections\n-  Client can connect and exchange data\n-  Multiple streams work concurrently\n-  Connection survives stream closure\n\n---\n\n#### Week 3: Message Framing Protocol\n\n**Objectives:**\n1. Design Macula wire protocol v1\n2. Implement message encoding/decoding\n3. Define message types for distribution\n\n**Wire Protocol Specification:**\n\n```\nMacula Wire Protocol v1\n=======================\n\nAll integers are big-endian.\n\nPacket Format:\n\n Ver   Type  Flags  Length  Payload \n (1B)  (1B)  (2B)   (4B)    (N B)   \n\n\nVersion (1 byte):\n  - 0x01: Version 1\n\nType (1 byte):\n  - 0x01: HANDSHAKE\n  - 0x02: HEARTBEAT\n  - 0x03: SEND           (send message to process)\n  - 0x04: REG_SEND       (send to registered name)\n  - 0x05: EXIT           (process exit signal)\n  - 0x06: LINK           (link processes)\n  - 0x07: UNLINK         (unlink processes)\n  - 0x08: MONITOR        (monitor process)\n  - 0x09: DEMONITOR      (demonitor)\n  - 0x0A: GROUP_LEADER   (group leader operations)\n  - 0x0B: RPC            (remote procedure call)\n  - 0x0C: SPAWN_REQUEST  (spawn on remote node)\n  - 0x0D: SPAWN_REPLY    (spawn result)\n\nFlags (2 bytes):\n  Bit 0: COMPRESSED (payload is compressed)\n  Bit 1: FRAGMENTED (part of fragmented message)\n  Bit 2-15: Reserved\n\nLength (4 bytes):\n  - Payload length in bytes (max 16 MB)\n\nPayload (N bytes):\n  - Message-type specific data\n  - Encoded using Erlang External Term Format (EETF)\n```\n\n**Implementation:**\n\n```erlang\n%% File: macula_protocol.erl\n-module(macula_protocol).\n-export([encode/2, decode/1]).\n\n%% Protocol version\n-define(VERSION, 1).\n\n%% Message types\n-define(MSG_HANDSHAKE, 16#01).\n-define(MSG_HEARTBEAT, 16#02).\n-define(MSG_SEND, 16#03).\n-define(MSG_REG_SEND, 16#04).\n-define(MSG_EXIT, 16#05).\n-define(MSG_LINK, 16#06).\n-define(MSG_UNLINK, 16#07).\n-define(MSG_MONITOR, 16#08).\n-define(MSG_DEMONITOR, 16#09).\n-define(MSG_GROUP_LEADER, 16#0A).\n-define(MSG_RPC, 16#0B).\n-define(MSG_SPAWN_REQUEST, 16#0C).\n-define(MSG_SPAWN_REPLY, 16#0D).\n\n%% Flags\n-define(FLAG_COMPRESSED, 16#0001).\n-define(FLAG_FRAGMENTED, 16#0002).\n\n%% Encode message\nencode(Type, Payload) when is_integer(Type), Type >= 0, Type =< 255 ->\n    encode(Type, 0, Payload).\n\nencode(Type, Flags, Payload) ->\n    %% Serialize payload\n    PayloadBin = term_to_binary(Payload, [compressed]),\n    Length = byte_size(PayloadBin),\n\n    %% Check size limit (16 MB)\n    if\n        Length > 16#1000000 ->\n            {error, payload_too_large};\n        true ->\n            %% Build packet\n            <<?VERSION:8, Type:8, Flags:16, Length:32, PayloadBin/binary>>\n    end.\n\n%% Decode message\ndecode(<<?VERSION:8, Type:8, Flags:16, Length:32, PayloadBin:Length/binary, Rest/binary>>) ->\n    %% Deserialize payload\n    Payload = binary_to_term(PayloadBin),\n\n    {ok, #{\n        type => Type,\n        flags => Flags,\n        payload => Payload\n    }, Rest};\ndecode(Bin) when byte_size(Bin) < 8 ->\n    {error, insufficient_data};\ndecode(< >) when Version =/= ?VERSION ->\n    {error, {unsupported_version, Version}};\ndecode(_) ->\n    {error, invalid_packet}.\n\n%% Helper: Encode SEND message\nencode_send(FromPid, ToPid, Message) ->\n    encode(?MSG_SEND, {FromPid, ToPid, Message}).\n\n%% Helper: Encode LINK message\nencode_link(Pid1, Pid2) ->\n    encode(?MSG_LINK, {Pid1, Pid2}).\n\n%% Helper: Encode MONITOR message\nencode_monitor(Pid, Ref, MonitoredPid) ->\n    encode(?MSG_MONITOR, {Pid, Ref, MonitoredPid}).\n\n%% Helper: Encode SPAWN_REQUEST message\nencode_spawn_request(ReqId, Module, Function, Args) ->\n    encode(?MSG_SPAWN_REQUEST, {ReqId, Module, Function, Args}).\n```\n\n**Handshake Protocol:**\n\n```erlang\n%% File: macula_handshake.erl\n-module(macula_handshake).\n-export([perform/1, accept/1]).\n\n-record(handshake, {\n    version = ?MACULA_VERSION,\n    node_name :: atom(),\n    node_id :: binary(),      %% SHA256(certificate)\n    capabilities = [] :: [atom()],\n    creation :: integer(),    %% Node start time\n    challenge :: binary()     %% Random bytes for auth\n}).\n\n%% Initiate handshake (client side)\nperform(Conn) ->\n    %% Generate our handshake\n    Handshake = #handshake{\n        node_name = node(),\n        node_id = macula_identity:node_id(),\n        capabilities = [compression, rpc, monitoring, streams],\n        creation = erlang:system_time(millisecond),\n        challenge = crypto:strong_rand_bytes(32)\n    },\n\n    %% Send handshake\n    Packet = macula_protocol:encode(?MSG_HANDSHAKE, Handshake),\n    {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n    ok = quicer:send(Stream, Packet),\n\n    %% Receive remote handshake\n    {ok, ResponsePacket} = quicer:recv(Stream, 0),\n    {ok, #{payload := RemoteHandshake}, _} = macula_protocol:decode(ResponsePacket),\n\n    %% Verify compatibility\n    case check_compatibility(Handshake, RemoteHandshake) of\n        ok ->\n            %% Send acknowledgment\n            Ack = macula_protocol:encode(?MSG_HANDSHAKE, {ack, Handshake#handshake.challenge}),\n            ok = quicer:send(Stream, Ack),\n            {ok, RemoteHandshake};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept handshake (server side)\naccept(Conn) ->\n    %% Accept stream\n    {ok, Stream} = quicer:accept_stream(Conn, []),\n\n    %% Receive handshake\n    {ok, Packet} = quicer:recv(Stream, 0),\n    {ok, #{payload := RemoteHandshake}, _} = macula_protocol:decode(Packet),\n\n    %% Generate our handshake\n    Handshake = #handshake{\n        node_name = node(),\n        node_id = macula_identity:node_id(),\n        capabilities = [compression, rpc, monitoring, streams],\n        creation = erlang:system_time(millisecond),\n        challenge = crypto:strong_rand_bytes(32)\n    },\n\n    %% Verify compatibility\n    case check_compatibility(Handshake, RemoteHandshake) of\n        ok ->\n            %% Send our handshake\n            Response = macula_protocol:encode(?MSG_HANDSHAKE, Handshake),\n            ok = quicer:send(Stream, Response),\n\n            %% Wait for acknowledgment\n            {ok, AckPacket} = quicer:recv(Stream, 0),\n            {ok, #{payload := {ack, Challenge}}, _} = macula_protocol:decode(AckPacket),\n\n            %% Verify challenge\n            if\n                Challenge =:= Handshake#handshake.challenge ->\n                    {ok, RemoteHandshake};\n                true ->\n                    {error, invalid_challenge}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\ncheck_compatibility(Local, Remote) ->\n    %% Check version\n    if\n        Local#handshake.version =/= Remote#handshake.version ->\n            {error, version_mismatch};\n        true ->\n            %% Check capabilities\n            CommonCaps = sets:intersection(\n                sets:from_list(Local#handshake.capabilities),\n                sets:from_list(Remote#handshake.capabilities)\n            ),\n            if\n                sets:size(CommonCaps) > 0 -> ok;\n                true -> {error, no_common_capabilities}\n            end\n    end.\n```\n\n---\n\n#### Week 4: Basic Distribution Protocol\n\n**Objectives:**\n1. Implement net_kernel distribution driver\n2. Support basic message sending\n3. Enable process spawning\n\n**Distribution Driver:**\n\n```erlang\n%% File: macula_dist.erl\n%% Erlang distribution protocol driver for Macula\n%%\n%% This module implements the callbacks required by Erlang's net_kernel\n%% to use Macula as a custom distribution protocol.\n\n-module(macula_dist).\n\n%% Distribution driver callbacks\n-export([\n    listen/1,\n    accept/1,\n    accept_connection/5,\n    setup/5,\n    close/1,\n    select/1,\n    is_node_name/1,\n    address/0\n]).\n\n%% Internal API\n-export([\n    send/2,\n    send/3,\n    recv/2\n]).\n\n-record(macula_dist_state, {\n    listener,      %% QUIC listener\n    connection,    %% QUIC connection\n    node,          %% Remote node name\n    streams = #{}  %% Map: purpose => stream\n}).\n\n%% Listen for incoming connections\nlisten(Name) ->\n    %% Extract port from name (e.g., node@host:4433)\n    Port = extract_port(Name, 4433),\n\n    %% Generate certificate\n    {Cert, Key} = macula_cert:generate_node_cert(Name),\n\n    ListenOpts = #{\n        cert => Cert,\n        key => Key,\n        alpn => [\"macula-dist/1.0\"],\n        peer_bidi_stream_count => 100\n    },\n\n    case quicer:listen(Port, ListenOpts) of\n        {ok, Listener} ->\n            {ok, {Listener, #macula_dist_state{listener = Listener}}};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept incoming connection\naccept(Listen) ->\n    Listener = element(1, Listen),\n    case quicer:accept(Listener, [], infinity) of\n        {ok, Conn} ->\n            %% Perform handshake\n            case macula_handshake:accept(Conn) of\n                {ok, RemoteHandshake} ->\n                    RemoteNode = RemoteHandshake#handshake.node_name,\n                    State = #macula_dist_state{\n                        connection = Conn,\n                        node = RemoteNode\n                    },\n                    {ok, Conn, State};\n                {error, Reason} ->\n                    quicer:close_connection(Conn),\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Accept connection (post-handshake setup)\naccept_connection(AcceptPid, DistCtrl, MyNode, Allowed, SetupTime) ->\n    %% This is called by net_kernel after accept/1 succeeds\n    gen_server:call(DistCtrl, {accept_connection, AcceptPid, MyNode, Allowed, SetupTime}).\n\n%% Setup outgoing connection\nsetup(Node, Type, MyNode, LongOrShortNames, SetupTime) ->\n    %% Extract host and port\n    {Host, Port} = parse_node_name(Node),\n\n    %% Connect\n    ConnOpts = #{\n        alpn => [\"macula-dist/1.0\"],\n        verify => verify_peer\n    },\n\n    case quicer:connect(Host, Port, ConnOpts, 5000) of\n        {ok, Conn} ->\n            %% Perform handshake\n            case macula_handshake:perform(Conn) of\n                {ok, RemoteHandshake} ->\n                    State = #macula_dist_state{\n                        connection = Conn,\n                        node = Node\n                    },\n                    {ok, Conn, State};\n                {error, Reason} ->\n                    quicer:close_connection(Conn),\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%% Close connection\nclose(Conn) ->\n    quicer:close_connection(Conn),\n    ok.\n\n%% Select (for epmd compatibility)\nselect(Node) ->\n    %% Macula doesn't use epmd\n    {ok, Node}.\n\n%% Check if valid node name\nis_node_name(Node) when is_atom(Node) ->\n    case atom_to_list(Node) of\n        [$@ | _] -> false;\n        Name ->\n            case string:chr(Name, $@) of\n                0 -> false;\n                _ -> true\n            end\n    end;\nis_node_name(_) ->\n    false.\n\n%% Get address (for net_kernel)\naddress() ->\n    %% Return local node address\n    {ok, {0, 0, 0, 0}}.\n\n%% Send message to process on remote node\nsend(Conn, Pid, Message) ->\n    %% Encode SEND message\n    Packet = macula_protocol:encode_send(self(), Pid, Message),\n\n    %% Get or create stream for this message\n    {ok, Stream} = get_or_create_stream(Conn, control),\n\n    %% Send\n    quicer:send(Stream, Packet).\n\nsend(Conn, Name, Message) when is_atom(Name) ->\n    %% Send to registered name\n    Packet = macula_protocol:encode(?MSG_REG_SEND, {self(), Name, Message}),\n    {ok, Stream} = get_or_create_stream(Conn, control),\n    quicer:send(Stream, Packet).\n\n%% Receive message\nrecv(Conn, Timeout) ->\n    %% Accept next stream with data\n    case quicer:accept_stream(Conn, [], Timeout) of\n        {ok, Stream} ->\n            case quicer:recv(Stream, 0) of\n                {ok, Packet} ->\n                    {ok, Msg, _} = macula_protocol:decode(Packet),\n                    {ok, Msg};\n                {error, Reason} ->\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n%%% Internal functions\n\nget_or_create_stream(Conn, Purpose) ->\n    %% Look up existing stream for this purpose\n    %% If not found, create new stream\n    case ets:lookup(macula_streams, {Conn, Purpose}) of\n        [{_, Stream}] ->\n            {ok, Stream};\n        [] ->\n            {ok, Stream} = quicer:start_stream(Conn, #{active => false}),\n            ets:insert(macula_streams, {{Conn, Purpose}, Stream}),\n            {ok, Stream}\n    end.\n\nparse_node_name(Node) when is_atom(Node) ->\n    case string:split(atom_to_list(Node), \"@\") of\n        [_Name, HostPort] ->\n            case string:split(HostPort, \":\") of\n                [Host, Port] -> {Host, list_to_integer(Port)};\n                [Host] -> {Host, 4433}  %% Default port\n            end;\n        _ ->\n            {error, invalid_node_name}\n    end.\n\nextract_port(Name, Default) ->\n    case string:split(atom_to_list(Name), \":\") of\n        [_, Port] -> list_to_integer(Port);\n        _ -> Default\n    end.\n```\n\n**Testing:**\n\n```bash\n# Terminal 1: Start first node\n$ erl -name node1@localhost:4433 -proto_dist macula -pa _build/default/lib/*/ebin\n\n# Terminal 2: Start second node\n$ erl -name node2@localhost:4434 -proto_dist macula -pa _build/default/lib/*/ebin\n\n# In node2:\n(node2@localhost:4434)1> net_kernel:connect_node('node1@localhost:4433').\ntrue\n\n(node2@localhost:4434)2> nodes().\n['node1@localhost:4433']\n\n(node2@localhost:4434)3> {node1, 'node1@localhost:4433'} ! {hello, from, node2}.\n{hello, from, node2}\n\n# In node1, check process mailbox:\n(node1@localhost:4433)1> receive Msg -> Msg end.\n{hello, from, node2}\n\n# Spawn remote process:\n(node2@localhost:4434)4> spawn('node1@localhost:4433', fun() ->\n    io:format(\"Running on ~p!~n\", [node()])\nend).\n<12345.67.0>\n\n# On node1, see output:\nRunning on 'node1@localhost:4433'!\n```\n\n**Success Criteria:**\n-  Two nodes can connect via Macula\n-  `nodes()` shows connected nodes\n-  Messages can be sent between nodes\n-  Remote spawning works\n-  Basic distributed Erlang operations function\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-1-foundation-weeks-1-4"},{"type":"extras","title":"Phase 2: Mesh Topology (Weeks 5-8) - Roadmap","doc":"**Goal:** Move Beyond Point-to-Point to Self-Organizing Mesh\n\n#### Week 5-6: Node Discovery and Membership\n\n**Objectives:**\n1. Implement multi-strategy node discovery\n2. Build SWIM-based membership protocol\n3. Handle node joins, leaves, failures\n\n**Node Discovery:**\n\n```erlang\n%% File: macula_discovery.erl\n-module(macula_discovery).\n-behaviour(gen_server).\n\n-export([start_link/0, discover/0, get_known_nodes/0]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-record(state, {\n    bootstrap_nodes = [],\n    known_nodes = sets:new(),\n    discovery_interval = 30000  %% 30 seconds\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\ndiscover() ->\n    gen_server:call(?MODULE, discover).\n\nget_known_nodes() ->\n    gen_server:call(?MODULE, get_known_nodes).\n\ninit([]) ->\n    %% Load bootstrap nodes from config\n    Bootstrap = application:get_env(macula, bootstrap_nodes, []),\n\n    %% Start discovery timer\n    erlang:send_after(1000, self(), discover),\n\n    {ok, #state{bootstrap_nodes = Bootstrap}}.\n\nhandle_call(discover, _From, State) ->\n    %% Run all discovery strategies in parallel\n    Self = self(),\n    spawn(fun() -> Self ! {discovered, discover_via_bootstrap(State#state.bootstrap_nodes)} end),\n    spawn(fun() -> Self ! {discovered, discover_via_mdns()} end),\n    spawn(fun() -> Self ! {discovered, discover_via_dns_srv()} end),\n\n    {reply, ok, State};\n\nhandle_call(get_known_nodes, _From, State) ->\n    Nodes = sets:to_list(State#state.known_nodes),\n    {reply, Nodes, State}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(discover, State) ->\n    %% Trigger discovery\n    discover(),\n\n    %% Schedule next discovery\n    erlang:send_after(State#state.discovery_interval, self(), discover),\n    {noreply, State};\n\nhandle_info({discovered, Nodes}, State) ->\n    %% Merge discovered nodes\n    KnownNodes = lists:foldl(\n        fun(Node, Acc) -> sets:add_element(Node, Acc) end,\n        State#state.known_nodes,\n        Nodes\n    ),\n\n    %% Notify membership protocol\n    macula_membership:discovered_nodes(Nodes),\n\n    {noreply, State#state{known_nodes = KnownNodes}}.\n\n%%% Discovery Strategies\n\n%% Strategy 1: Bootstrap Nodes\ndiscover_via_bootstrap(Bootstrap) ->\n    %% Try to connect to bootstrap nodes\n    lists:filtermap(fun(Node) ->\n        case macula_connection:ping(Node, 1000) of\n            pong -> {true, Node};\n            timeout -> false\n        end\n    end, Bootstrap).\n\n%% Strategy 2: mDNS (local network)\ndiscover_via_mdns() ->\n    %% Send mDNS query for _macula._udp.local\n    case macula_mdns:discover(\"_macula._udp.local\", 2000) of\n        {ok, Nodes} -> Nodes;\n        {error, _} -> []\n    end.\n\n%% Strategy 3: DNS SRV Records\ndiscover_via_dns_srv() ->\n    %% Query DNS SRV for _macula._udp.example.com\n    Domain = application:get_env(macula, dns_domain, \"macula.local\"),\n    SRVName = \"_macula._udp.\" ++ Domain,\n\n    case inet_res:lookup(SRVName, in, srv) of\n        [] -> [];\n        Records ->\n            %% Extract host:port from SRV records\n            lists:map(fun({_Priority, _Weight, Port, Host}) ->\n                list_to_atom(atom_to_list(node()) ++ \"@\" ++ Host ++ \":\" ++ integer_to_list(Port))\n            end, Records)\n    end.\n```\n\n**SWIM Membership Protocol:**\n\n```erlang\n%% File: macula_membership.erl\n%% SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol\n-module(macula_membership).\n-behaviour(gen_server).\n\n-export([start_link/0, join/1, leave/0, get_members/0, discovered_nodes/1]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-record(member, {\n    node_id,\n    address,\n    state = alive,      %% alive | suspect | dead\n    incarnation = 0,    %% For conflict resolution\n    last_seen,          %% Timestamp\n    metadata = #{}      %% Arbitrary key-value data\n}).\n\n-record(state, {\n    local_member,\n    members = #{},       %% node_id => member\n    protocol_period = 1000,  %% 1 second\n    suspect_timeout = 5000,  %% 5 seconds\n    ping_targets = []\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\njoin(BootstrapNode) ->\n    gen_server:call(?MODULE, {join, BootstrapNode}).\n\nleave() ->\n    gen_server:call(?MODULE, leave).\n\nget_members() ->\n    gen_server:call(?MODULE, get_members).\n\ndiscovered_nodes(Nodes) ->\n    gen_server:cast(?MODULE, {discovered_nodes, Nodes}).\n\ninit([]) ->\n    %% Create local member\n    Local = #member{\n        node_id = macula_identity:node_id(),\n        address = macula_identity:address(),\n        state = alive,\n        incarnation = 0,\n        last_seen = erlang:system_time(millisecond),\n        metadata = #{\n            node_name => node(),\n            started_at => erlang:system_time(millisecond)\n        }\n    },\n\n    %% Start protocol tick\n    erlang:send_after(1000, self(), protocol_tick),\n\n    {ok, #state{local_member = Local}}.\n\nhandle_call({join, BootstrapNode}, _From, State) ->\n    %% Contact bootstrap node and exchange membership\n    case macula_connection:connect(BootstrapNode) of\n        {ok, Conn} ->\n            %% Send join request\n            Request = {join, State#state.local_member},\n            case macula_rpc:call(Conn, ?MODULE, handle_join, [Request]) of\n                {ok, RemoteMembers} ->\n                    %% Merge members\n                    Members = maps:merge(State#state.members, RemoteMembers),\n                    {reply, ok, State#state{members = Members}};\n                {error, Reason} ->\n                    {reply, {error, Reason}, State}\n            end;\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\n\nhandle_call(get_members, _From, State) ->\n    Members = maps:values(State#state.members),\n    AliveMembers = lists:filter(fun(M) -> M#member.state =:= alive end, Members),\n    {reply, AliveMembers, State};\n\nhandle_call(leave, _From, State) ->\n    %% Broadcast leave message\n    Members = maps:values(State#state.members),\n    Msg = {leave, State#state.local_member},\n    lists:foreach(fun(Member) ->\n        macula_connection:send(Member#member.node_id, Msg)\n    end, Members),\n\n    {stop, normal, ok, State}.\n\nhandle_cast({discovered_nodes, Nodes}, State) ->\n    %% Add discovered nodes to members (if not already known)\n    NewMembers = lists:foldl(fun(Node, Acc) ->\n        NodeId = macula_identity:node_id(Node),\n        case maps:is_key(NodeId, Acc) of\n            true -> Acc;\n            false ->\n                Member = #member{\n                    node_id = NodeId,\n                    address = Node,\n                    state = alive,\n                    last_seen = erlang:system_time(millisecond)\n                },\n                maps:put(NodeId, Member, Acc)\n        end\n    end, State#state.members, Nodes),\n\n    {noreply, State#state{members = NewMembers}};\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(protocol_tick, State) ->\n    %% SWIM protocol tick\n    NewState = swim_tick(State),\n\n    %% Schedule next tick\n    erlang:send_after(State#state.protocol_period, self(), protocol_tick),\n\n    {noreply, NewState};\n\nhandle_info({ping, From, Incarnation}, State) ->\n    %% Respond to ping\n    macula_connection:send(From, {ack, State#state.local_member#member.incarnation}),\n    {noreply, State};\n\nhandle_info({ack, _Incarnation}, State) ->\n    %% Received ack from ping\n    {noreply, State};\n\nhandle_info({ping_req, Target, From}, State) ->\n    %% Indirect ping request\n    case macula_connection:ping(Target, 500) of\n        pong ->\n            macula_connection:send(From, {ping_req_ack, Target});\n        timeout ->\n            macula_connection:send(From, {ping_req_timeout, Target})\n    end,\n    {noreply, State}.\n\n%%% SWIM Protocol Implementation\n\nswim_tick(State) ->\n    %% 1. Select random member to ping\n    case select_random_member(State#state.members) of\n        {ok, Target} ->\n            case direct_ping(Target) of\n                pong ->\n                    %% Update last_seen\n                    update_member_state(Target#member.node_id, alive, State);\n                timeout ->\n                    %% Try indirect ping via other members\n                    case indirect_ping(Target, State) of\n                        ok ->\n                            update_member_state(Target#member.node_id, alive, State);\n                        failed ->\n                            %% Mark as suspect\n                            State1 = update_member_state(Target#member.node_id, suspect, State),\n                            %% Schedule suspicion timeout\n                            erlang:send_after(State#state.suspect_timeout, self(),\n                                {suspect_timeout, Target#member.node_id}),\n                            State1\n                    end\n            end;\n        error ->\n            State\n    end,\n\n    %% 2. Gossip membership changes\n    gossip_changes(State),\n\n    State.\n\ndirect_ping(Target) ->\n    case macula_connection:ping(Target#member.node_id, 1000) of\n        pong -> pong;\n        _ -> timeout\n    end.\n\nindirect_ping(Target, State) ->\n    %% Select K random members for indirect ping\n    K = 3,\n    Members = maps:values(State#state.members),\n    Proxies = select_random_n(Members, K),\n\n    %% Send ping_req to proxies\n    Ref = make_ref(),\n    lists:foreach(fun(Proxy) ->\n        macula_connection:send(Proxy#member.node_id, {ping_req, Target, self(), Ref})\n    end, Proxies),\n\n    %% Wait for responses\n    wait_for_ping_req_responses(Ref, K, 2000).\n\nwait_for_ping_req_responses(_Ref, 0, _Timeout) ->\n    failed;\nwait_for_ping_req_responses(Ref, Remaining, Timeout) ->\n    receive\n        {ping_req_ack, _Target, Ref} ->\n            ok;\n        {ping_req_timeout, _Target, Ref} ->\n            wait_for_ping_req_responses(Ref, Remaining - 1, Timeout)\n    after Timeout ->\n        failed\n    end.\n\ngossip_changes(State) ->\n    %% Select random peers for gossip\n    Members = maps:values(State#state.members),\n    GossipTargets = select_random_n(Members, 3),\n\n    %% Get recent changes\n    Changes = get_recent_changes(State),\n\n    %% Send to targets\n    lists:foreach(fun(Target) ->\n        macula_connection:send(Target#member.node_id, {gossip, Changes})\n    end, GossipTargets).\n\nget_recent_changes(State) ->\n    %% Get members that changed state recently (last 10 seconds)\n    Now = erlang:system_time(millisecond),\n    RecentWindow = 10000,\n\n    maps:filter(fun(_NodeId, Member) ->\n        (Now - Member#member.last_seen)  \n    case maps:find(NodeId, State#state.members) of\n        {ok, Member} ->\n            UpdatedMember = Member#member{\n                state = NewState,\n                last_seen = erlang:system_time(millisecond)\n            },\n            Members = maps:put(NodeId, UpdatedMember, State#state.members),\n            State#state{members = Members};\n        error ->\n            State\n    end.\n\nselect_random_member(Members) when map_size(Members) > 0 ->\n    List = maps:values(Members),\n    {ok, lists:nth(rand:uniform(length(List)), List)};\nselect_random_member(_) ->\n    error.\n\nselect_random_n(List, N) when length(List) = \n    List;\nselect_random_n(List, N) ->\n    %% Shuffle and take N\n    Shuffled = [X || {_, X} <- lists:sort([{rand:uniform(), E} || E <- List])],\n    lists:sublist(Shuffled, N).\n```\n\n---\n\n#### Week 7: Topology Management and Routing\n\n**Objectives:**\n1. Implement k-regular graph topology\n2. Build DHT-based routing\n3. Optimize for low diameter\n\n**Topology Manager:**\n\n```erlang\n%% File: macula_topology.erl\n%% Manages connection topology using k-regular graph\n%% Each node maintains K connections to neighbors on consistent hash ring\n\n-module(macula_topology).\n-behaviour(gen_server).\n\n-export([start_link/0, maintain/0, get_neighbors/0]).\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2]).\n\n-define(K_NEIGHBORS, 6).  %% Number of neighbors to maintain\n\n-record(state, {\n    neighbors = [],         %% Current neighbor connections\n    desired_neighbors = [], %% Neighbors we should connect to\n    ring_position          %% Our position on hash ring\n}).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\nmaintain() ->\n    gen_server:call(?MODULE, maintain).\n\nget_neighbors() ->\n    gen_server:call(?MODULE, get_neighbors).\n\ninit([]) ->\n    %% Calculate our position on hash ring\n    NodeId = macula_identity:node_id(),\n    Position = crypto:hash(sha256, NodeId),\n\n    %% Start maintenance timer\n    erlang:send_after(5000, self(), maintain),\n\n    {ok, #state{ring_position = Position}}.\n\nhandle_call(get_neighbors, _From, State) ->\n    {reply, State#state.neighbors, State};\n\nhandle_call(maintain, _From, State) ->\n    NewState = maintain_topology(State),\n    {reply, ok, NewState}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(maintain, State) ->\n    NewState = maintain_topology(State),\n    erlang:send_after(5000, self(), maintain),\n    {noreply, NewState}.\n\nmaintain_topology(State) ->\n    %% Get all known members\n    Members = macula_membership:get_members(),\n\n    %% Select desired neighbors using consistent hashing\n    DesiredNeighbors = select_neighbors(Members, ?K_NEIGHBORS, State#state.ring_position),\n\n    %% Current connections\n    CurrentNeighbors = State#state.neighbors,\n\n    %% Find missing connections\n    Missing = DesiredNeighbors -- CurrentNeighbors,\n\n    %% Find extra connections (if we're over K neighbors)\n    Extra = CurrentNeighbors -- DesiredNeighbors,\n\n    %% Connect to missing\n    lists:foreach(fun(NodeId) ->\n        case macula_connection:connect(NodeId) of\n            {ok, _Conn} ->\n                io:format(\"Connected to neighbor: ~p~n\", [NodeId]);\n            {error, Reason} ->\n                io:format(\"Failed to connect to ~p: ~p~n\", [NodeId, Reason])\n        end\n    end, Missing),\n\n    %% Disconnect extra (if too many connections)\n    if\n        length(CurrentNeighbors) > ?K_NEIGHBORS * 2 ->\n            lists:foreach(fun(NodeId) ->\n                macula_connection:disconnect(NodeId)\n            end, Extra);\n        true ->\n            ok\n    end,\n\n    %% Update state\n    NewNeighbors = (CurrentNeighbors ++ Missing) -- Extra,\n    State#state{\n        neighbors = NewNeighbors,\n        desired_neighbors = DesiredNeighbors\n    }.\n\nselect_neighbors(Members, K, MyPosition) ->\n    %% Place all members on hash ring\n    Ring = lists:map(fun(Member) ->\n        NodeId = Member#member.node_id,\n        Position = crypto:hash(sha256, NodeId),\n        {Position, NodeId}\n    end, Members),\n\n    %% Sort by position\n    SortedRing = lists:sort(Ring),\n\n    %% Find our position\n    MyIndex = find_position(MyPosition, SortedRing),\n\n    %% Select K clockwise neighbors (for redundancy, select K/2 clockwise + K/2 counter-clockwise)\n    ClockwiseCount = K div 2,\n    CounterClockwiseCount = K - ClockwiseCount,\n\n    Clockwise = select_clockwise(MyIndex, ClockwiseCount, SortedRing),\n    CounterClockwise = select_counter_clockwise(MyIndex, CounterClockwiseCount, SortedRing),\n\n    Clockwise ++ CounterClockwise.\n\nfind_position(MyPosition, Ring) ->\n    find_position(MyPosition, Ring, 0).\n\nfind_position(_MyPosition, [], _Index) ->\n    0;\nfind_position(MyPosition, [{Position, _NodeId} | _Rest], Index) when Position >= MyPosition ->\n    Index;\nfind_position(MyPosition, [_H | Rest], Index) ->\n    find_position(MyPosition, Rest, Index + 1).\n\nselect_clockwise(MyIndex, Count, Ring) ->\n    RingSize = length(Ring),\n    Indices = [(MyIndex + I) rem RingSize || I <- lists:seq(1, Count)],\n    [NodeId || {Idx, {_Pos, NodeId}} <- lists:zip(Indices, Ring), Idx =:= element(1, lists:nth(Idx + 1, lists:zip(lists:seq(0, RingSize - 1), Ring)))].\n\nselect_counter_clockwise(MyIndex, Count, Ring) ->\n    RingSize = length(Ring),\n    Indices = [(MyIndex - I + RingSize) rem RingSize || I <- lists:seq(1, Count)],\n    [NodeId || {Idx, {_Pos, NodeId}} <- lists:zip(Indices, Ring), Idx =:= element(1, lists:nth(Idx + 1, lists:zip(lists:seq(0, RingSize - 1), Ring)))].\n```\n\n**DHT Routing:**\n\n```erlang\n%% File: macula_routing.erl\n%% Kademlia-inspired DHT routing for mesh\n\n-module(macula_routing).\n-export([route/2, find_node/1, find_closest_nodes/2]).\n\n-define(K, 20).  %% Replication factor\n-define(ALPHA, 3).  %% Concurrency parameter\n\n%% Route message to destination node\nroute(DestNodeId, Message) ->\n    case macula_connection:is_connected(DestNodeId) of\n        true ->\n            %% Direct connection, send immediately\n            macula_connection:send(DestNodeId, Message);\n        false ->\n            %% Find next hop via DHT\n            NextHop = find_next_hop(DestNodeId),\n            forward(NextHop, DestNodeId, Message)\n    end.\n\n%% Find next hop closer to destination\nfind_next_hop(DestNodeId) ->\n    MyNodeId = macula_identity:node_id(),\n\n    %% Get connected neighbors\n    Neighbors = macula_topology:get_neighbors(),\n\n    %% Calculate XOR distance from each neighbor to destination\n    Distances = lists:map(fun(NeighborId) ->\n        Dist = xor_distance(NeighborId, DestNodeId),\n        {Dist, NeighborId}\n    end, Neighbors),\n\n    %% Sort by distance (closest first)\n    Sorted = lists:sort(Distances),\n\n    %% Return closest neighbor\n    case Sorted of\n        [{_Dist, NextHop} | _] ->\n            %% Check if NextHop is closer than us\n            MyDist = xor_distance(MyNodeId, DestNodeId),\n            if\n                _Dist   NextHop;\n                true -> DestNodeId  %% We're closest, destination must be dead\n            end;\n        [] ->\n            %% No neighbors, can't route\n            {error, no_route}\n    end.\n\n%% Forward message to next hop\nforward(NextHop, FinalDest, Message) ->\n    ForwardMsg = {forward, FinalDest, Message},\n    macula_connection:send(NextHop, ForwardMsg).\n\n%% XOR distance metric (like Kademlia)\nxor_distance(A, B) when is_binary(A), is_binary(B) ->\n    crypto:bytes_to_integer(crypto:exor(A, B));\nxor_distance(A, B) ->\n    xor_distance(term_to_binary(A), term_to_binary(B)).\n\n%% Find node by ID (iterative lookup)\nfind_node(TargetId) ->\n    find_node(TargetId, [], [macula_identity:node_id()]).\n\nfind_node(TargetId, Queried, Closest) ->\n    %% Select ALPHA closest unqueried nodes\n    ToQuery = select_unqueried(Closest, Queried, ?ALPHA),\n\n    case ToQuery of\n        [] ->\n            %% No more nodes to query, return closest\n            {ok, lists:sublist(Closest, ?K)};\n        _ ->\n            %% Query nodes in parallel\n            Results = query_nodes(ToQuery, TargetId),\n\n            %% Merge results\n            NewClosest = merge_and_sort(Closest, Results, TargetId),\n            NewQueried = Queried ++ ToQuery,\n\n            %% Check if we found target\n            case lists:member(TargetId, NewClosest) of\n                true -> {ok, TargetId};\n                false -> find_node(TargetId, NewQueried, NewClosest)\n            end\n    end.\n\nquery_nodes(Nodes, TargetId) ->\n    %% Query each node for closer nodes\n    lists:flatmap(fun(NodeId) ->\n        case macula_rpc:call(NodeId, ?MODULE, find_closest_nodes, [TargetId, ?K], 1000) of\n            {ok, Nodes} -> Nodes;\n            {error, _} -> []\n        end\n    end, Nodes).\n\nfind_closest_nodes(TargetId, K) ->\n    %% Return K closest known nodes to TargetId\n    Members = macula_membership:get_members(),\n    Distances = [{xor_distance(M#member.node_id, TargetId), M#member.node_id} || M <- Members],\n    Sorted = lists:sort(Distances),\n    {ok, [NodeId || {_Dist, NodeId} <- lists:sublist(Sorted, K)]}.\n\nselect_unqueried(Closest, Queried, Alpha) ->\n    Unqueried = Closest -- Queried,\n    lists:sublist(Unqueried, Alpha).\n\nmerge_and_sort(Closest, New, TargetId) ->\n    All = lists:usort(Closest ++ New),\n    Distances = [{xor_distance(NodeId, TargetId), NodeId} || NodeId <- All],\n    Sorted = lists:sort(Distances),\n    [NodeId || {_Dist, NodeId} <- Sorted].\n```\n\n---\n\n(Continuing in next section due to length...)","ref":"macula_http3_mesh_roadmap.html#phase-2-mesh-topology-weeks-5-8"},{"type":"extras","title":"Phase 3: NAT Traversal (Weeks 9-12) - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#phase-3-nat-traversal-weeks-9-12"},{"type":"extras","title":"Phase 4: WAMP Layer (Weeks 13-16) - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#phase-4-wamp-layer-weeks-13-16"},{"type":"extras","title":"Phase 5: Production Hardening (Weeks 17-20) - Roadmap","doc":"---","ref":"macula_http3_mesh_roadmap.html#phase-5-production-hardening-weeks-17-20"},{"type":"extras","title":"Architecture Diagrams - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#architecture-diagrams"},{"type":"extras","title":"1. System Architecture - Roadmap","doc":"```\n\n                         Macula Mesh Network                         \n                                                                     \n  Internet / WAN                                                     \n    \n                                                                  \n                               \n     Node A   Node B   Node C         \n     (USA)              (Europe)           (Asia)         \n                               \n                                                             \n                     \n                                                                \n                     HTTP/3 (QUIC/UDP)                           \n                       Port 443/UDP                              \n    \n                                                                     \n  NAT/Firewall Traversal:                                           \n   STUN for public address discovery                               \n   ICE for connectivity checks                                     \n   UDP hole punching                                               \n   TURN relay as fallback                                          \n\n```","ref":"macula_http3_mesh_roadmap.html#1-system-architecture"},{"type":"extras","title":"2. Node Internal Architecture - Roadmap","doc":"```\n\n Macula Node (BEAM VM)                                               \n\n                                                                     \n      \n   Application Layer                                              \n     Elixir/Erlang Apps                                          \n     spawn/2, send/2, monitor/2                                 \n     Transparent distribution                                    \n      \n                                                                    \n      \n   WAMP Compatibility Layer (Optional)                            \n     publish/subscribe                                           \n     call/register (RPC)                                         \n      \n                                                                    \n      \n   Mesh Services                                                  \n                \n     Discovery       Membership      Topology             \n     (Bootstrap,     (SWIM           (k-regular           \n      mDNS, DNS)      Gossip)         graph)              \n                \n                \n     Routing         Pub/Sub         RPC                  \n     (DHT,           (Topic-based    (Request/            \n      Kademlia)       Registry)       Response)           \n                \n      \n                                                                    \n      \n   Macula Distribution Protocol                                   \n     Message framing (wire protocol)                             \n     Handshake & authentication                                  \n     Stream multiplexing                                         \n     Process  Stream mapping                                   \n      \n                                                                    \n      \n   QUIC Transport (via quicer NIF)                                \n             \n     MsQuic (C library)                                         \n       RFC 9000 QUIC implementation                            \n       TLS 1.3 integrated                                      \n       Streams, flow control, congestion control               \n             \n      \n                                                                    \n      \n   UDP Sockets (OS Network Stack)                                 \n      \n\n```","ref":"macula_http3_mesh_roadmap.html#2-node-internal-architecture"},{"type":"extras","title":"3. Message Flow Diagram - Roadmap","doc":"```\nProcess A (Node 1)                                  Process B (Node 2)\n                                                          \n       Pid ! Message                                     \n                                  \n                                                        \n                                                        \n macula_dist                                             \n                                                        \n       encode_send()                                    \n                                          \n                                                       \n                                                       \n macula_protocol                                        \n                                                       \n       Frame:                                          \n       [Ver|Type|                                      \n        Flags|Len|                                     \n        Payload]                                       \n                                          \n                                                        \n                                                        \n macula_connection                                       \n                                                        \n       Get/Create Stream                                \n                                          \n                                                       \n                                                       \n quicer (NIF)                                           \n                                                       \n       quicer:send()                                    \n                                          \n                                                        \n                                                        \n   MsQuic (C)                                            \n                                                        \n       QUIC Packet                                      \n       (encrypted)                                      \n                                  \n                                                         \n                                                         \n   UDP Socket                                             \n                                                         \n          \n                 Network (Internet)                     \n                                                        \n                                                  UDP Socket\n                                                        \n                                                        \n                                                   MsQuic (C)\n                                                        \n                                                         Decrypt\n                                                         Reassemble\n                                                        \n                                                                 \n                                                                 \n                                                  quicer (NIF)    \n                                                                 \n                                                         quicer:recv()\n                                                        \n                                                        \n                                                        \n                                               macula_connection\n                                                        \n                                                         Stream  Pid lookup\n                                                        \n                                                                 \n                                                                 \n                                                macula_protocol   \n                                                                 \n                                                         decode()\n                                                        \n                                                        \n                                                        \n                                                  macula_dist\n                                                        \n                                                         Deliver to process\n                                                        \n                                                                \n                                                                \n                                                  Process B      \n                                                                \n                                                         receive \n                                                           Message\n                                                        \n                                                        \n                                                        \n```","ref":"macula_http3_mesh_roadmap.html#3-message-flow-diagram"},{"type":"extras","title":"4. Mesh Topology Diagram - Roadmap","doc":"```\n\n Consistent Hash Ring (k-regular graph, k=6)                     \n                                                                  \n                          Node 3                                 \n                                                                \n                                                               \n                                                                \n                                                                \n                                                                \n   Node 2   Node 4               \n                                                             \n                                                             \n                                                             \n                       Node 5                                 \n                                                             \n                                                             \n                                                             \n   Node 1  Node 6                \n                                                                \n                                                                \n                                                                \n                                                               \n                                                                \n                        Node 7                                   \n                                                                  \n  Each node connects to K neighbors (K=6 in this example)       \n   K/2 clockwise neighbors (3)                                 \n   K/2 counter-clockwise neighbors (3)                         \n                                                                  \n  Properties:                                                    \n   Low diameter (O(log n) hops between any two nodes)         \n   High fault tolerance (multiple paths)                       \n   Scalable (each node has fixed K connections)               \n\n```","ref":"macula_http3_mesh_roadmap.html#4-mesh-topology-diagram"},{"type":"extras","title":"5. NAT Traversal Flow - Roadmap","doc":"```\n\n NAT Traversal Using STUN + ICE                                   \n                                                                  \n  Node A (behind NAT)          STUN Server         Node B (public)\n                                                               \n         1. STUN Binding Request                               \n                                   \n                                                               \n         2. STUN Response                                      \n            (Public IP: 1.2.3.4)                               \n                                   \n                                                               \n         3. Register with Signaling Server                     \n            POST /register                                      \n            { candidates: [                                     \n              {type: \"host\", addr: \"192.168.1.100\"},            \n              {type: \"srflx\", addr: \"1.2.3.4\"}                  \n            ]}                                                   \n             \n                                                                 \n         4. Query for Node B candidates                         \n            GET /lookup/node_b                                  \n             \n                                                                 \n         5. Receive Node B candidates                           \n            { candidates: [{type: \"host\", addr: \"5.6.7.8\"}]}    \n             \n                                                                 \n         6. Connectivity Checks (ICE)                           \n            Send STUN probes to all candidate pairs             \n             \n             \n                                                                 \n         7. Select best candidate pair                          \n            (Direct: 1.2.3.4  5.6.7.8)                        \n                                                                 \n         8. Establish QUIC Connection                           \n             \n                                                                 \n         9. Communication over QUIC/UDP                         \n             \n                                                                 \n\n```","ref":"macula_http3_mesh_roadmap.html#5-nat-traversal-flow"},{"type":"extras","title":"6. Development Roadmap Gantt Chart - Roadmap","doc":"```\nWeek  Phase   Milestone\n\n 1-2   QUIC Transport Layer\n              quicer integration\n              Basic client/server\n              Bidirectional streams\n\n 3        Message Framing Protocol\n              Wire protocol spec\n              Encode/decode\n              Handshake\n\n 4        Distribution Protocol\n              net_kernel driver\n              Basic messaging\n              Remote spawn\n\n 5-6       Node Discovery\n                Bootstrap\n                mDNS\n                SWIM membership\n\n 7            Topology & Routing\n                  k-regular graph\n                  DHT routing\n\n 8             Testing & Validation\n                  Chaos testing\n                  Benchmarks\n\n 9-10           NAT Traversal\n                     STUN client\n                     ICE implementation\n\n11-12             Hole Punching\n                       UDP hole punch\n                       TURN relay\n\n13-14               Distributed Pub/Sub\n                         Topic registry\n                         Content routing\n\n15-16                 RPC Layer\n                           Sync RPC\n                           WAMP compat\n\n17                      Security\n                           TLS certs\n                           Rate limiting\n\n18                       Monitoring\n                            Metrics\n                            Visualization\n\n19                        Performance\n                             Optimization\n                             Benchmarks\n\n20                         Documentation\n                              Arch guide\n                              API docs\n\n\nLegend:\n = Active development\n```\n\n---","ref":"macula_http3_mesh_roadmap.html#6-development-roadmap-gantt-chart"},{"type":"extras","title":"Technical Deep Dives - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#technical-deep-dives"},{"type":"extras","title":"Deep Dive 1: QUIC vs TCP for Distributed Erlang - Roadmap","doc":"**Why QUIC is Better for Distributed Erlang:**\n\n#### 1. Head-of-Line Blocking\n\n**TCP Problem:**\n```\nProcess A sends: [Packet 1][Packet 2][Packet 3*LOST][Packet 4]\n                                          \n                                          \n                        All packets 4+ blocked until 3 retransmitted!\n\nProcess B waiting to receive Packet 4:   BLOCKED\n```\n\n**QUIC Solution:**\n```\nStream 0 (Process A): [Pkt 1][Pkt 2][Pkt 3*LOST]\n                                           Retransmit only this\n                                          \nStream 1 (Process B): [Pkt 1][Pkt 2][Pkt 3]  NOT BLOCKED!\n\nIndependent streams = No cross-stream blocking\n```\n\n#### 2. Connection Migration\n\n**TCP Problem:**\n```\nMobile device moves from WiFi to Cellular:\n\nWiFi IP:     192.168.1.100:5000\n              [Connection established]\n              [Active transfers]\n              [Network switches]\nCellular IP: 10.20.30.40:6000\n              [TCP connection LOST]\n              [Must re-establish: 3 RTT]\n              [Resume transfers]\n```\n\n**QUIC Solution:**\n```\nWiFi IP:     192.168.1.100:5000\n              [Connection ID: 0x1a2b3c4d]\n              [Active transfers]\n              [Network switches]\nCellular IP: 10.20.30.40:6000\n              [Same Connection ID!]\n              [Continue immediately: 0 RTT]\n              [Transfers uninterrupted]\n```\n\n#### 3. 0-RTT Resumption\n\n**TCP + TLS 1.2:**\n```\nClient  Server: SYN                      RTT 1\nServer  Client: SYN-ACK\nClient  Server: ACK\nClient  Server: ClientHello              RTT 2\nServer  Client: ServerHello + Certificate\nClient  Server: Finished\nServer  Client: Finished\nClient  Server: HTTP Request             RTT 3\n\nTotal: 3 RTT before application data\n```\n\n**QUIC (with 0-RTT token):**\n```\nClient  Server: Initial + 0-RTT Data + App Request   RTT 0\n\nTotal: 0 RTT! Data sent immediately\n```\n\nThis is HUGE for edge devices that frequently reconnect!\n\n#### 4. Multiplexing Efficiency\n\n**HTTP/2 over TCP:**\n```\n\n TCP Connection                       \n     \n   HTTP/2 Multiplexing             \n    Stream 1, Stream 2, ...        \n     \n                                      \n Problem: TCP sees bytes, not streams \n Single packet loss blocks ALL streams\n\n```\n\n**HTTP/3 over QUIC:**\n```\n\n QUIC Connection                      \n  Stream 1 (independent)              \n  Stream 2 (independent)              \n  Stream 3 (independent)              \n  ...                                 \n                                      \n QUIC understands streams natively!   \n Packet loss only affects one stream  \n\n```\n\nFor Erlang distribution with millions of processes, this is critical!\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-1-quic-vs-tcp-for-distributed-erlang"},{"type":"extras","title":"Deep Dive 2: SWIM Gossip Protocol - Roadmap","doc":"**SWIM: Scalable Weakly-consistent Infection-style Process Group Membership**\n\n#### Why SWIM?\n\nTraditional heartbeat protocols don't scale:\n```\nN nodes sending heartbeats to all others:\n  Network load: O(N) messages per period\n\nExample: 1000 nodes, 1 sec heartbeat\n  = 1,000,000 messages/sec\n  = NOT SCALABLE\n```\n\nSWIM uses gossip:\n```\nEach node:\n  - Pings 1 random member per period\n  - Gossips to K random members\n\nNetwork load: O(N) messages per period\n\nExample: 1000 nodes, K=3\n  = 1000 pings + 3000 gossip = 4000 messages/sec\n  = SCALABLE!\n```\n\n#### SWIM Algorithm\n\n```\nEvery protocol period (1 second):\n\n1. SELECT random member M\n2. PING M (wait for ACK)\n    If ACK received  M is alive\n    If timeout  INDIRECT PING\n\n3. INDIRECT PING:\n    Select K random members (e.g., K=3)\n    Ask each to ping M on your behalf\n    If any ACK  M is alive\n       If all timeout  M is SUSPECT\n\n4. SUSPECT handling:\n    Don't immediately mark M as dead\n    Give time for refutation (5 seconds)\n    M can increase its \"incarnation number\" to refute\n    If no refutation  M is DEAD\n\n5. GOSSIP:\n    Select K random members\n    Send recent membership changes\n       (new members, state changes, etc.)\n```\n\n#### Suspicion Mechanism\n\n```\nTimeline:\n\nT+0s:  Node fails to respond to ping\n       \n       \n       Mark as SUSPECT (not dead!)\n       \n        Broadcast \"Node X is suspect\"\n         via gossip\n       \nT+1s:    Other nodes hear rumor\n          Try to ping Node X\n               Some may succeed!\n       \nT+2s:    Node X hears it's suspected\n          Refutes by increasing\n              incarnation number\n       \nT+5s:  \n       If no refutation  Mark as DEAD\n       \n        Broadcast \"Node X is dead\"\n```\n\nThis prevents false positives from temporary network glitches!\n\n#### Gossip Dissemination\n\n```\nEpidemic-style spread:\n\nT+0: Node A detects change (Node X joined)\n     \n        A    knows: X joined\n     \n\nT+1: A gossips to B, C, D (K=3 random)\n              \n        A      B      C      D   \n              \n                  knows       knows       knows\n\nT+2: B, C, D gossip to 3 others each (exponential spread)\n     9 nodes know\n\nT+3: 27 nodes know\n\nT+log(N): All nodes know!\n```\n\nConvergence time: **O(log N)**\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-2-swim-gossip-protocol"},{"type":"extras","title":"Deep Dive 3: Kademlia DHT for Routing - Roadmap","doc":"**Why DHT (Distributed Hash Table)?**\n\nIn large mesh networks, full mesh (N connections) doesn't scale:\n```\nNodes  Connections  Problem\n  10       45       OK\n 100     4,950      Getting expensive\n1000   499,500      IMPOSSIBLE\n```\n\nDHT enables O(log N) routing:\n```\nNodes  Hops (log N)\n  10        3\n 100        6\n1000       10\n```\n\n#### Kademlia Basics\n\n**XOR Distance Metric:**\n```\nNode IDs are 256-bit hashes (SHA256)\n\nNode A: 0x3a7f...\nNode B: 0x8c12...\n\nDistance = A XOR B\n         = 0x3a7f... XOR 0x8c12...\n         = 0xb66d...\n\nProperties:\n   d(A, B) = d(B, A)  (symmetric)\n   d(A, A) = 0\n   d(A, B) + d(B, C) >= d(A, C)  (triangle inequality)\n```\n\n**k-buckets:**\n```\nEach node maintains k-buckets for distance ranges:\n\nBucket 0:  Distance 2^0  to 2^1   (1 hop away)\nBucket 1:  Distance 2^1  to 2^2   (2 hops)\nBucket 2:  Distance 2^2  to 2^3   (4 hops)\n...\nBucket 255: Distance 2^255 to 2^256 (very far)\n\nEach bucket stores up to K nodes (e.g., K=20)\n```\n\n**Routing:**\n```\nTo send message to target T:\n\n1. Calculate distance: d = XOR(my_id, T)\n2. Find bucket for distance d\n3. Select closest node N from bucket\n4. Forward to N\n5. Repeat until reached T\n\nMax hops: log(total_nodes)\n```\n\n#### Iterative Node Lookup\n\n```erlang\nfind_node(TargetId) ->\n    % Start with K closest known nodes\n    Closest = get_k_closest(TargetId, K),\n    find_node_iter(TargetId, Closest, [], K).\n\nfind_node_iter(TargetId, Closest, Queried, K) ->\n    % Select ALPHA unqueried nodes to ask\n    ToQuery = select_closest_unqueried(Closest, Queried, ALPHA),\n\n    if\n        ToQuery =:= [] ->\n            % No more to query, return result\n            lists:sublist(Closest, K);\n        true ->\n            % Query nodes in parallel\n            Results = pmap(fun(Node) ->\n                rpc:call(Node, kademlia, get_closest, [TargetId, K])\n            end, ToQuery),\n\n            % Merge results and sort by distance\n            NewClosest = merge_and_sort(Closest, lists:flatten(Results), TargetId),\n            NewQueried = Queried ++ ToQuery,\n\n            % Check if target found\n            case lists:member(TargetId, NewClosest) of\n                true -> {found, TargetId};\n                false -> find_node_iter(TargetId, NewClosest, NewQueried, K)\n            end\n    end.\n```\n\nComplexity: **O(log N)** lookups, **O(ALPHA * log N)** messages\n\n---","ref":"macula_http3_mesh_roadmap.html#deep-dive-3-kademlia-dht-for-routing"},{"type":"extras","title":"Success Metrics - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#success-metrics"},{"type":"extras","title":"Phase 1 Success Criteria - Roadmap","doc":"-  **QUIC Transport Works**\n  - Server accepts connections\n  - Client can connect\n  - Bidirectional streams function\n  - Connection survives stream closure\n\n-  **Wire Protocol Implemented**\n  - Messages encode/decode correctly\n  - Handshake completes successfully\n  - All message types supported\n\n-  **Basic Distribution Functions**\n  - `net_kernel:connect_node/1` works\n  - `nodes()` shows connected nodes\n  - Message sending: `{Name, Node} ! Msg`\n  - Remote spawn: `spawn(Node, Fun)`\n  - Process linking works\n  - Monitoring works\n\n**Deliverable:** Two Erlang nodes communicating over HTTP/3\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-1-success-criteria"},{"type":"extras","title":"Phase 2 Success Criteria - Roadmap","doc":"-  **Node Discovery Works**\n  - Bootstrap discovery functional\n  - mDNS discovery works locally\n  - DNS SRV discovery works\n\n-  **Membership Protocol Stable**\n  - SWIM protocol running\n  - Failures detected within 10 seconds\n  - Gossip converges in O(log N) time\n  - No false positives in stable network\n\n-  **Topology Self-Organizes**\n  - Nodes form k-regular graph\n  - New nodes join smoothly\n  - Departed nodes removed from topology\n  - Healing after network partition\n\n-  **Routing Functions**\n  - Messages route through mesh\n  - DHT lookup finds nodes\n  - O(log N) hops for routing\n\n**Deliverable:** 20+ node mesh that self-heals from failures\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-2-success-criteria"},{"type":"extras","title":"Phase 3 Success Criteria - Roadmap","doc":"-  **NAT Traversal Works**\n  - STUN discovers public address\n  - ICE negotiates connectivity\n  - UDP hole punching succeeds (>80%)\n  - TURN relay works as fallback\n\n-  **Real-World Scenarios**\n  - Home router NAT traversed\n  - Corporate firewall traversed\n  - Mobile hotspot NAT traversed\n  - Symmetric NAT handled\n\n**Deliverable:** Nodes behind different NATs forming mesh\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-3-success-criteria"},{"type":"extras","title":"Phase 4 Success Criteria - Roadmap","doc":"-  **Pub/Sub Works**\n  - Topic subscriptions work\n  - Messages routed by topic\n  - Pattern matching (prefix/wildcard)\n  - Scalable (not flooding all nodes)\n\n-  **RPC Works**\n  - Synchronous RPC calls\n  - Timeouts handled correctly\n  - Error propagation works\n\n-  **WAMP Compatible**\n  - Existing WAMP clients can connect\n  - Subscribe/Publish semantics match\n  - Call/Register semantics match\n\n**Deliverable:** Example Platform PoC runs on Macula Mesh\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-4-success-criteria"},{"type":"extras","title":"Phase 5 Success Criteria - Roadmap","doc":"-  **Security Hardened**\n  - TLS certificates managed\n  - Message authentication\n  - Rate limiting prevents DoS\n  - Access control enforced\n\n-  **Production Monitoring**\n  - Prometheus metrics exported\n  - Topology visualization works\n  - Alerts fire on anomalies\n  - Distributed tracing available\n\n-  **Performance Acceptable**\n  - <10ms latency (local)\n  - <100ms latency (internet)\n  - >10,000 msg/sec throughput\n  - Scales to 1000+ nodes\n\n-  **Documentation Complete**\n  - Architecture guide published\n  - API reference docs\n  - Deployment guide\n  - Migration from Bondy guide\n\n**Deliverable:** Production-ready Macula Mesh 1.0\n\n---","ref":"macula_http3_mesh_roadmap.html#phase-5-success-criteria"},{"type":"extras","title":"Conclusion - Roadmap","doc":"Macula HTTP/3 Mesh represents a unique opportunity to build **world-class distributed infrastructure for the BEAM ecosystem**. By leveraging QUIC's modern transport capabilities, we can create a mesh network that:\n\n1. **Works anywhere** - Through NATs, firewalls, mobile networks\n2. **Scales effortlessly** - O(log N) routing, not O(N) connections\n3. **Feels native** - Standard Erlang distribution semantics\n4. **Performs brilliantly** - 0-RTT reconnection, no head-of-line blocking\n5. **Stands out** - Nobody else has this for BEAM\n\nThis is a **20-week journey** that will culminate in a \"Wow, how do they do it?\" moment.\n\n**Next Steps:**\n1. Set up development environment\n2. Integrate quicer dependency\n3. Build Week 1 deliverable (QUIC echo server/client)\n4. Start the journey! \n\n---","ref":"macula_http3_mesh_roadmap.html#conclusion"},{"type":"extras","title":"References - Roadmap","doc":"","ref":"macula_http3_mesh_roadmap.html#references"},{"type":"extras","title":"QUIC & HTTP/3 - Roadmap","doc":"- [RFC 9000: QUIC Transport Protocol](https://www.rfc-editor.org/rfc/rfc9000.html)\n- [RFC 9001: Using TLS to Secure QUIC](https://www.rfc-editor.org/rfc/rfc9001.html)\n- [RFC 9114: HTTP/3](https://www.rfc-editor.org/rfc/rfc9114.html)\n- [MsQuic Documentation](https://github.com/microsoft/msquic/tree/main/docs)","ref":"macula_http3_mesh_roadmap.html#quic-http-3"},{"type":"extras","title":"Libraries - Roadmap","doc":"- [quicer (Erlang NIF)](https://github.com/emqx/quic)\n- [xquic (Alibaba)](https://github.com/alibaba/xquic)\n- [quinn (Rust)](https://github.com/quinn-rs/quinn)","ref":"macula_http3_mesh_roadmap.html#libraries"},{"type":"extras","title":"Algorithms - Roadmap","doc":"- [SWIM: Scalable Membership Protocol](https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf)\n- [Kademlia: A Peer-to-peer Information System](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)\n- [Consistent Hashing](https://www.cs.princeton.edu/courses/archive/fall09/cos518/papers/chash.pdf)","ref":"macula_http3_mesh_roadmap.html#algorithms"},{"type":"extras","title":"Related Work - Roadmap","doc":"- [Partisan: Flexible Distributed Erlang](https://github.com/lasp-lang/partisan)\n- [Bondy: Distributed WAMP Router](https://github.com/bondy-io/bondy)\n- [Riak Core: Distributed Systems Framework](https://github.com/basho/riak_core)\n\n---\n\n**Document Version:** 1.0\n**Last Updated:** 2025-11-07\n**Author:** Macula Architecture Team\n**Status:** Proposal","ref":"macula_http3_mesh_roadmap.html#related-work"},{"type":"extras","title":"Documentation Status","doc":"# Macula HTTP/3 Mesh - Documentation Status Tracker\n\n**Last Updated**: 2025-01-08\n\nThis file tracks the completion status of all Macula HTTP/3 Mesh documentation.\n\n---","ref":"documentation_status.html"},{"type":"extras","title":"Status Legend - Documentation Status","doc":"-  **Complete**: Document is comprehensive and ready for use\n-  **Skeleton**: Structure exists, needs content\n-  **Planned**: Outlined in root index, not yet created\n-  **In Progress**: Actively being written\n\n---","ref":"documentation_status.html#status-legend"},{"type":"extras","title":"Core Architecture (P0) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Technical Roadmap](macula_http3_mesh_roadmap.md) |  Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [C4 Diagrams](macula_http3_mesh_c4_diagrams.md) |  Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [Isolation Mechanisms](macula_http3_mesh_isolation_mechanisms.md) |  Complete | P0 | 100% | Week 0 | 2025-01-08 |\n| [Documentation Root](macula_http3_mesh_root.md) |  Complete | P0 | 100% | Week 0 | 2025-01-08 |\n\n**Summary**: 4/4 complete (100%)\n\n---","ref":"documentation_status.html#core-architecture-p0"},{"type":"extras","title":"Getting Started (P1) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Quick Start Guide](macula_http3_mesh_quick_start.md) |  Complete | P1 | 100% | Week 4 | 2025-01-08 |\n| [Hello World Tutorial](macula_http3_mesh_hello_world.md) |  Complete | P1 | 100% | Week 4 | 2025-01-08 |\n\n**Summary**: 2/2 complete (100%)\n\n---","ref":"documentation_status.html#getting-started-p1"},{"type":"extras","title":"API and Protocol (P1) - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Wire Protocol Spec](macula_http3_mesh_protocol_spec.md) |  Skeleton | P1 | 10% | Week 8 | 2025-01-08 |\n| [API Reference](macula_http3_mesh_api_reference.md) |  Skeleton | P1 | 10% | Week 12 | 2025-01-08 |\n\n**Summary**: 0/2 complete (20% average progress)\n\n---","ref":"documentation_status.html#api-and-protocol-p1"},{"type":"extras","title":"Advanced Topics - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [NAT Traversal Deep Dive](macula_http3_mesh_nat_traversal.md) |  Skeleton | P2 | 10% | Week 12 | 2025-01-08 |\n| [Security Model](macula_http3_mesh_security.md) |  Skeleton | P1 | 10% | Week 16 | 2025-01-08 |\n| [Performance Tuning](macula_http3_mesh_performance.md) |  Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Observability Guide](macula_http3_mesh_observability.md) |  Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Deployment Patterns](macula_http3_mesh_deployment_patterns.md) |  Skeleton | P1 | 10% | Week 20 | 2025-01-08 |\n| [Gateway Operations](macula_http3_mesh_gateway_ops.md) |  Skeleton | P2 | 10% | Week 24 | 2025-01-08 |\n\n**Summary**: 0/6 complete (10% average progress)\n\n---","ref":"documentation_status.html#advanced-topics"},{"type":"extras","title":"Comparisons - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [WAMP Comparison](macula_http3_mesh_vs_wamp.md) |  Skeleton | P2 | 10% | Week 8 | 2025-01-08 |\n| [libp2p Comparison](macula_http3_mesh_vs_libp2p.md) |  Skeleton | P3 | 10% | Week 12 | 2025-01-08 |\n\n**Summary**: 0/2 complete (10% average progress)\n\n---","ref":"documentation_status.html#comparisons"},{"type":"extras","title":"Reference Materials - Documentation Status","doc":"| Document | Status | Priority | Completion | Target Week | Last Updated |\n|----------|--------|----------|------------|-------------|--------------|\n| [Design Decision Log](macula_http3_mesh_decisions.md) |  Skeleton | P2 | 10% | Ongoing | 2025-01-08 |\n| [Glossary](macula_http3_mesh_glossary.md) |  Skeleton | P2 | 10% | Week 4 | 2025-01-08 |\n| [FAQ](macula_http3_mesh_faq.md) |  Skeleton | P1 | 10% | Week 4 | 2025-01-08 |\n| [Troubleshooting Guide](macula_http3_mesh_troubleshooting.md) |  Skeleton | P2 | 10% | Week 20 | 2025-01-08 |\n| [Contributing Guide](macula_http3_mesh_contributing.md) |  Skeleton | P2 | 10% | Week 4 | 2025-01-08 |\n\n**Summary**: 0/5 complete (10% average progress)\n\n---","ref":"documentation_status.html#reference-materials"},{"type":"extras","title":"Overall Progress - Documentation Status","doc":"| Category | Complete | In Progress | Planned | Total | Completion % |\n|----------|----------|-------------|---------|-------|--------------|\n| Core Architecture (P0) | 4 | 0 | 0 | 4 | 100% |\n| Getting Started (P1) | 2 | 0 | 0 | 2 | 100% |\n| API and Protocol (P1) | 0 | 2 | 0 | 2 | 20% |\n| Advanced Topics | 0 | 6 | 0 | 6 | 10% |\n| Comparisons | 0 | 2 | 0 | 2 | 10% |\n| Reference Materials | 0 | 5 | 0 | 5 | 10% |\n| **TOTAL** | **6** | **15** | **0** | **21** | **34%** |\n\n---","ref":"documentation_status.html#overall-progress"},{"type":"extras","title":"Priority Breakdown - Documentation Status","doc":"","ref":"documentation_status.html#priority-breakdown"},{"type":"extras","title":"P0 (Must have before code) - Documentation Status","doc":"-  4/4 complete (100%)","ref":"documentation_status.html#p0-must-have-before-code"},{"type":"extras","title":"P1 (Required for MVP release) - Documentation Status","doc":"-  2/6 complete (33%)\n-  Need: Wire Protocol Spec, API Reference, Security Model, Deployment Patterns, FAQ","ref":"documentation_status.html#p1-required-for-mvp-release"},{"type":"extras","title":"P2 (Important for production) - Documentation Status","doc":"-  0/8 complete (0%)","ref":"documentation_status.html#p2-important-for-production"},{"type":"extras","title":"P3 (Nice to have) - Documentation Status","doc":"-  0/1 complete (0%)\n\n---","ref":"documentation_status.html#p3-nice-to-have"},{"type":"extras","title":"Completion Roadmap - Documentation Status","doc":"","ref":"documentation_status.html#completion-roadmap"},{"type":"extras","title":"Immediate Priorities (Next 2 weeks) - Documentation Status","doc":"1. **FAQ** - Quick wins, high user value\n2. **Glossary** - Reference for all other docs\n3. **Wire Protocol Spec** - Critical for implementers","ref":"documentation_status.html#immediate-priorities-next-2-weeks"},{"type":"extras","title":"Short Term (Weeks 3-8) - Documentation Status","doc":"4. **API Reference** - Essential for developers\n5. **Security Model** - Critical for production use\n6. **WAMP Comparison** - Address \"why not WAMP\" question\n7. **Design Decision Log** - Document architectural choices","ref":"documentation_status.html#short-term-weeks-3-8"},{"type":"extras","title":"Medium Term (Weeks 9-16) - Documentation Status","doc":"8. **Deployment Patterns** - Production deployment guidance\n9. **NAT Traversal Deep Dive** - Technical deep dive\n10. **Performance Tuning** - Optimization guide\n11. **Observability Guide** - Monitoring and debugging","ref":"documentation_status.html#medium-term-weeks-9-16"},{"type":"extras","title":"Long Term (Weeks 17+) - Documentation Status","doc":"12. **Gateway Operations** - Advanced realm features\n13. **Troubleshooting Guide** - Support documentation\n14. **Contributing Guide** - Community building\n15. **libp2p Comparison** - Additional comparison\n\n---","ref":"documentation_status.html#long-term-weeks-17"},{"type":"extras","title":"Contribution Workflow - Documentation Status","doc":"","ref":"documentation_status.html#contribution-workflow"},{"type":"extras","title":"How to Contribute to Documentation - Documentation Status","doc":"1. **Choose a skeleton document** from the table above\n2. **Claim it** by creating an issue or commenting in Discord\n3. **Fill in sections** following the existing structure\n4. **Update this status file** with your progress\n5. **Submit PR** when section(s) are complete\n6. **Code review** from maintainers\n7. **Merge** and update \"Last Updated\" date","ref":"documentation_status.html#how-to-contribute-to-documentation"},{"type":"extras","title":"Section-by-Section Approach - Documentation Status","doc":"You don't need to complete an entire document! Contribute section by section:\n- Pick one section from a skeleton\n- Fill it in completely\n- Submit PR with partial completion\n- Update completion % in this file","ref":"documentation_status.html#section-by-section-approach"},{"type":"extras","title":"Tracking Your Progress - Documentation Status","doc":"When working on a document:\n1. Update status from  to  (in progress)\n2. Update completion % as sections are finished\n3. When 100% complete, change status to \n4. Update \"Last Updated\" date\n\n---","ref":"documentation_status.html#tracking-your-progress"},{"type":"extras","title":"Document Quality Standards - Documentation Status","doc":"","ref":"documentation_status.html#document-quality-standards"},{"type":"extras","title":"Complete () Criteria - Documentation Status","doc":"A document is \"Complete\" when it has:\n-  All sections from skeleton filled in\n-  Code examples tested and working\n-  Diagrams added where helpful\n-  Links to related docs\n-  No  TODO markers remaining\n-  Reviewed by at least one other person","ref":"documentation_status.html#complete-criteria"},{"type":"extras","title":"Skeleton () Criteria - Documentation Status","doc":"A document is \"Skeleton\" when it has:\n-  Clear structure with section headings\n-   TODO markers indicating what needs to be written\n-  Estimated effort and priority\n-  Outline of content to be added\n\n---","ref":"documentation_status.html#skeleton-criteria"},{"type":"extras","title":"Need Help? - Documentation Status","doc":"- **Questions about what to write?** Check the document outline and related complete docs\n- **Technical questions?** Ask in Discord #documentation channel\n- **Want to collaborate?** Find others working on same doc area\n- **Stuck?** Tag a maintainer for guidance\n\n---","ref":"documentation_status.html#need-help"},{"type":"extras","title":"Maintainers - Documentation Status","doc":"Documentation maintainers who can review PRs:\n- [To be assigned]\n\n---\n\n**This file is updated automatically when documentation PRs are merged.**","ref":"documentation_status.html#maintainers"},{"type":"extras","title":"Contributing","doc":"STDIN\n   1 # Macula HTTP/3 Mesh - Contributing Guide\n   2 \n   3 **How to contribute to Macula**\n   4 \n   5 **Status**:  SKELETON - Needs completion\n   6 **Priority**: P2\n   7 **Estimated effort**: 4 hours\n   8 \n   9 ---\n  10 \n  11","ref":"macula_http3_mesh_contributing.html"},{"type":"extras","title":"Welcome - Contributing","doc":"12 \n  13  **TODO**: Welcome message for contributors.\n  14 \n  15 ---\n  16 \n  17","ref":"macula_http3_mesh_contributing.html#welcome"},{"type":"extras","title":"Code of Conduct - Contributing","doc":"18 \n  19  **TODO**: Community code of conduct.\n  20 \n  21 ---\n  22 \n  23","ref":"macula_http3_mesh_contributing.html#code-of-conduct"},{"type":"extras","title":"Development Setup - Contributing","doc":"24 \n  25  **TODO**: How to set up development environment.\n  26 \n  27 **Sections needed**:\n  28 - Prerequisites\n  29 - Fork and clone\n  30 - Install dependencies\n  31 - Run tests\n  32 - Start local mesh\n  33 \n  34 ---\n  35 \n  36","ref":"macula_http3_mesh_contributing.html#development-setup"},{"type":"extras","title":"Testing Requirements - Contributing","doc":"37 \n  38  **TODO**: Testing standards.\n  39 \n  40 **Topics**:\n  41 - Unit tests (EUnit/ExUnit)\n  42 - Integration tests\n  43 - Property-based tests (PropEr/StreamData)\n  44 - Coverage requirements\n  45 \n  46 ---\n  47 \n  48","ref":"macula_http3_mesh_contributing.html#testing-requirements"},{"type":"extras","title":"Code Style Guide - Contributing","doc":"49 \n  50  **TODO**: Erlang/Elixir coding conventions.\n  51 \n  52 **Topics**:\n  53 - Formatting (mix format, erlfmt)\n  54 - Naming conventions\n  55 - Documentation requirements\n  56 - Type specifications\n  57 \n  58 ---\n  59 \n  60","ref":"macula_http3_mesh_contributing.html#code-style-guide"},{"type":"extras","title":"Documentation Requirements - Contributing","doc":"61 \n  62  **TODO**: How to document code.\n  63 \n  64 ---\n  65 \n  66","ref":"macula_http3_mesh_contributing.html#documentation-requirements"},{"type":"extras","title":"Pull Request Process - Contributing","doc":"67 \n  68  **TODO**: PR workflow.\n  69 \n  70 **Steps**:\n  71 1. Create feature branch\n  72 2. Make changes\n  73 3. Write tests\n  74 4. Update docs\n  75 5. Submit PR\n  76 6. Code review\n  77 7. Merge\n  78 \n  79 ---\n  80 \n  81","ref":"macula_http3_mesh_contributing.html#pull-request-process"},{"type":"extras","title":"Release Process - Contributing","doc":"82 \n  83  **TODO**: How releases are managed.\n  84 \n  85 ---\n  86 \n  87","ref":"macula_http3_mesh_contributing.html#release-process"},{"type":"extras","title":"Community Channels - Contributing","doc":"88 \n  89  **TODO**: Where to get help and discuss.\n  90 \n  91 **Channels**:\n  92 - GitHub Discussions\n  93 - Discord server\n  94 - Mailing list\n  95 - Monthly community calls\n  96 \n  97 ---\n  98 \n  99","ref":"macula_http3_mesh_contributing.html#community-channels"},{"type":"extras","title":"Roadmap and Feature Requests - Contributing","doc":"100 \n 101  **TODO**: How to propose new features.\n 102 \n 103 ---\n 104 \n 105","ref":"macula_http3_mesh_contributing.html#roadmap-and-feature-requests"},{"type":"extras","title":"Reporting Issues - Contributing","doc":"106 \n 107  **TODO**: Bug report template and guidelines.\n 108 \n 109 ---\n 110 \n 111","ref":"macula_http3_mesh_contributing.html#reporting-issues"},{"type":"extras","title":"Recognition - Contributing","doc":"112 \n 113  **TODO**: How contributors are recognized.\n 114 \n 115 ---\n 116 \n 117 **Last Updated**: 2025-01-08\n 118 **Contributors**: [Add names as sections are completed]","ref":"macula_http3_mesh_contributing.html#recognition"}],"proglang":"erlang","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}